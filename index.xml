<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>42th openheart</title>
    <link>https://www.openheart.icu/</link>
    <description>Recent content on 42th openheart</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>ALL RIGHTS RESERVED KRIS NIE</copyright>
    <lastBuildDate>Sat, 25 Jul 2020 00:14:11 +0000</lastBuildDate>
    
        <atom:link href="https://www.openheart.icu/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>C# in Depth</title>
        <link>https://www.openheart.icu/cs/csharp-in-depth/</link>
        <pubDate>Sat, 25 Jul 2020 00:14:11 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/csharp-in-depth/</guid>
        <description>42th openheart https://www.openheart.icu/cs/csharp-in-depth/ -&lt;p&gt;&lt;em&gt;本文为「C# in Depth」(4th edition)学习记录。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;implementing-the-singleton-pattern-in-chttpscsharpindepthcomarticlessingleton&#34;&gt;&lt;a href=&#34;https://csharpindepth.com/articles/Singleton&#34;&gt;Implementing the Singleton Pattern in C#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在C＃中实现单例模式。该模式是非常常见的设计模式之一，某个对象全局只需要一个实例时，就可以使用单例模式。它的优点也显而易见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它能够避免对象重复创建，节约空间并提升效率&lt;/li&gt;
&lt;li&gt;避免由于操作不同实例导致的逻辑错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;以下是原文作者Jon Skeet 对C#单例模式的介绍。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;单例模式是软件工程中最著名的模式之一。本质上，单例是仅允许创建其自身的单个实例的类，并且通常提供对该实例的简单访问。最常见的是，单例在创建实例时不允许指定任何参数，否则对实例的第二次请求但参数不同可能会出现问题！ （如果应该为具有相同参数的所有请求访问相同的实例，则使用工厂模式更为合适。）本文仅涉及不需要参数的情况。通常，单例的要求是它们是懒惰地创建的，即：直到首次需要实例时才创建实例。&lt;/p&gt;
&lt;p&gt;在C＃中有多种不同的方式来实现单例模式。我将在这里以从简到难顺序（&lt;em&gt;in reverse order of elegance&lt;/em&gt;）介绍它们，从最常见的线程安全性开始，逐步发展为完全延迟加载，线程安全，简单且高性能的版本。&lt;/p&gt;
&lt;p&gt;所有这些实现都有四个共同的特征，但是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个构造函数，私有且无参数。这样可以防止其他类实例化它（这将违反模式）。请注意，它还防止了子类化（&lt;em&gt;subclassing&lt;/em&gt;）如果一个单例可以被子类化一次，则可以被子类化两次，并且如果每个子类都可以创建一个实例，则将违反（&lt;em&gt;violated&lt;/em&gt;）该模式。如果您需要基本类型的单个实例，则可以使用工厂模式，但是直到运行时才知道确切的类型。&lt;/li&gt;
&lt;li&gt;该类是密封的。严格来说，由于上述几点，这是不必要的，但可以帮助&lt;code&gt;JIT&lt;/code&gt;进行更多优化。&lt;/li&gt;
&lt;li&gt;一个静态变量，其中包含对创建的单个实例的引用（如果有）。&lt;/li&gt;
&lt;li&gt;公共静态方法是获取对创建的单个实例的引用，并在必要时创建一个实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，所有这些实现还使用公共静态属性&lt;code&gt;Instance&lt;/code&gt;作为访问实例的方式。在所有情况下，都可以轻松地将属性转换为方法，而不会影响线程安全性或性能。&lt;/p&gt;
&lt;h2 id=&#34;first-version---not-thread-safe&#34;&gt;First version - not thread-safe&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// Bad code! Do not use!
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance
  {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;
    {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (instance == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
      {
        instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton();
      }
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; instance;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如前所述，以上内容不是线程安全的。&lt;/p&gt;
&lt;p&gt;两个不同的线程都可以执行判断（&lt;em&gt;evaluated the test&lt;/em&gt;）&lt;code&gt;if(instance == null)&lt;/code&gt;并发现它为&lt;code&gt;true&lt;/code&gt;，然后都创建实例，这违反了单例模式。请注意，实际上可能已经在计算表达式之前创建了实例，但是内存模型不能保证实例的新值能暴露给其他线程，除非已传递适当的内存屏障（互斥锁）（&lt;em&gt;memory barriers&lt;/em&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;second-version---simple-thread-safety&#34;&gt;Second version - simple thread-safety&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C#&#34; data-lang=&#34;C#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;object&lt;/span&gt; padlock = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;object&lt;/span&gt;();

  Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance
  {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;
    {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;lock&lt;/span&gt; (padlock)
      {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (instance == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
        {
          instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton();
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; instance;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此实现是线程安全的。线程在共享对象上加锁（&lt;em&gt;takes out a lock&lt;/em&gt;），然后在创建实例之前检查是否已创建实例。这可以解决内存屏障问题（因为锁定可确保所有读取均在获取锁之后逻辑发生，而解锁可确保所有写入均在锁释放之前逻辑发生）并确保只有一个线程将创建一个实例（仅一个线程一次可以位于代码的该部分中，到第二个线程进入该线程时，第一个线程将创建该实例，因此该表达式的计算结果为&lt;code&gt;false&lt;/code&gt;）。不幸的是，每次请求实例时都需要获取锁，因此性能会受到影响。&lt;/p&gt;
&lt;p&gt;请注意，我没有像此实现的某些版本那样锁定&lt;code&gt;typeof(Singleton)&lt;/code&gt;，而是锁定了类私有的静态变量的值。锁定其他类可以访问和锁定的对象（such as the type）可能会导致性能问题甚至死锁。这是我的一般样式首选项-尽可能仅锁定专门为锁定目的而创建的对象，或者为特定目的而将其锁定在哪个文档上（例如用于等待/触发队列）。通常，此类对象应为使用它们的类所专用。这有助于使编写线程安全的应用程序变得更加容易。&lt;/p&gt;
&lt;h2 id=&#34;third-version---attempted-thread-safety-using-double-check-locking&#34;&gt;Third version - attempted thread-safety using double-check locking&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// Bad code! Do not use!
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;object&lt;/span&gt; padlock = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;object&lt;/span&gt;();

  Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance
  {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;
    {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (instance == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
      {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;lock&lt;/span&gt; (padlock)
        {
          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (instance == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
          {
            instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton();
          }
        }
      }
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; instance;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此实现方式（&lt;em&gt;implementation&lt;/em&gt;）尝试不再每次都加锁，同时保证线程安全。遗憾的是，该模式有四个缺点（&lt;em&gt;there are four downsides to the pattern&lt;/em&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它在Java中不起作用。这么说这似乎有些不合理，但是值得一提的是，您是否需要Java中的单例模式，C＃程序员也很可能是Java程序员。 Java内存模型无法确保在将对新对象的引用分配给实例之前，执行完构造函数。 Java内存模型针对1.5版进行了重新加工，但是在此之后，在没有易失性变量的情况下，双重检查锁定仍然被破坏（像C＃一样）。&lt;/li&gt;
&lt;li&gt;没有任何内存障碍，它在&lt;code&gt;ECMA CLI&lt;/code&gt;规范中也被打破。在.NET 2.0内存模型（比ECMA规范更强）下，它很可能是安全的，但我宁愿不依赖那些更强的语义，尤其是在对安全性有任何疑问的情况下。将实例变量设置为&lt;code&gt;volatile&lt;/code&gt;也有效，就像显式的内存屏障调用一样，但这样的话即使是大佬也无法确切地确定需要哪些屏障。我倾向于不去用大佬们有争议的方法！&lt;/li&gt;
&lt;li&gt;很容易出错。该模式必须与上面的完全一样-任何重大更改都可能影响性能或正确性。&lt;/li&gt;
&lt;li&gt;它的性能仍然不如后来的实现方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;fourth-version---not-quite-as-lazy-but-thread-safe-without-using-locks&#34;&gt;Fourth version - not quite as lazy, but thread-safe without using locks&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; Singleton instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton();

  &lt;span style=&#34;color:#228b22&#34;&gt;// Explicit static constructor to tell C# compiler
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// not to mark type as beforefieldinit
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance
  {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;
    {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; instance;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如您所见，这确实非常简单，那它是怎么实现线程安全的，它有多懒呢？Well，将C＃中的静态构造函数指定为仅在创建类的实例或引用静态成员时执行，并且每个&lt;code&gt;AppDomain&lt;/code&gt;仅执行一次。鉴于无论其他情况如何都需要执行对新构造的类型的检查，因此比在前面的示例中添加额外的检查要快。&lt;/p&gt;
&lt;p&gt;但是，这种方法也有一些缺点（&lt;em&gt;wrinkles&lt;/em&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它没有其他实现那么懒。特别是，当具有实例以外的静态成员时，对这些成员的首次引用将涉及创建实例。在下一个实现中将对此进行更正。&lt;/li&gt;
&lt;li&gt;如果一个静态构造函数调用另一个而又再次调用第一个静态构造函数，则会带来复杂性。请查阅&lt;code&gt;.NET规范（currently section 9.5.3 of partition II&lt;/code&gt;），以获取有关类型初始值设定项的确切性质的更多详细信息。它们不太可能会影响程序（&lt;em&gt;they&amp;rsquo;re unlikely to bite you&lt;/em&gt;），但值得一提的是，静态构造函数在生命周期内存在互相引用（&lt;em&gt;the consequences of static constructors which refer to each other in a cycle&lt;/em&gt;）。&lt;/li&gt;
&lt;li&gt;只有当类型未使用称为&lt;code&gt;beforefieldinit&lt;/code&gt;的特殊标志进行标记时，.NET才能保证类型初始化程序的惰性。不幸的是，C＃编译器（至少是.NET 1.1运行时中提供的）将所有没有静态构造函数（即看起来像构造函数但被标记为静态的块）的类型都标记为&lt;code&gt;beforefieldinit&lt;/code&gt;。我有一篇&lt;a href=&#34;https://csharpindepth.com/articles/BeforeFieldInit&#34;&gt;文章&lt;/a&gt;，详细介绍了这个问题。还要注意，它会影响性能，如页面底部所述。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种实现方式可以采取的一种捷径：仅使实例成为公共静态只读变量，并完全摆脱该属性。这使得基本框架代码绝对很小！但是，许多人更喜欢拥有属性，以防将来需要采取进一步的措施，并且&lt;code&gt;JIT&lt;/code&gt;内联可能使性能相同。 （请注意，如果您需要惰性，则仍然需要静态构造函数本身。）&lt;/p&gt;
&lt;h2 id=&#34;fifth-version---fully-lazy-instantiation&#34;&gt;Fifth version - fully lazy instantiation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance
  {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt; { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; Nested.instance; }
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Nested&lt;/span&gt;
  {
    &lt;span style=&#34;color:#228b22&#34;&gt;// Explicit static constructor to tell C# compiler
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;// not to mark type as beforefieldinit
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Nested()
    {
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;internal&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; Singleton instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里，实例化是由对嵌套类的静态成员的第一次引用触发的，该实例仅在&lt;code&gt;Instance&lt;/code&gt;中发生。这意味着该实现完全是懒的，同事具有先前性能的所有性能优势。请注意，尽管嵌套类可以访问封闭类的私有成员，但事实并非如此，因此这里需要实例化。但是，由于类本身是私有的，所以这不会引起任何其他问题。但是，为了使实例化变得懒惰，代码有些复杂。&lt;/p&gt;
&lt;h2 id=&#34;sixth-version---using-net-4s-lazyt-type&#34;&gt;Sixth version - using .NET 4&amp;rsquo;s &lt;code&gt;Lazy&amp;lt;T&amp;gt;&lt;/code&gt; type&lt;/h2&gt;
&lt;p&gt;如果使用的是.NET 4（或更高版本），则可以使用&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd642331.aspx&#34;&gt;System.Lazy&lt;/a&gt;类型使懒变得非常简单。您需要做的就是将委托传递给构造函数，该构造函数调用Singleton构造函数，使用&lt;code&gt;lambda表达式&lt;/code&gt;最容易完成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; Lazy&amp;lt;Singleton&amp;gt; lazy = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Lazy&amp;lt;Singleton&amp;gt; (() =&amp;gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton());

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance { 
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt; { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; lazy.Value; }
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Singleton()
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它很简单，性能也很好。如果需要，还可以使用&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd642334.aspx&#34;&gt;IsValueCreated&lt;/a&gt;属性检查实例是否已创建。&lt;/p&gt;
&lt;p&gt;上面的代码隐式地使用&lt;code&gt;LazyThreadSafetyMode.ExecutionAndPublication&lt;/code&gt;作为&lt;code&gt;Lazy&amp;lt;Singleton&amp;gt;&lt;/code&gt;的线程安全模式。根据您的要求，您可能希望尝试其他模式。&lt;/p&gt;
&lt;h2 id=&#34;performance-vs-laziness&#34;&gt;Performance vs laziness&lt;/h2&gt;
&lt;p&gt;在许多情况下，您实际上并不需要完全的懒，除非类初始化时需要做特别耗时的事情，或者在其他地方有副作用，否则可以忽略上面有关显式静态构造函数的实现方法。这可以提高性能，因为它允许&lt;code&gt;JIT&lt;/code&gt;编译器进行一次检查（例如，在方法开始时进行检查），以确保类型已初始化，然后从此开始进行假定。如果您的单例实例是在相对紧凑的循环中引用的，则这可能会（相对）产生明显的性能差异。您应该确定是否需要完全延迟的实例化，并在类中适当地记录此决定。&lt;/p&gt;
&lt;p&gt;该页面存在的很多原因是人们试图变得聪明（&lt;em&gt;A lot of the reason for this page&amp;rsquo;s existence is people trying to be clever&lt;/em&gt;），因此提出了双重检查的锁定算法。人们常常认为加锁是付出昂贵代价的操作，这是普遍的并且是错误的。我编写了一个非常快速的基准测试，它以十亿次尝试各种变体，以循环方式获取单例实例。这并不是十分科学（&lt;em&gt;It&amp;rsquo;s not terribly scientific&lt;/em&gt;），因为在现实生活中，您可能想知道，如果每次迭代实际上都涉及到对获取单例的方法的调用等，该过程有多快。但是，它确实显示了重要的意义。在我的笔记本电脑上，最慢的解决方案（约为5倍）是加锁的解决方法（解决方案2）。那重要吗？当您记住它仍然可以在40秒内成功获取十亿次单例时，可能就不会了。 （注意：本文最初是在很早以前写的，我希望现在可以有更好的性能。）这意味着，如果您“仅”每秒获取40万次单例，则获取的成本将不断增加达到1％的性能。因此，改善性能并不会起到太大作用。现在，如果您经常使用单例模式，您是否是在循环中使用它？如果您非常在乎提高性能，为什么不在循环之外声明局部变量，请获取一次单例然后循环。所以，即使是最慢的实现也很容易做到。&lt;/p&gt;
&lt;p&gt;我非常有兴趣看到一个现实世界的应用程序，在该应用程序中，使用简单的加锁和使用较快速的解决方案之一之间的差异实际上带来了显着的性能差异。&lt;/p&gt;
&lt;h2 id=&#34;exceptions&#34;&gt;Exceptions&lt;/h2&gt;
&lt;p&gt;有时，您需要在单例构造函数中进行工作，这可能会引发异常，但对整个应用程序可能不会致命。您的应用程序可能能够解决问题，并希望重试。在这个阶段，使用类型初始值设定项构造单例成为问题。不同的运行时对这种情况的处理方式不同，但是我不知道哪个运行者可以做所需的事情（再次运行类型初始化器），即使这样做，您的代码也会在其他运行时中损坏。为了避免这些问题，我建议使用页面上列出的第二种模式，只需使用一个简单的锁，然后每次都要进行检查，如果尚未成功构建该实例，则可以在方法/属性中进行构建。&lt;/p&gt;
&lt;h2 id=&#34;conclusion-modified-slightly-on-january-7th-2006-updated-feb-12th-2011&#34;&gt;Conclusion (modified slightly on January 7th 2006; updated Feb 12th 2011)&lt;/h2&gt;
&lt;p&gt;在C＃中有多种不同的方式来实现单例模式。读者写信给我，详细介绍了他封装同步方面的一种方式，尽管我承认这在某些非常特殊的情况下（特别是在您想要非常高性能的情况下，并且能够确定单例是否已经被使用的能力）很有用。创建，并且完全懒惰（无论是否调用其他静态成员）。我个人认为这种情况不会经常出现，值得在此页面上进行进一步介绍，但是如果您遇到这种情况，请发&lt;a href=&#34;skeet@pobox.com&#34;&gt;邮件&lt;/a&gt;给我。&lt;/p&gt;
&lt;p&gt;我的个人偏爱是解决方案4：通常，我只有在我需要能够在不触发初始化的情况下调用其他静态方法，或者如果我需要知道单例是否已经被实例化，或者是否需要知道单例是否已被实例化时才不会使用该方法。我不记得我上次遇到这种情况，假设我有过，在这种情况下，我可能会选择解决方案2，该解决方案仍然很不错，而且很容易就可以实现。&lt;/p&gt;
&lt;p&gt;解决方案5很优雅，但比2或4棘手，而且正如我上面所说，它提供的好处似乎很少有用。如果您使用的是.NET 4，则解决方案6是实现懒惰的一种更简单的方法，它还具有明显的惰性。我目前倾向于仅通过习惯就使用解决方案4，但是如果我与经验不足的开发人员一起工作，我很可能会选择解决方案6作为一种简单且普遍适用的模式开始。&lt;/p&gt;
&lt;p&gt;（我不会使用解决方案1，因为它是有缺陷的，我不会使用解决方案3，因为它比不过5。）&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://csharpindepth.com/articles/Singleton&#34;&gt;https://csharpindepth.com/articles/Singleton&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/leolion/p/10241822.html&#34;&gt;https://www.cnblogs.com/leolion/p/10241822.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/csharp-in-depth/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Distributed cache</title>
        <link>https://www.openheart.icu/cs/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</link>
        <pubDate>Fri, 24 Jul 2020 00:00:50 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</guid>
        <description>42th openheart https://www.openheart.icu/cs/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/ -&lt;p&gt;&lt;em&gt;简单了解分布式缓存的各种概念&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h1&gt;
&lt;p&gt;缓存雪崩我们可以简单的理解为：由于原有&lt;strong&gt;缓存失效&lt;/strong&gt;，新缓存未到期间所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。&lt;/p&gt;
&lt;p&gt;关键词：缓存失效，针对这种情况一般有三种处理办法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;为 key 设置不同的缓存失效时间。&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;第二、第三中方法在面试中均被提到过，很遗憾我只想到了第一种解决办法（纯粹靠蒙），被连续问到两次后觉得分布式缓存需要整体都了解一下，于是去查资料整理了本文&lt;/em&gt; 😁&lt;/p&gt;
&lt;h1 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h1&gt;
&lt;p&gt;缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在 缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请 求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。&lt;/p&gt;
&lt;p&gt;有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈 希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存 储系统的查询压力。&lt;/p&gt;
&lt;p&gt;另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不 存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。&lt;/p&gt;
&lt;h1 id=&#34;缓存预热&#34;&gt;缓存预热&lt;/h1&gt;
&lt;p&gt;缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。&lt;/p&gt;
&lt;h1 id=&#34;缓存更新&#34;&gt;缓存更新&lt;/h1&gt;
&lt;p&gt;缓存更新除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：&lt;/p&gt;
&lt;p&gt;（1）定时去清理过期的缓存；&lt;/p&gt;
&lt;p&gt;（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。&lt;/p&gt;
&lt;h1 id=&#34;缓存降级&#34;&gt;缓存降级&lt;/h1&gt;
&lt;p&gt;当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 降级的最终目的是保证核心服务可用，即使是有损的。 而且有些服务是无法降级的（如加入购物车、结算）。&lt;/p&gt;
- https://www.openheart.icu/cs/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Reliability&amp;Availability</title>
        <link>https://www.openheart.icu/cs/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7/</link>
        <pubDate>Fri, 24 Jul 2020 00:00:50 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7/</guid>
        <description>42th openheart https://www.openheart.icu/cs/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7/ -&lt;h1 id=&#34;区分高可靠性与高可用性&#34;&gt;区分高可靠性与高可用性&lt;/h1&gt;
&lt;p&gt;Reliability和Availability分别对应可靠性和可用性, 这两个概念既有区别也有联系:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reliability定义为一个服务连续无故障运行的时间，无故障运行的时间越长，可靠性就越高。&lt;/li&gt;
&lt;li&gt;Availiability定义为在足够长的时间里，比如一年的时间里，一个服务可用的时间，服务可用时间越长越好。一般用可服务时间除于总时间算出一个百分比，用百分比作为度量。比如一个服务如果有5个9的可用性，指的就是一年里99.999%时间里服务都是可用的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有两个极端的例子可以很好的说明这两个概念的区别:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假想一个服务，可靠性很高，平均来说可以稳定运行10年，但是一旦服务中断，要用一年的时间来恢复，那么它的可用性只有90%。&lt;/li&gt;
&lt;li&gt;假想另一个服务，可靠性很差，运行10秒就会宕机，但是恢复服务只需要1ms, 那么它的可用性是99.99%&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从这两个极端的例子可以看出，提高可用性有两条路:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一是提高可靠性，当然影响可靠性的原因有很多，包括硬件，软件，网络，运维等。但是有人做过统计，软件的bug是影响可靠性的最主要的因素。并且提高软件质量相较于使用更可靠的硬件也算成本较低的方式了，&lt;/li&gt;
&lt;li&gt;二是减少恢复时间，一旦出现宕机，如果能在秒级恢复，那对业务影响是很小的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;高可靠性的实现&#34;&gt;高可靠性的实现&lt;/h1&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;高可用性的实现&#34;&gt;高可用性的实现&lt;/h1&gt;
&lt;p&gt;高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。&lt;/p&gt;
&lt;p&gt;方法论上，高可用是通过&lt;strong&gt;冗余+自动故障转移&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;p&gt;整个互联网分层系统架构的高可用，又是通过每一层的&lt;strong&gt;冗余+自动故障转移&lt;/strong&gt;来综合实现的，具体的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移&lt;/li&gt;
&lt;li&gt;【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移&lt;/li&gt;
&lt;li&gt;【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移&lt;/li&gt;
&lt;li&gt;【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性&lt;/li&gt;
&lt;li&gt;【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移&lt;/li&gt;
&lt;li&gt;【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>URL</title>
        <link>https://www.openheart.icu/cs/url/</link>
        <pubDate>Wed, 22 Jul 2020 20:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/url/</guid>
        <description>42th openheart https://www.openheart.icu/cs/url/ -&lt;h1 id=&#34;url解析&#34;&gt;URL解析&lt;/h1&gt;
&lt;h2 id=&#34;urlencode&#34;&gt;UrlEncode&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;符号&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Encode&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;+&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;表示空格&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%2B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;(空格)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以用+号替代&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;/&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分隔目录和子目录&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%2F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;？&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分隔实际的URL和参数&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%3F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;%&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定特殊字符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;#&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;表示书签&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;amp;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;URL 中指定的参数间的分隔符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;URL 中指定参数的值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%3D&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
- https://www.openheart.icu/cs/url/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Interesting</title>
        <link>https://www.openheart.icu/cs/interesting/</link>
        <pubDate>Wed, 22 Jul 2020 19:45:28 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/interesting/</guid>
        <description>42th openheart https://www.openheart.icu/cs/interesting/ -&lt;h3 id=&#34;texturesjshttpsriccardoscalcoittextures&#34;&gt;&lt;a href=&#34;https://riccardoscalco.it/textures/&#34;&gt;Textures.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 JS 纹理库，基于 D3.js&lt;/p&gt;
&lt;h3 id=&#34;elevatorjshttpsgithubcomtholmanelevatorjs&#34;&gt;&lt;a href=&#34;https://github.com/tholman/elevator.js&#34;&gt;elevator.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Finally, a &amp;ldquo;back to top&amp;rdquo; button that behaves like a real elevator, by adding elevator music to quietly soothe the awkwardness that can ensue when being smoothly scrolled to the top of the screen.&lt;/p&gt;
&lt;p&gt;This is very serious stuff, &lt;a href=&#34;http://tholman.com/elevator.js&#34;&gt;here&amp;rsquo;s a demo&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;一个使得“回到顶部”的网页滚动，具有电梯效果的 JS 库。&lt;/p&gt;
&lt;h3 id=&#34;mownedhttpsmownedcom&#34;&gt;&lt;a href=&#34;https://mowned.com/&#34;&gt;Mowned&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个手机数据库&lt;/p&gt;
&lt;h3 id=&#34;javascript-生成艺术图形教程httpsgenerativeartistrycomtutorials&#34;&gt;&lt;a href=&#34;https://generativeartistry.com/tutorials/&#34;&gt;JavaScript 生成艺术图形教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;介绍 如何使用JavaScript 生成8种艺术图形。&lt;/p&gt;
&lt;h3 id=&#34;使用-raspberry-pi-学习操作系统开发httpss-matyukevichgithubioraspberry-pi-os&#34;&gt;&lt;a href=&#34;https://s-matyukevich.github.io/raspberry-pi-os/&#34;&gt;使用 Raspberry Pi 学习操作系统开发&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这是一个免费英文教程，教大家怎么用树莓派，一步步开发一个简单的操作系统内核，每一步都有实例代码&lt;/p&gt;
&lt;h3 id=&#34;vim-的由来httpspragmaticpineapplecomhow-did-vim-become-so-popular&#34;&gt;&lt;a href=&#34;https://pragmaticpineapple.com/how-did-vim-become-so-popular/&#34;&gt;Vim 的由来&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Vim 有30多年历史，目前依然是最流行的编辑器之一。本文简要地回顾了历史，它的一些主要的设计决定，到底是怎么来的&lt;/p&gt;
&lt;h3 id=&#34;makefile-的静态网站实现httpsmetinnextcorgpoststhe_idea_of_makefile_bloghtml&#34;&gt;&lt;a href=&#34;https://metin.nextc.org/posts/The_Idea_Of_Makefile_Blog.html&#34;&gt;Makefile 的静态网站实现&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;现在有各种各样的静态网站工具，比如 Jekyll 和 Hugo 等。作者提出，Makefile 也可以用来实现静态网站，这样就不需要任何外部工具了，只维护一个 Makefile 配置文件即可&lt;/p&gt;
&lt;h3 id=&#34;字体反爬的攻与防httpscjtingme20200701douyu-crawler-and-font-anti-crawling&#34;&gt;&lt;a href=&#34;https://cjting.me/2020/07/01/douyu-crawler-and-font-anti-crawling/&#34;&gt;字体反爬的攻与防&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者因为业务原因需要爬取一批斗鱼主播的相关数据，结果发现斗鱼使用了一种很有意思的反爬技术：字体反爬&lt;/p&gt;
&lt;h3 id=&#34;分页查询不要使用-offset-和-limit-语法httpshackernooncomplease-dont-use-offset-and-limit-for-your-pagination-8ux3u4y&#34;&gt;&lt;a href=&#34;https://hackernoon.com/please-dont-use-offset-and-limit-for-your-pagination-8ux3u4y&#34;&gt;分页查询不要使用 OFFSET 和 LIMIT 语法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;数据查询时，如果数据多，就需要分页，一般使用 OFFSET 和 LIMIT 语法。这篇文章提出，这样做不好，耗费资源，有性能问题&lt;/p&gt;
&lt;h3 id=&#34;git-多行提交信息的简单方法httpswwwstefanjudiscomtoday-i-learnedgit-commit-accepts-several-message-flags-m-to-allow-multiline-commits&#34;&gt;&lt;a href=&#34;https://www.stefanjudis.com/today-i-learned/git-commit-accepts-several-message-flags-m-to-allow-multiline-commits/&#34;&gt;Git 多行提交信息的简单方法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt;命令的&lt;code&gt;-m&lt;/code&gt;参数用来指定提交信息，但是这样提交的信息只有一行。本文介绍实现多行信息的简单方法&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;git co -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;commit title&amp;#34;&lt;/span&gt; -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;commit description&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;盲文的由来httpsstitcherioblogbraille-and-the-history-of-software&#34;&gt;&lt;a href=&#34;https://stitcher.io/blog/braille-and-the-history-of-software&#34;&gt;盲文的由来&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如题&lt;/p&gt;
&lt;h3 id=&#34;漫长的雨httpwwwsamwellernetbradbury-120181129the-essential-bradbury&#34;&gt;&lt;a href=&#34;http://www.samweller.net/bradbury-1/2018/11/29/the-essential-bradbury&#34;&gt;漫长的雨&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;《漫长的雨》（The long rain，&lt;strong&gt;&lt;a href=&#34;https://www.sohu.com/a/337866552_771944&#34;&gt;中译全文&lt;/a&gt;&lt;/strong&gt;）是美国科幻小说作家雷·布拉德伯里（Ray Bradbury）1950年发表的一篇短篇小说。&lt;/p&gt;
&lt;p&gt;它讲述四个宇航员因为火箭失事，来到一个不停下雨的星球。这个星球永远在下瓢泼大雨，过去10年一秒都没有停过。宇航员冒着雨水，在丛林里面穿行，拼命寻找前人修建的“阳光穹顶”，那里是一个大屋顶，有温暖的人造阳光，以及充足的食物和休息的场所。&lt;/p&gt;
&lt;p&gt;小说的开头是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;大雨，永远的雨，升腾着汗水和蒸汽的雨。这是密集的瓢泼大雨，像鞭子一样打在眼睛上，飞溅到脚踝上。它是一场淹没其他所有雨水的雨，让人遗忘所有关于雨水的记忆。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6个最常见的网页可访问性问题httpsblogscottlogiccom202007026-most-common-accessibility-problemshtmlempty-links-and-empty-buttons&#34;&gt;&lt;a href=&#34;https://blog.scottlogic.com/2020/07/02/6-most-common-accessibility-problems.html#empty-links-and-empty-buttons&#34;&gt;6个最常见的网页可访问性问题&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可访问性（accessibility）指的是，网页对生理缺陷的用户是否友好。本文总结了6个最常见的可访问性问题及其解决方法&lt;/p&gt;
&lt;h3 id=&#34;伪随机数生成器httpsgithubcombryccodeblobmasterjshashprngsmd&#34;&gt;&lt;a href=&#34;https://github.com/bryc/code/blob/master/jshash/PRNGs.md&#34;&gt;伪随机数生成器&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;伪随机数指的是通过一种算法，由种子值得到的随机数。本文介绍了几种简单的伪随机数算法&lt;/p&gt;
&lt;h3 id=&#34;75行代码入门-webglhttpsavikdascom20200708barebones-webgl-in-75-lines-of-codehtml&#34;&gt;&lt;a href=&#34;https://avikdas.com/2020/07/08/barebones-webgl-in-75-lines-of-code.html&#34;&gt;75行代码入门 WebGL&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WebGL 是浏览器对 OpenGL API 的调用接口，可以在浏览器里面实现 3D 动画。本文用一个简短的例子，介绍了这个 API。这只是一篇简介，另有&lt;a href=&#34;https://www.toptal.com/javascript/3d-graphics-a-webgl-tutorial&#34;&gt;完整的 WebGL 教程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;redisearchhttpsossredislabscomredisearch&#34;&gt;&lt;a href=&#34;https://oss.redislabs.com/redisearch/&#34;&gt;RediSearch&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;以 Redis 作为后端的全文搜索引擎，支持中文&lt;/p&gt;
&lt;h3 id=&#34;onelook-thesaurushttpswwwonelookcomthesaurus&#34;&gt;&lt;a href=&#34;https://www.onelook.com/thesaurus/&#34;&gt;OneLook Thesaurus&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;英语的同义词词典，可以查询同义词，也可以根据描述返回对应的词（比如 &lt;a href=&#34;https://www.onelook.com/thesaurus/?s=large%20birds&amp;amp;loc=revfp&#34;&gt;large bird&lt;/a&gt; 对应哪些词），加载速度很快&lt;/p&gt;
&lt;h3 id=&#34;crdttechhttpscrdttech&#34;&gt;&lt;a href=&#34;https://crdt.tech/&#34;&gt;CRDT.tech&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;CRDT 是一种数据结构，用于分布式网络的数据同步，最典型的例子就是多人同时编辑文档。该网站收集了 CRDT 的相关资料&lt;/p&gt;
&lt;h3 id=&#34;progressive-app-storehttpsprogressiveappstorehome&#34;&gt;&lt;a href=&#34;https://progressiveapp.store/home&#34;&gt;Progressive App Store&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个渐进式 App 的在线商店，收集各种 Progessive App，是网友搭建的&lt;/p&gt;
&lt;h3 id=&#34;网页设计博物馆httpswwwwebdesignmuseumorg&#34;&gt;&lt;a href=&#34;https://www.webdesignmuseum.org/&#34;&gt;网页设计博物馆&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站收集了1600多个经过精心挑选和分类的网页，展示了1991年至2006年之间的网站设计趋势&lt;/p&gt;
&lt;h3 id=&#34;窗口交换httpswindow-swapcom&#34;&gt;&lt;a href=&#34;https://window-swap.com/&#34;&gt;窗口交换&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站让世界各地的人上传他们窗外的镜像，一段5到10分钟的视频。其他用户就可以在网站上随机看到别人的窗外&lt;/p&gt;
&lt;h3 id=&#34;cnetcomhttpswwwcnetcompicturesinside-the-kansas-survival-condo-designed-to-save-you-from-nuclear-winter&#34;&gt;&lt;a href=&#34;https://www.cnet.com/pictures/inside-the-kansas-survival-condo-designed-to-save-you-from-nuclear-winter/&#34;&gt;cnet.com&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;幸存者公寓&lt;/p&gt;
&lt;h3 id=&#34;平流层飞船httpswwwgeekwirecom2020space-perspective-reboots-vision-flying-passengers-stratosphere-balloon&#34;&gt;&lt;a href=&#34;https://www.geekwire.com/2020/space-perspective-reboots-vision-flying-passengers-stratosphere-balloon/&#34;&gt;平流层飞船&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;美国一家私人公司提出了“平流层飞船”计划，让游客乘坐飞船上升到平流层（距离地面30公里），体验一下太空的感觉，票价预计为每人12.5万美元。飞船可以乘坐八名乘客和一名飞行员，先进行长达两个小时的上升，然后在空中停留两个小时，最后再花两个小时下降。&lt;/p&gt;
&lt;p&gt;飞船的上升动力，主要来自一个巨大的充满氢气的气球。飞船内部有酒吧，还有一个“拥有世界上最佳视野”的厕所，甚至有 Wifi。该公司计划飞船在2024年完工，目前已经在&lt;a href=&#34;https://thespaceperspective.com/fly/&#34;&gt;官网&lt;/a&gt;接受预订。&lt;/p&gt;
&lt;h3 id=&#34;sha-256-的原理httpsqvaultio20200708how-sha-2-works-step-by-step-sha-256&#34;&gt;&lt;a href=&#34;https://qvault.io/2020/07/08/how-sha-2-works-step-by-step-sha-256/&#34;&gt;SHA-256 的原理&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文通过一个简单的例子，一步步演示 SHA-256 算法，如何将字符串变成一个256位的哈希值。&lt;/p&gt;
&lt;h3 id=&#34;javascript-函数作用域解释httpsbloggreenrootsinfojavascript-scope-fundamentals-with-tom-and-jerry-ckcq723h4007vkxs18dxa97ae&#34;&gt;&lt;a href=&#34;https://blog.greenroots.info/javascript-scope-fundamentals-with-tom-and-jerry-ckcq723h4007vkxs18dxa97ae&#34;&gt;JavaScript 函数作用域解释&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;通过一个简单的例子，解释 JavaScript 的函数作用域规则&lt;/p&gt;
&lt;h3 id=&#34;gpt-3-模型的图灵测试httplackerioai20200706giving-gpt-3-a-turing-testhtml&#34;&gt;&lt;a href=&#34;http://lacker.io/ai/2020/07/06/giving-gpt-3-a-turing-test.html&#34;&gt;GPT-3 模型的图灵测试&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;GPT-3 是 OpenAI 公司开发的一个 AI 模型，能够自动生成文本。作者对它进行了图灵测试，跟它对话，看能不能分辨出对方是一个软件。&lt;/p&gt;
&lt;h3 id=&#34;pastemecnhttpspastemecn&#34;&gt;&lt;a href=&#34;https://pasteme.cn/&#34;&gt;PasteMe.cn&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个文本分享网站，不需要注册，会对输入的文本或代码生成 URL，支持密码和阅后即焚&lt;/p&gt;
&lt;h3 id=&#34;shoelacehttpsshoelacestyle&#34;&gt;&lt;a href=&#34;https://shoelace.style/&#34;&gt;Shoelace&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 Web Components 组件库，易用&lt;/p&gt;
&lt;h3 id=&#34;3d-封面生成器https3d-book-cssnetlifyapp&#34;&gt;&lt;a href=&#34;https://3d-book-css.netlify.app/&#34;&gt;3D 封面生成器&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在线工具，让一张平面图片变成 3D 书籍封面。&lt;/p&gt;
&lt;h3 id=&#34;easy-monitorhttpsgithubcomhyj1991easy-monitor&#34;&gt;&lt;a href=&#34;https://github.com/hyj1991/easy-monitor&#34;&gt;easy-monitor&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Node.js 应用的性能监控工具，可以定位线上故障。代码开源，支持私有部署&lt;/p&gt;
&lt;h3 id=&#34;remark42httpsgithubcomumputunremark42&#34;&gt;&lt;a href=&#34;https://github.com/umputun/remark42&#34;&gt;remark42&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;开源的评论服务，可以用来为静态网页加上留言功能。&lt;/p&gt;
&lt;h3 id=&#34;wikijshttpswikijsorg&#34;&gt;&lt;a href=&#34;https://wiki.js.org/&#34;&gt;Wiki.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;架设个人 Wiki 的 Node.js 应用。&lt;/p&gt;
&lt;h3 id=&#34;rust-语言之旅httpstourofrustcom00_zh-cnhtml&#34;&gt;&lt;a href=&#34;https://tourofrust.com/00_zh-cn.html&#34;&gt;Rust 语言之旅&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Rust 语言的中文版在线教程，通过可以运行的小例子介绍语法，从 Hello World 开始讲起&lt;/p&gt;
&lt;h3 id=&#34;木星相册httpswwwflickrcomphotoskevinmgillalbums72157709069900506&#34;&gt;&lt;a href=&#34;https://www.flickr.com/photos/kevinmgill/albums/72157709069900506&#34;&gt;木星相册&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个天文爱好者收集的木星照片。&lt;/p&gt;
&lt;h3 id=&#34;麻省理工学院的统计学课件httpsocwmiteducoursesmathematics18-650-statistics-for-applications-fall-2016lecture-slides&#34;&gt;&lt;a href=&#34;https://ocw.mit.edu/courses/mathematics/18-650-statistics-for-applications-fall-2016/lecture-slides/&#34;&gt;麻省理工学院的统计学课件&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;麻省理工学院本科生统计学课程的 PPT 课件&lt;/p&gt;
&lt;h3 id=&#34;没有博士学位者的-tensorflow-和深度学习教程httpscodelabsdevelopersgooglecomcodelabscloud-tensorflow-mnist&#34;&gt;&lt;a href=&#34;https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/&#34;&gt;没有博士学位者的 TensorFlow 和深度学习教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;谷歌发布的英文教程，没有高深的数学，向初学者介绍 TensorFlow 和深度学习。&lt;/p&gt;
- https://www.openheart.icu/cs/interesting/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Oracle</title>
        <link>https://www.openheart.icu/cs/oracle/</link>
        <pubDate>Tue, 21 Jul 2020 20:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/oracle/</guid>
        <description>42th openheart https://www.openheart.icu/cs/oracle/ -&lt;h1 id=&#34;common-operation&#34;&gt;Common Operation&lt;/h1&gt;
&lt;h1 id=&#34;optimize&#34;&gt;Optimize&lt;/h1&gt;
&lt;h2 id=&#34;索引失效&#34;&gt;索引失效&lt;/h2&gt;
&lt;p&gt;SQL在&lt;code&gt;WHERE&lt;/code&gt;条件里面使用了&lt;code&gt;IN&lt;/code&gt;导致有一个关联表的索引失效，Oracle版本为11g&lt;/p&gt;
&lt;p&gt;条件中有or，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引&lt;/p&gt;
&lt;p&gt;like查询是以%开头&lt;/p&gt;
&lt;p&gt;如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引&lt;/p&gt;
&lt;h2 id=&#34;分库-分表-分区&#34;&gt;分库 分表 分区&lt;/h2&gt;
&lt;h2 id=&#34;视图优化&#34;&gt;视图优化&lt;/h2&gt;
&lt;h3 id=&#34;基表增加索引&#34;&gt;基表增加索引&lt;/h3&gt;
&lt;p&gt;对基表中，视图查询SQL的&lt;code&gt;WHERE&lt;/code&gt;条件中用到的字段增加索引&lt;/p&gt;
&lt;h3 id=&#34;重新进行表分析&#34;&gt;重新进行表分析&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;-- 视图查询慢
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;

&lt;span style=&#34;color:#228b22&#34;&gt;-- 在当前用户下执行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;analyze table &amp;#39;&lt;/span&gt;||&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;||&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; compute statistics;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;IN&lt;/span&gt; (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;tablename&amp;#39;&lt;/span&gt;);   

&lt;span style=&#34;color:#228b22&#34;&gt;-- 得到如下语句，将这些语句整体执行一遍
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; PRODUCT_REF_LIST_NESTEDTAB compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#228b22&#34;&gt;-- ....
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;-- 查看统计信息
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;,num_rows &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分析的结果被Oracle用于基于成本的优化生成更好的查询计划。&lt;/p&gt;
&lt;p&gt;遇到当前表的查询或其他性能不好时，就可以对相应的表进行一次分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你的表经常由几千万变成几百万，又变成几千万那么需要制定分析计划定期表分析，同时可以一并分析索引，计算索引中数据的分布情况，这样CBO会选择更加准确的执行计划。&lt;/li&gt;
&lt;li&gt;如果表结构变化了也要做下，也就是经常对表做dml就需要分析，现在推荐使用dbms_stats包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;error&#34;&gt;ERROR&lt;/h1&gt;
&lt;h2 id=&#34;ora-01779-无法修改与非键值保存表对应的列&#34;&gt;ORA-01779: 无法修改与非键值保存表对应的列&lt;/h2&gt;
&lt;p&gt;这里要搞清楚三个概念：视图、联接视图、可更新的联接视图&lt;/p&gt;
&lt;h3 id=&#34;视图&#34;&gt;视图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;视图&lt;/strong&gt;可以分为视图对象和内嵌视图两种。&lt;/p&gt;
&lt;h4 id=&#34;视图对象view-object&#34;&gt;视图对象（View Object）&lt;/h4&gt;
&lt;p&gt;数据库里的&lt;strong&gt;视图对象&lt;/strong&gt;跟一张表或索引等一样，是数据库对象中的一种，它其实是将基于表中原始数据的查询给虚拟了一层之后，提供给外部查询的一种对象。
其本质是并不保存查询的实际结果，而只是将查询语句保存在数据库中，当用户查询某张视图的时候，就会找到并执行这个视图的语句。
而&lt;strong&gt;联接视图&lt;/strong&gt;其实就是在一个视图中将两个表建立关联就是了。&lt;/p&gt;
&lt;h4 id=&#34;内嵌视图inline-view&#34;&gt;内嵌视图（Inline View）&lt;/h4&gt;
&lt;p&gt;在SQL语句中，很多地方都可以写嵌套的语句，比如说，FROM后面可以套括号嵌套其他的语句，WHERE、SELECT、UPDATE、INSERT、DELETE后面都是可以写的。只是写的位置不同，执行的方式还有处理时的一些限制不同，这些SQL中嵌套的SQL被称为&lt;strong&gt;子查询（Subquery）&lt;/strong&gt; 。子查询可以分为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内嵌视图：位置位于FROM语句中，也相当于一个预处理结果集的概念&lt;/li&gt;
&lt;li&gt;标量子查询（Scalar Subquery）：只返还一个结果值的子查询。位于SELECT语句的子查询只能返还一个值，所以必然是标量子查询，WHERE语句里也会出现这样的子查询&lt;/li&gt;
&lt;li&gt;关联子查询：将查询的结果传递给子查询作为参数的使用的形式&lt;/li&gt;
&lt;li&gt;一般子查询：除了那些特殊形式的子查询以外的一般用法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;可更新联接视图updatable-join-view-&#34;&gt;可更新联接视图（Updatable Join View ）&lt;/h4&gt;
&lt;p&gt;将一个联接视图（包括视图对象和内嵌视图）放到UPADTE语句中这样的语法形式。&lt;/p&gt;
&lt;p&gt;同样的道理，如果只是用一个表来作为视图的基表，则可以对该视图直接进行&lt;code&gt;DELETE&lt;/code&gt;和&lt;code&gt;UPDATE&lt;/code&gt;，但无法直接执行&lt;code&gt;INSERT&lt;/code&gt;，因为该视图没有默认值的非空列(&lt;code&gt;brand_id&lt;/code&gt;)。该视图称为&lt;strong&gt;可更新视图&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;报错原理&#34;&gt;报错原理&lt;/h3&gt;
&lt;p&gt;Oracle的键值保存表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; *
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; DBA_UPDATABLE_COLUMNS
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;SCOTT&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;EMP_DEPT_V&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COLUMN_NAME&lt;/span&gt; | UPDATABLE | INSERTABLE | DELETABLE
SCOTT   EMP_DEPT_V     EMPNO            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     ENAME            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     SAL              &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     DEPTNO           &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     DNAME            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;视图&lt;code&gt;EMP_DEPT_V&lt;/code&gt;里的字段都无法变更。&lt;/p&gt;
&lt;p&gt;如果能保证DEPT_T表里的数据是唯一的就能够更新。也就是说在DEPT_T表上加&lt;code&gt;主键约束&lt;/code&gt;或&lt;code&gt;唯一约束&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; DEPT_T
     &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ADD&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;CONSTRAINT&lt;/span&gt; PK_DEPT_T &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;KEY&lt;/span&gt; (DEPTNO);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再看一下之前的视图：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; *
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; DBA_UPDATABLE_COLUMNS
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;SCOTT&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;EMP_DEPT_V&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COLUMN_NAME&lt;/span&gt; | UPDATABLE | INSERTABLE | DELETABLE
SCOTT   EMP_DEPT_V     EMPNO            YES         YES         YES
SCOTT   EMP_DEPT_V     ENAME            YES         YES         YES
SCOTT   EMP_DEPT_V     SAL              YES         YES         YES
SCOTT   EMP_DEPT_V     DEPTNO           YES         YES         YES
SCOTT   EMP_DEPT_V     DNAME             &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个时候就可以看到，视图中&lt;code&gt;EMP_DEPT_V&lt;/code&gt;表中原来的字段都是可以更新的了。&lt;/p&gt;
&lt;p&gt;在对联接视图进行变更的时候，必须保证修改后的值是唯一的，并且这个事实要让数据库知道，而告知数据库的方法是建立主键约束或唯一约束。&lt;/p&gt;
&lt;p&gt;并不是所有的表都可以随意建这些约束，有什么方法能够不添加约束也能变更？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加&lt;code&gt;/*+ BYPASS_UJVC */&lt;/code&gt; 提示，让ORACLE跳过检查（11g R2之后无效，不建议使用）&lt;/li&gt;
&lt;li&gt;改写&lt;code&gt;UPDATE&lt;/code&gt;语句，通过其他方式判断后处理&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;UPDATE&lt;/code&gt;改成&lt;code&gt;MERGE&lt;/code&gt;语句&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Oracle：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The concept of a &lt;strong&gt;key-preserved table&lt;/strong&gt; is fundamental to understanding the restrictions on &lt;strong&gt;modifying join views&lt;/strong&gt;. A table is key-preserved if every key of the table can also be a key of the result of the join. So, a key-preserved table has its keys preserved through a join.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;An &lt;strong&gt;updatable join view&lt;/strong&gt; (also referred to as a &lt;strong&gt;modifiable join view&lt;/strong&gt;) is a view that contains multiple tables in the top-level FROM clause of the SELECT statement, and is not restricted by the WITH READ ONLY clause.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/60a56760b19f&#34;&gt;https://www.jianshu.com/p/60a56760b19f&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.yiibai.com/oracle/oracle-updatable-view.html&#34;&gt;https://www.yiibai.com/oracle/oracle-updatable-view.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://www.openheart.icu/cs/oracle/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Speech</title>
        <link>https://www.openheart.icu/cs/speech/</link>
        <pubDate>Tue, 21 Jul 2020 19:45:28 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/speech/</guid>
        <description>42th openheart https://www.openheart.icu/cs/speech/ -&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;唯一不适应远程工作的是中层管理人员。&lt;/p&gt;
&lt;p&gt;基层员工对于在家工作感到很高兴，只要把活做好就可以了。高层管理人员只需要对销售和产量数字负责。中层管理人员的不适应在于，他们的职责是直接监控基层员工，最常用的判断方法是通过是否坐在座位上等迹象，来判断工作量和工作是否勤奋。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=23607203&#34;&gt;Hacker news 读者&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我有一种反英雄主义的精神。以前看电视时，我就对皇帝和将军不感兴趣，觉得他们已经有荣耀和风光了。&lt;/p&gt;
&lt;p&gt;我更关心皇帝和将军手下的那些小兵，有时战斗刚开始，他们就被杀死了。他们脑海里想的是什么？会有人记得他们，为他们哭泣吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 黄西自传《黄瓜的黄，西瓜的西》&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;时钟和镜子改变了人类社会。&lt;/p&gt;
&lt;p&gt;时钟创造了一种焦虑文化。&lt;/p&gt;
&lt;p&gt;镜子创造了一种自恋文化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; David Perell&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;100年前的中国，四千个人里面才有一个中学生，其他都是文盲。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 李敖&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;看到抽象的东西，应该尽量使它变得具体；看到具体的东西，应该尽量使它变得抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 李敖&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你花钱买，你就是客户，如果你免费获得，你就是产品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.wired.com/story/a-startup-is-testing-the-subscription-model-for-search-engines/&#34;&gt;《创业公司尝试搜索引擎的订阅模式》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;40年前算法很重要，大部分程序员都需要懂，因为硬件差，必须靠算法保证性能。&lt;/p&gt;
&lt;p&gt;但是今天只剩下不到1%的程序员直接跟算法打交道，其他人都使用现成的软件包，或从大公司购买算法，算法已成为一种商品，普通程序员不再需要自己生产了，也不需要有很深入的了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;http://shape-of-code.coding-guidelines.com/2020/07/05/algorithms-are-now-commodities/&#34;&gt;《算法现在是商品》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;本站100%无 JavaScript。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.swiftbysundell.com/special/javascript-free/&#34;&gt;swiftbysundell.com&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我希望 JavaScript 程序员、Java 程序员、PHP 程序员、Perl 程序员、Python 程序员、C 程序员、C ++ 程序员、以及其他重要语言的程序员，大家聚在一起开个会，一劳永逸地提出一个大家都遵守的解决方案，我们应该如何处理时间和日期。我厌倦了每个语言都有自己一套处理时间和日期的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=23781819&#34;&gt;《JavaScript 语言准备提出新的时间和日期 API》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;至少12年 Kubernetes 经验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Required Technical and Professional Expertise&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Minimum 12+ years’ experience in Kubernetes administration and management&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; IBM 招聘云工程师的&lt;a href=&#34;https://intellijobs.ai/job/IBMCloud-Native-Infrastructure-Engineer-Architect-bvJJ6yraexfWOk1nMRKP-bvJJ6yraexfWOk1nMRKP&#34;&gt;公告&lt;/a&gt;，但 Kubernetes 是2014年发布的。&lt;/p&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;一家公司获得垄断地位以后，就不需要从任何形式的产品开发获益了，只通过市场营销或金融工程就能增加利润。最终，公司就会被销售人员和财务人员控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 史蒂夫·乔布斯&lt;/p&gt;
&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;锚定偏差（anchoring bias）指的是决策时严重依赖第一个可用的信息。&lt;/p&gt;
&lt;p&gt;比如，你走进一家体育用品商店，发现的第一件商品，是一条价值500美元的运动裤。接着，你看到另一条价格为300美元的运动裤时，就会觉得它很便宜，实际上如果首先看到这条300美元的裤子，你会觉得它根本不便宜。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://models.substack.com/p/why-are-we-anchored-often&#34;&gt;《锚定偏差》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;信息成瘾指的是强迫性信息消费：明明已经看完所有内容，你仍在继续滚动浏览 Facebook；你刚刚关闭 Instagram，立即再次打开它；你每五分钟拿起手机，检查有没有新的通知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.defetter.com/&#34;&gt;《什么是信息成瘾》&lt;/a&gt;&lt;/p&gt;
- https://www.openheart.icu/cs/speech/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>剑指 Offer 46. 把数字翻译成字符串</title>
        <link>https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/</link>
        <pubDate>Tue, 21 Jul 2020 19:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/</guid>
        <description>42th openheart https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/ -&lt;h1 id=&#34;把数字翻译成字符串httpsleetcode-cncomproblemsba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/&#34;&gt;把数字翻译成字符串&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是&lt;code&gt;bccfi&lt;/code&gt;, &lt;code&gt;bwfi&lt;/code&gt;, &lt;code&gt;bczi&lt;/code&gt;, &lt;code&gt;mcfi&lt;/code&gt;和&lt;code&gt;mzi&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0 &amp;lt;= num &amp;lt; 2&lt;!-- raw HTML omitted --&gt;31&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;动态规划&#34;&gt;动态规划&lt;/h2&gt;
&lt;p&gt;拿示例看&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先考虑每个数字单独翻译的情况，即翻译&lt;code&gt;[1,2,2,4,8]&lt;/code&gt;，结果为&lt;code&gt;bccfi&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以将数字拼接为两位的情况，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[12,2,4,8]&lt;/code&gt; &lt;code&gt;mcfi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[12,24,8]&lt;/code&gt; &lt;code&gt;mzi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[12,2,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,22,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,22,4,8]&lt;/code&gt; &lt;code&gt;bwfi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,2,24,8]&lt;/code&gt; &lt;code&gt;bczi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,2,2,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;归纳规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以单独作为一位来翻译&lt;/li&gt;
&lt;li&gt;如果第 &lt;code&gt;i−1&lt;/code&gt; 位和第 &lt;code&gt;i&lt;/code&gt; 位组成的数字在 10 到 25 之间，可以把这两位连起来翻译&lt;/li&gt;
&lt;/ul&gt;
- https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>DNS</title>
        <link>https://www.openheart.icu/cs/dns/</link>
        <pubDate>Sun, 19 Jul 2020 12:50:56 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/dns/</guid>
        <description>42th openheart https://www.openheart.icu/cs/dns/ -&lt;h2 id=&#34;dnspod-dns&#34;&gt;DNSPod DNS+&lt;/h2&gt;
&lt;p&gt;​            首选：119.29.29.29&lt;/p&gt;
&lt;p&gt;​            备选：182.254.116.116&lt;/p&gt;
&lt;h3 id=&#34;114dns&#34;&gt;114DNS&lt;/h3&gt;
&lt;p&gt;​            首选：114.114.114.114&lt;/p&gt;
&lt;p&gt;​            备选：114.114.114.115&lt;/p&gt;
&lt;h3 id=&#34;阿里-alidns&#34;&gt;阿里 AliDNS&lt;/h3&gt;
&lt;p&gt;​            首选：223.5.5.5&lt;/p&gt;
&lt;p&gt;​            备选：223.6.6.6&lt;/p&gt;
&lt;h3 id=&#34;dns派&#34;&gt;DNS派&lt;/h3&gt;
&lt;p&gt;​            首选（电信/移动/铁通）：101.226.4.6&lt;/p&gt;
&lt;p&gt;​            备选（电信/移动/铁通）：218.30.118.6&lt;/p&gt;
&lt;p&gt;​            首选（联通）：123.125.81.6&lt;/p&gt;
&lt;p&gt;​            备选（联通）：140.207.198.6&lt;/p&gt;
&lt;h3 id=&#34;百度-baidudns&#34;&gt;百度 BaiduDNS&lt;/h3&gt;
&lt;p&gt;​            首选：180.76.76.76&lt;/p&gt;
&lt;h3 id=&#34;cnnic-sdns&#34;&gt;CNNIC SDNS&lt;/h3&gt;
&lt;p&gt;​            首选：1.2.4.8&lt;/p&gt;
&lt;p&gt;​            备选：202.98.0.68&lt;/p&gt;
&lt;h3 id=&#34;opendns&#34;&gt;OpenDNS&lt;/h3&gt;
&lt;p&gt;​            208.67.222.222&lt;/p&gt;
&lt;p&gt;​            208.67.220.220&lt;/p&gt;
&lt;p&gt;​            208.67.222.220&lt;/p&gt;
&lt;p&gt;​            208.67.220.222&lt;/p&gt;
&lt;h3 id=&#34;family-shield-servers&#34;&gt;Family Shield Servers&lt;/h3&gt;
&lt;p&gt;可以阻挡成人网站和含有恶意网站&lt;/p&gt;
&lt;p&gt;​            208.67.222.123&lt;/p&gt;
&lt;p&gt;​            208.67.220.123&lt;/p&gt;
&lt;h3 id=&#34;ipv6地址实验&#34;&gt;IPv6地址(实验)&lt;/h3&gt;
&lt;p&gt;​            2620:0:ccc::2&lt;/p&gt;
&lt;p&gt;​            2620:0:ccd::2&lt;/p&gt;
- https://www.openheart.icu/cs/dns/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title> 当面调试</title>
        <link>https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/</link>
        <pubDate>Sat, 18 Jul 2020 10:28:50 +0000</pubDate>
        
        <guid>https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/</guid>
        <description>42th openheart https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/ -&lt;p&gt;当我在被面试的时候我再想些什么？&lt;/p&gt;
- https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
  </channel>
</rss> 