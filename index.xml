<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>42th openheart</title>
    <link>https://www.openheart.icu/</link>
    <description>Recent content on 42th openheart</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>ALL RIGHTS RESERVED KRIS NIE</copyright>
    <lastBuildDate>Wed, 22 Jul 2020 20:28:00 +0000</lastBuildDate>
    
        <atom:link href="https://www.openheart.icu/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>URL</title>
        <link>https://www.openheart.icu/cs/url/</link>
        <pubDate>Wed, 22 Jul 2020 20:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/url/</guid>
        <description>42th openheart https://www.openheart.icu/cs/url/ -&lt;h1 id=&#34;url解析&#34;&gt;URL解析&lt;/h1&gt;
&lt;h2 id=&#34;urlencode&#34;&gt;UrlEncode&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 号表示空格  &lt;code&gt;%2B&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt; &lt;/code&gt;(空格) 可以用+号或者编码 &lt;code&gt;%20&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/&lt;/code&gt; 分隔目录和子目录 &lt;code&gt;%2F&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;?&lt;/code&gt; 分隔实际的URL和参数 &lt;code&gt;%3F&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 指定特殊字符 &lt;code&gt;%25&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;##&lt;/code&gt; 表示书签 &lt;code&gt;%23&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; URL 中指定的参数间的分隔符 &lt;code&gt;%26&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;=&lt;/code&gt; URL 中指定参数的值 &lt;code&gt;%3D&lt;/code&gt;&lt;/p&gt;
- https://www.openheart.icu/cs/url/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Interesting</title>
        <link>https://www.openheart.icu/cs/interesting/</link>
        <pubDate>Wed, 22 Jul 2020 19:45:28 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/interesting/</guid>
        <description>42th openheart https://www.openheart.icu/cs/interesting/ -&lt;h3 id=&#34;texturesjshttpsriccardoscalcoittextures&#34;&gt;&lt;a href=&#34;https://riccardoscalco.it/textures/&#34;&gt;Textures.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 JS 纹理库，基于 D3.js&lt;/p&gt;
&lt;h3 id=&#34;elevatorjshttpsgithubcomtholmanelevatorjs&#34;&gt;&lt;a href=&#34;https://github.com/tholman/elevator.js&#34;&gt;elevator.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Finally, a &amp;ldquo;back to top&amp;rdquo; button that behaves like a real elevator, by adding elevator music to quietly soothe the awkwardness that can ensue when being smoothly scrolled to the top of the screen.&lt;/p&gt;
&lt;p&gt;This is very serious stuff, &lt;a href=&#34;http://tholman.com/elevator.js&#34;&gt;here&amp;rsquo;s a demo&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;一个使得“回到顶部”的网页滚动，具有电梯效果的 JS 库。&lt;/p&gt;
&lt;h3 id=&#34;mownedhttpsmownedcom&#34;&gt;&lt;a href=&#34;https://mowned.com/&#34;&gt;Mowned&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个手机数据库&lt;/p&gt;
&lt;h3 id=&#34;javascript-生成艺术图形教程httpsgenerativeartistrycomtutorials&#34;&gt;&lt;a href=&#34;https://generativeartistry.com/tutorials/&#34;&gt;JavaScript 生成艺术图形教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;介绍 如何使用JavaScript 生成8种艺术图形。&lt;/p&gt;
&lt;h3 id=&#34;使用-raspberry-pi-学习操作系统开发httpss-matyukevichgithubioraspberry-pi-os&#34;&gt;&lt;a href=&#34;https://s-matyukevich.github.io/raspberry-pi-os/&#34;&gt;使用 Raspberry Pi 学习操作系统开发&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这是一个免费英文教程，教大家怎么用树莓派，一步步开发一个简单的操作系统内核，每一步都有实例代码&lt;/p&gt;
&lt;h3 id=&#34;vim-的由来httpspragmaticpineapplecomhow-did-vim-become-so-popular&#34;&gt;&lt;a href=&#34;https://pragmaticpineapple.com/how-did-vim-become-so-popular/&#34;&gt;Vim 的由来&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Vim 有30多年历史，目前依然是最流行的编辑器之一。本文简要地回顾了历史，它的一些主要的设计决定，到底是怎么来的&lt;/p&gt;
&lt;h3 id=&#34;makefile-的静态网站实现httpsmetinnextcorgpoststhe_idea_of_makefile_bloghtml&#34;&gt;&lt;a href=&#34;https://metin.nextc.org/posts/The_Idea_Of_Makefile_Blog.html&#34;&gt;Makefile 的静态网站实现&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;现在有各种各样的静态网站工具，比如 Jekyll 和 Hugo 等。作者提出，Makefile 也可以用来实现静态网站，这样就不需要任何外部工具了，只维护一个 Makefile 配置文件即可&lt;/p&gt;
&lt;h3 id=&#34;字体反爬的攻与防httpscjtingme20200701douyu-crawler-and-font-anti-crawling&#34;&gt;&lt;a href=&#34;https://cjting.me/2020/07/01/douyu-crawler-and-font-anti-crawling/&#34;&gt;字体反爬的攻与防&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者因为业务原因需要爬取一批斗鱼主播的相关数据，结果发现斗鱼使用了一种很有意思的反爬技术：字体反爬&lt;/p&gt;
&lt;h3 id=&#34;分页查询不要使用-offset-和-limit-语法httpshackernooncomplease-dont-use-offset-and-limit-for-your-pagination-8ux3u4y&#34;&gt;&lt;a href=&#34;https://hackernoon.com/please-dont-use-offset-and-limit-for-your-pagination-8ux3u4y&#34;&gt;分页查询不要使用 OFFSET 和 LIMIT 语法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;数据查询时，如果数据多，就需要分页，一般使用 OFFSET 和 LIMIT 语法。这篇文章提出，这样做不好，耗费资源，有性能问题&lt;/p&gt;
&lt;h3 id=&#34;git-多行提交信息的简单方法httpswwwstefanjudiscomtoday-i-learnedgit-commit-accepts-several-message-flags-m-to-allow-multiline-commits&#34;&gt;&lt;a href=&#34;https://www.stefanjudis.com/today-i-learned/git-commit-accepts-several-message-flags-m-to-allow-multiline-commits/&#34;&gt;Git 多行提交信息的简单方法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt;命令的&lt;code&gt;-m&lt;/code&gt;参数用来指定提交信息，但是这样提交的信息只有一行。本文介绍实现多行信息的简单方法&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;git co -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;commit title&amp;#34;&lt;/span&gt; -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;commit description&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;盲文的由来httpsstitcherioblogbraille-and-the-history-of-software&#34;&gt;&lt;a href=&#34;https://stitcher.io/blog/braille-and-the-history-of-software&#34;&gt;盲文的由来&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如题&lt;/p&gt;
&lt;h3 id=&#34;漫长的雨httpwwwsamwellernetbradbury-120181129the-essential-bradbury&#34;&gt;&lt;a href=&#34;http://www.samweller.net/bradbury-1/2018/11/29/the-essential-bradbury&#34;&gt;漫长的雨&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;《漫长的雨》（The long rain，&lt;strong&gt;&lt;a href=&#34;https://www.sohu.com/a/337866552_771944&#34;&gt;中译全文&lt;/a&gt;&lt;/strong&gt;）是美国科幻小说作家雷·布拉德伯里（Ray Bradbury）1950年发表的一篇短篇小说。&lt;/p&gt;
&lt;p&gt;它讲述四个宇航员因为火箭失事，来到一个不停下雨的星球。这个星球永远在下瓢泼大雨，过去10年一秒都没有停过。宇航员冒着雨水，在丛林里面穿行，拼命寻找前人修建的“阳光穹顶”，那里是一个大屋顶，有温暖的人造阳光，以及充足的食物和休息的场所。&lt;/p&gt;
&lt;p&gt;小说的开头是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;大雨，永远的雨，升腾着汗水和蒸汽的雨。这是密集的瓢泼大雨，像鞭子一样打在眼睛上，飞溅到脚踝上。它是一场淹没其他所有雨水的雨，让人遗忘所有关于雨水的记忆。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6个最常见的网页可访问性问题httpsblogscottlogiccom202007026-most-common-accessibility-problemshtmlempty-links-and-empty-buttons&#34;&gt;&lt;a href=&#34;https://blog.scottlogic.com/2020/07/02/6-most-common-accessibility-problems.html#empty-links-and-empty-buttons&#34;&gt;6个最常见的网页可访问性问题&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可访问性（accessibility）指的是，网页对生理缺陷的用户是否友好。本文总结了6个最常见的可访问性问题及其解决方法&lt;/p&gt;
&lt;h3 id=&#34;伪随机数生成器httpsgithubcombryccodeblobmasterjshashprngsmd&#34;&gt;&lt;a href=&#34;https://github.com/bryc/code/blob/master/jshash/PRNGs.md&#34;&gt;伪随机数生成器&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;伪随机数指的是通过一种算法，由种子值得到的随机数。本文介绍了几种简单的伪随机数算法&lt;/p&gt;
&lt;h3 id=&#34;75行代码入门-webglhttpsavikdascom20200708barebones-webgl-in-75-lines-of-codehtml&#34;&gt;&lt;a href=&#34;https://avikdas.com/2020/07/08/barebones-webgl-in-75-lines-of-code.html&#34;&gt;75行代码入门 WebGL&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WebGL 是浏览器对 OpenGL API 的调用接口，可以在浏览器里面实现 3D 动画。本文用一个简短的例子，介绍了这个 API。这只是一篇简介，另有&lt;a href=&#34;https://www.toptal.com/javascript/3d-graphics-a-webgl-tutorial&#34;&gt;完整的 WebGL 教程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;redisearchhttpsossredislabscomredisearch&#34;&gt;&lt;a href=&#34;https://oss.redislabs.com/redisearch/&#34;&gt;RediSearch&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;以 Redis 作为后端的全文搜索引擎，支持中文&lt;/p&gt;
&lt;h3 id=&#34;onelook-thesaurushttpswwwonelookcomthesaurus&#34;&gt;&lt;a href=&#34;https://www.onelook.com/thesaurus/&#34;&gt;OneLook Thesaurus&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;英语的同义词词典，可以查询同义词，也可以根据描述返回对应的词（比如 &lt;a href=&#34;https://www.onelook.com/thesaurus/?s=large%20birds&amp;amp;loc=revfp&#34;&gt;large bird&lt;/a&gt; 对应哪些词），加载速度很快&lt;/p&gt;
&lt;h3 id=&#34;crdttechhttpscrdttech&#34;&gt;&lt;a href=&#34;https://crdt.tech/&#34;&gt;CRDT.tech&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;CRDT 是一种数据结构，用于分布式网络的数据同步，最典型的例子就是多人同时编辑文档。该网站收集了 CRDT 的相关资料&lt;/p&gt;
&lt;h3 id=&#34;progressive-app-storehttpsprogressiveappstorehome&#34;&gt;&lt;a href=&#34;https://progressiveapp.store/home&#34;&gt;Progressive App Store&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个渐进式 App 的在线商店，收集各种 Progessive App，是网友搭建的&lt;/p&gt;
&lt;h3 id=&#34;网页设计博物馆httpswwwwebdesignmuseumorg&#34;&gt;&lt;a href=&#34;https://www.webdesignmuseum.org/&#34;&gt;网页设计博物馆&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站收集了1600多个经过精心挑选和分类的网页，展示了1991年至2006年之间的网站设计趋势&lt;/p&gt;
&lt;h3 id=&#34;窗口交换httpswindow-swapcom&#34;&gt;&lt;a href=&#34;https://window-swap.com/&#34;&gt;窗口交换&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站让世界各地的人上传他们窗外的镜像，一段5到10分钟的视频。其他用户就可以在网站上随机看到别人的窗外&lt;/p&gt;
&lt;h3 id=&#34;cnetcomhttpswwwcnetcompicturesinside-the-kansas-survival-condo-designed-to-save-you-from-nuclear-winter&#34;&gt;&lt;a href=&#34;https://www.cnet.com/pictures/inside-the-kansas-survival-condo-designed-to-save-you-from-nuclear-winter/&#34;&gt;cnet.com&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;幸存者公寓&lt;/p&gt;
&lt;h3 id=&#34;平流层飞船httpswwwgeekwirecom2020space-perspective-reboots-vision-flying-passengers-stratosphere-balloon&#34;&gt;&lt;a href=&#34;https://www.geekwire.com/2020/space-perspective-reboots-vision-flying-passengers-stratosphere-balloon/&#34;&gt;平流层飞船&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;美国一家私人公司提出了“平流层飞船”计划，让游客乘坐飞船上升到平流层（距离地面30公里），体验一下太空的感觉，票价预计为每人12.5万美元。飞船可以乘坐八名乘客和一名飞行员，先进行长达两个小时的上升，然后在空中停留两个小时，最后再花两个小时下降。&lt;/p&gt;
&lt;p&gt;飞船的上升动力，主要来自一个巨大的充满氢气的气球。飞船内部有酒吧，还有一个“拥有世界上最佳视野”的厕所，甚至有 Wifi。该公司计划飞船在2024年完工，目前已经在&lt;a href=&#34;https://thespaceperspective.com/fly/&#34;&gt;官网&lt;/a&gt;接受预订。&lt;/p&gt;
- https://www.openheart.icu/cs/interesting/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Oracle</title>
        <link>https://www.openheart.icu/cs/oracle/</link>
        <pubDate>Tue, 21 Jul 2020 20:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/oracle/</guid>
        <description>42th openheart https://www.openheart.icu/cs/oracle/ -&lt;h1 id=&#34;common-operation&#34;&gt;Common Operation&lt;/h1&gt;
&lt;h1 id=&#34;optimize&#34;&gt;Optimize&lt;/h1&gt;
&lt;h2 id=&#34;索引失效&#34;&gt;索引失效&lt;/h2&gt;
&lt;p&gt;SQL在&lt;code&gt;WHERE&lt;/code&gt;条件里面使用了&lt;code&gt;IN&lt;/code&gt;导致有一个关联表的索引失效，Oracle版本为11g&lt;/p&gt;
&lt;p&gt;条件中有or，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引&lt;/p&gt;
&lt;p&gt;like查询是以%开头&lt;/p&gt;
&lt;p&gt;如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引&lt;/p&gt;
&lt;h2 id=&#34;分库-分表-分区&#34;&gt;分库 分表 分区&lt;/h2&gt;
&lt;h2 id=&#34;视图优化&#34;&gt;视图优化&lt;/h2&gt;
&lt;h3 id=&#34;基表增加索引&#34;&gt;基表增加索引&lt;/h3&gt;
&lt;p&gt;对基表中，视图查询SQL的&lt;code&gt;WHERE&lt;/code&gt;条件中用到的字段增加索引&lt;/p&gt;
&lt;h3 id=&#34;重新进行表分析&#34;&gt;重新进行表分析&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;-- 视图查询慢
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;

&lt;span style=&#34;color:#228b22&#34;&gt;-- 在当前用户下执行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;analyze table &amp;#39;&lt;/span&gt;||&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;||&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; compute statistics;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;IN&lt;/span&gt; (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;tablename&amp;#39;&lt;/span&gt;);   

&lt;span style=&#34;color:#228b22&#34;&gt;-- 得到如下语句，将这些语句整体执行一遍
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; PRODUCT_REF_LIST_NESTEDTAB compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#228b22&#34;&gt;-- ....
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;-- 查看统计信息
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;,num_rows &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分析的结果被Oracle用于基于成本的优化生成更好的查询计划。&lt;/p&gt;
&lt;p&gt;遇到当前表的查询或其他性能不好时，就可以对相应的表进行一次分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你的表经常由几千万变成几百万，又变成几千万那么需要制定分析计划定期表分析，同时可以一并分析索引，计算索引中数据的分布情况，这样CBO会选择更加准确的执行计划。&lt;/li&gt;
&lt;li&gt;如果表结构变化了也要做下，也就是经常对表做dml就需要分析，现在推荐使用dbms_stats包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;error&#34;&gt;ERROR&lt;/h1&gt;
&lt;h2 id=&#34;ora-01779-无法修改与非键值保存表对应的列&#34;&gt;ORA-01779: 无法修改与非键值保存表对应的列&lt;/h2&gt;
&lt;p&gt;这里要搞清楚三个概念：视图、联接视图、可更新的联接视图&lt;/p&gt;
&lt;h3 id=&#34;视图&#34;&gt;视图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;视图&lt;/strong&gt;可以分为视图对象和内嵌视图两种。&lt;/p&gt;
&lt;h4 id=&#34;视图对象view-object&#34;&gt;视图对象（View Object）&lt;/h4&gt;
&lt;p&gt;数据库里的&lt;strong&gt;视图对象&lt;/strong&gt;跟一张表或索引等一样，是数据库对象中的一种，它其实是将基于表中原始数据的查询给虚拟了一层之后，提供给外部查询的一种对象。
其本质是并不保存查询的实际结果，而只是将查询语句保存在数据库中，当用户查询某张视图的时候，就会找到并执行这个视图的语句。
而&lt;strong&gt;联接视图&lt;/strong&gt;其实就是在一个视图中将两个表建立关联就是了。&lt;/p&gt;
&lt;h4 id=&#34;内嵌视图inline-view&#34;&gt;内嵌视图（Inline View）&lt;/h4&gt;
&lt;p&gt;在SQL语句中，很多地方都可以写嵌套的语句，比如说，FROM后面可以套括号嵌套其他的语句，WHERE、SELECT、UPDATE、INSERT、DELETE后面都是可以写的。只是写的位置不同，执行的方式还有处理时的一些限制不同，这些SQL中嵌套的SQL被称为&lt;strong&gt;子查询（Subquery）&lt;/strong&gt; 。子查询可以分为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内嵌视图：位置位于FROM语句中，也相当于一个预处理结果集的概念&lt;/li&gt;
&lt;li&gt;标量子查询（Scalar Subquery）：只返还一个结果值的子查询。位于SELECT语句的子查询只能返还一个值，所以必然是标量子查询，WHERE语句里也会出现这样的子查询&lt;/li&gt;
&lt;li&gt;关联子查询：将查询的结果传递给子查询作为参数的使用的形式&lt;/li&gt;
&lt;li&gt;一般子查询：除了那些特殊形式的子查询以外的一般用法&lt;/li&gt;
&lt;/ul&gt;
- https://www.openheart.icu/cs/oracle/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Speech</title>
        <link>https://www.openheart.icu/cs/speech/</link>
        <pubDate>Tue, 21 Jul 2020 19:45:28 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/speech/</guid>
        <description>42th openheart https://www.openheart.icu/cs/speech/ -&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;唯一不适应远程工作的是中层管理人员。&lt;/p&gt;
&lt;p&gt;基层员工对于在家工作感到很高兴，只要把活做好就可以了。高层管理人员只需要对销售和产量数字负责。中层管理人员的不适应在于，他们的职责是直接监控基层员工，最常用的判断方法是通过是否坐在座位上等迹象，来判断工作量和工作是否勤奋。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=23607203&#34;&gt;Hacker news 读者&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我有一种反英雄主义的精神。以前看电视时，我就对皇帝和将军不感兴趣，觉得他们已经有荣耀和风光了。&lt;/p&gt;
&lt;p&gt;我更关心皇帝和将军手下的那些小兵，有时战斗刚开始，他们就被杀死了。他们脑海里想的是什么？会有人记得他们，为他们哭泣吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 黄西自传《黄瓜的黄，西瓜的西》&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;时钟和镜子改变了人类社会。&lt;/p&gt;
&lt;p&gt;时钟创造了一种焦虑文化。&lt;/p&gt;
&lt;p&gt;镜子创造了一种自恋文化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; David Perell&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;100年前的中国，四千个人里面才有一个中学生，其他都是文盲。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 李敖&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;看到抽象的东西，应该尽量使它变得具体；看到具体的东西，应该尽量使它变得抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 李敖&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你花钱买，你就是客户，如果你免费获得，你就是产品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.wired.com/story/a-startup-is-testing-the-subscription-model-for-search-engines/&#34;&gt;《创业公司尝试搜索引擎的订阅模式》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;40年前算法很重要，大部分程序员都需要懂，因为硬件差，必须靠算法保证性能。&lt;/p&gt;
&lt;p&gt;但是今天只剩下不到1%的程序员直接跟算法打交道，其他人都使用现成的软件包，或从大公司购买算法，算法已成为一种商品，普通程序员不再需要自己生产了，也不需要有很深入的了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;http://shape-of-code.coding-guidelines.com/2020/07/05/algorithms-are-now-commodities/&#34;&gt;《算法现在是商品》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;本站100%无 JavaScript。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.swiftbysundell.com/special/javascript-free/&#34;&gt;swiftbysundell.com&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我希望 JavaScript 程序员、Java 程序员、PHP 程序员、Perl 程序员、Python 程序员、C 程序员、C ++ 程序员、以及其他重要语言的程序员，大家聚在一起开个会，一劳永逸地提出一个大家都遵守的解决方案，我们应该如何处理时间和日期。我厌倦了每个语言都有自己一套处理时间和日期的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=23781819&#34;&gt;《JavaScript 语言准备提出新的时间和日期 API》&lt;/a&gt;&lt;/p&gt;
- https://www.openheart.icu/cs/speech/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>剑指 Offer 46. 把数字翻译成字符串</title>
        <link>https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/</link>
        <pubDate>Tue, 21 Jul 2020 19:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/</guid>
        <description>42th openheart https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/ -&lt;h1 id=&#34;把数字翻译成字符串httpsleetcode-cncomproblemsba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/&#34;&gt;把数字翻译成字符串&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是&lt;code&gt;bccfi&lt;/code&gt;, &lt;code&gt;bwfi&lt;/code&gt;, &lt;code&gt;bczi&lt;/code&gt;, &lt;code&gt;mcfi&lt;/code&gt;和&lt;code&gt;mzi&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0 &amp;lt;= num &amp;lt; 2&lt;!-- raw HTML omitted --&gt;31&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;动态规划&#34;&gt;动态规划&lt;/h2&gt;
&lt;p&gt;拿示例看&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先考虑每个数字单独翻译的情况，即翻译&lt;code&gt;[1,2,2,4,8]&lt;/code&gt;，结果为&lt;code&gt;bccfi&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以将数字拼接为两位的情况，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[12,2,4,8]&lt;/code&gt; &lt;code&gt;mcfi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[12,24,8]&lt;/code&gt; &lt;code&gt;mzi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[12,2,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,22,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,22,4,8]&lt;/code&gt; &lt;code&gt;bwfi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,2,24,8]&lt;/code&gt; &lt;code&gt;bczi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,2,2,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;归纳规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以单独作为一位来翻译&lt;/li&gt;
&lt;li&gt;如果第 &lt;code&gt;i−1&lt;/code&gt; 位和第 &lt;code&gt;i&lt;/code&gt; 位组成的数字在 10 到 25 之间，可以把这两位连起来翻译&lt;/li&gt;
&lt;/ul&gt;
- https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>DNS</title>
        <link>https://www.openheart.icu/cs/dns/</link>
        <pubDate>Sun, 19 Jul 2020 12:50:56 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/dns/</guid>
        <description>42th openheart https://www.openheart.icu/cs/dns/ -&lt;h2 id=&#34;dnspod-dns&#34;&gt;DNSPod DNS+&lt;/h2&gt;
&lt;p&gt;​            首选：119.29.29.29&lt;/p&gt;
&lt;p&gt;​            备选：182.254.116.116&lt;/p&gt;
&lt;h3 id=&#34;114dns&#34;&gt;114DNS&lt;/h3&gt;
&lt;p&gt;​            首选：114.114.114.114&lt;/p&gt;
&lt;p&gt;​            备选：114.114.114.115&lt;/p&gt;
&lt;h3 id=&#34;阿里-alidns&#34;&gt;阿里 AliDNS&lt;/h3&gt;
&lt;p&gt;​            首选：223.5.5.5&lt;/p&gt;
&lt;p&gt;​            备选：223.6.6.6&lt;/p&gt;
&lt;h3 id=&#34;dns派&#34;&gt;DNS派&lt;/h3&gt;
&lt;p&gt;​            首选（电信/移动/铁通）：101.226.4.6&lt;/p&gt;
&lt;p&gt;​            备选（电信/移动/铁通）：218.30.118.6&lt;/p&gt;
&lt;p&gt;​            首选（联通）：123.125.81.6&lt;/p&gt;
&lt;p&gt;​            备选（联通）：140.207.198.6&lt;/p&gt;
&lt;h3 id=&#34;百度-baidudns&#34;&gt;百度 BaiduDNS&lt;/h3&gt;
&lt;p&gt;​            首选：180.76.76.76&lt;/p&gt;
&lt;h3 id=&#34;cnnic-sdns&#34;&gt;CNNIC SDNS&lt;/h3&gt;
&lt;p&gt;​            首选：1.2.4.8&lt;/p&gt;
&lt;p&gt;​            备选：202.98.0.68&lt;/p&gt;
&lt;h3 id=&#34;opendns&#34;&gt;OpenDNS&lt;/h3&gt;
&lt;p&gt;​            208.67.222.222&lt;/p&gt;
&lt;p&gt;​            208.67.220.220&lt;/p&gt;
&lt;p&gt;​            208.67.222.220&lt;/p&gt;
&lt;p&gt;​            208.67.220.222&lt;/p&gt;
&lt;h3 id=&#34;family-shield-servers&#34;&gt;Family Shield Servers&lt;/h3&gt;
&lt;p&gt;可以阻挡成人网站和含有恶意网站&lt;/p&gt;
&lt;p&gt;​            208.67.222.123&lt;/p&gt;
&lt;p&gt;​            208.67.220.123&lt;/p&gt;
&lt;h3 id=&#34;ipv6地址实验&#34;&gt;IPv6地址(实验)&lt;/h3&gt;
&lt;p&gt;​            2620:0:ccc::2&lt;/p&gt;
&lt;p&gt;​            2620:0:ccd::2&lt;/p&gt;
- https://www.openheart.icu/cs/dns/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title> 当面调试</title>
        <link>https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/</link>
        <pubDate>Sat, 18 Jul 2020 10:28:50 +0000</pubDate>
        
        <guid>https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/</guid>
        <description>42th openheart https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/ -&lt;p&gt;当我在被面试的时候我再想些什么？&lt;/p&gt;
- https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>.NET INTERVIEW</title>
        <link>https://www.openheart.icu/cs/dot-net-interview-questions/</link>
        <pubDate>Fri, 17 Jul 2020 23:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/dot-net-interview-questions/</guid>
        <description>42th openheart https://www.openheart.icu/cs/dot-net-interview-questions/ -&lt;h1 id=&#34;net-interview&#34;&gt;.NET INTERVIEW&lt;/h1&gt;
&lt;h2 id=&#34;from-jeffrey-zhaos-blog&#34;&gt;from Jeffrey Zhao&amp;rsquo;s blog&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.zhaojie.me/2011/03/my-interview-questions-for-dotnet-programmers.html&#34;&gt;我在面试.NET/C#程序员时会提出的问题&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;什么是net什么是cli什么是clril是什么jit是什么它是如何工作的gc是什么简述一下gc的工作方式&#34;&gt;什么是.NET？什么是CLI？什么是CLR？IL是什么？JIT是什么，它是如何工作的？GC是什么，简述一下GC的工作方式？&lt;/h3&gt;
&lt;h4 id=&#34;什么是net&#34;&gt;什么是.net&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;.NET是个平台，你就把它看成C#&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一个.NET应用是一个运行于.NET Framework之上的应用程序。（更精确的说，一个.NET应用是一个使用.NET Framework类库来编写，并运行于公共语言运行时 Common Language Runtime之上的应用程序。）如果一个应用程序跟.NET Framework无关，它就不能叫做.NET程序。比如，仅仅使用了XML并不就是.NET应用，仅仅使用SOAP SDK调用一个Web Service也不是.NET应用&lt;/p&gt;
&lt;p&gt;开发平台（Dot Net Framework）：包含通用语言运行时（CLR）和Dot Net框架类库（FCL）两个部分。他们提供了一致的编程模型，简化的编程方式，可靠的版本机制（用全局程序集缓存GAC来避免DLL Hell），轻便的部署管理（程序集自带的元数据可以避免ini文件和注册表） ，广泛的平台支持（只要这台机器兼容标准下的CLR和FCL就可以部署，当然运行的时候IL会变成本机代码），无缝的语言集成，自动化的内存管理（垃圾收集），类型安全（CLR会阻止利用缓冲区溢出错误进行的攻击），CLR支持跨语言调试，统一的错误报告，全新的安全策略（CAS），兼容以往的COM组件&lt;/p&gt;
&lt;h4 id=&#34;什么是clr&#34;&gt;什么是CLR&lt;/h4&gt;
&lt;p&gt;CLR(公用语言运行时)和Java虚拟机一样也是一个&lt;strong&gt;运行时环境&lt;/strong&gt;，它负责资源管理（内存分配和垃圾收集），并保证应用和底层操作系统之间必要的分离。.NET提供了一个运行时环境，叫做&lt;strong&gt;公用语言运行时（Commen Language Runtime）&lt;/strong&gt;，是一种多语言执行环境，支持众多的数据类型和语言特性。他管理着代码的执行，并使开发过程变得更加简单。这是一种可操控的执行环境，其功能通过编译器与其他工具共同展现。&lt;/p&gt;
&lt;h4 id=&#34;什么是cli&#34;&gt;什么是CLI&lt;/h4&gt;
&lt;p&gt;通用语言基础结构（Common Language Infrastructure，CLI）是CLR的一个子集，也就是.NET中最终对编译成MSIL代码的应用程序的运行环境进行管理的那一部分。在 CLR结构图中CLI位于下半部分，主要包括类加载器(Class Loader)、实时编译器(IL To Native Compilers)和一个运行时环境的垃圾收集器(Garbage Collector)。CLI是.Net和CLR的灵魂，CLI为IL代码提供运行的环境，你可以将使用任何语言编写的代码通过其特定的编译器转换为 MSIL代码之后运行其上，甚至还可以自己写MSIL代码在CLI上面运行。&lt;/p&gt;
&lt;h4 id=&#34;什么是il&#34;&gt;什么是IL&lt;/h4&gt;
&lt;p&gt;IL是微软.NET平台上衍生出来的一门中间语言，.NET平台上的各种高级语言（如C#，VB，F#）的编译器会将各自的文字表述方式转化为 IL。各种不同的文字形式最终被统一到了IL的表述方式，其中包含了.NET平台上的各种元素，如“范型”，“类”、、“接口”、“模块”、“属性”等 等。值得注意的是，各种高级语言本身可能根本没有这些“概念”在里头，如IronScheme是一个在.NET平台上的Scheme语言实现，其中根本没有前面提到的这些IL——亦或说是.NET平台上的名词。IL本身并不知道自己是由哪种高级语言转化而来的，哪种语言中有哪些特性，IL也根本不会关心。&lt;/p&gt;
&lt;h4 id=&#34;什么是jit&#34;&gt;什么是JIT&lt;/h4&gt;
&lt;p&gt;JIT（Just In Time, JIT）是.Net边运行边编译的一种机制。&lt;/p&gt;
&lt;p&gt;开发人员需要通过IL与CLR进行交流, 虽然IL本身支持一些面向对象的概念, 但是对于开发人员来讲还是过于复杂低效, 于是C#应运而生, 程序员只需编写C#代码, csc编译器会将其翻译成IL;虽然CLR理解IL, 但是CPU只认识二进制指令, 所以CLR需要JIT的帮助, 将IL翻译成CPU指令. JIT按需工作, 当一个.NET方法即将被执行时, JIT会介入, 把该方法(IL指令) 编译成CPU指令, 并保存以供重用。&lt;/p&gt;
&lt;h4 id=&#34;什么是gc以及它的工作方式&#34;&gt;什么是GC，以及它的工作方式&lt;/h4&gt;
&lt;p&gt;GC:.NET Framework 的垃圾回收器管理应用程序的内存分配和释放&lt;/p&gt;
&lt;p&gt;工作方式：每次您使用 new 运算符创建对象时，运行库都从托管堆为该对象分配内存。只要托管堆中有地址空间可用，运行库就会继续为新对象分配空间。但是，内存不是无限大的。最终，垃 圾回收器必须执行回收以释放一些内存。垃圾回收器优化引擎根据正在进行的分配情况确定执行回收的最佳时间。当垃圾回收器执行回收时，它检查托管堆中不再被 应用程序使用的对象并执行必要的操作来回收它们占用的内存。&lt;/p&gt;
&lt;p&gt;Dot Net的垃圾回收可以分为两个步骤，第一步进行“标记”，垃圾回收器假设所有的对象都是垃圾，然后开始遍历每一个“根”（根包含指向引用类型对象的一个指针，值类型对象永远不会被认为是一个根），如果发现一个根引用了一个对象（非NULL），就对对象进行标记。没有被标记的对象被认为是垃圾。第二个阶段就是“压缩”，其实就是将后面的对象移动到已经成为垃圾的对象位置，使得原来的托管堆更为紧凑，从而释放了托管堆。&lt;/p&gt;
&lt;p&gt;垃圾回收由以下步骤组成：&lt;/p&gt;
&lt;p&gt;GC搜索托管代码中引用的托管对象。
GC尝试完成没有被引用的对象。
GC释放没有被引用的对象并回收它们的内存&lt;/p&gt;
&lt;h3 id=&#34;类class和结构struct的区别是什么它们对性能有影响吗net-bcl里有哪些是类结构为什么它们不是结构类在自定义类型时您如何选择是类还是结构&#34;&gt;类（class）和结构（struct）的区别是什么？它们对性能有影响吗？.NET BCL里有哪些是类（结构），为什么它们不是结构（类）？在自定义类型时，您如何选择是类还是结构？&lt;/h3&gt;
&lt;h4 id=&#34;什么是class和struct&#34;&gt;什么是class和struct&lt;/h4&gt;
&lt;p&gt;class 和struct 最本质的区别: class 是引用类型，它在堆中分配空间，栈中保存的只是引用；而struct 是值类型，它在栈中分配空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是class?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;class（类）是面向对象编程的基本概念，是一种自定义数据结构类型，通常包含字段、属性、方法、构造函数、索引器、操作符等。在.NET中，所有的类都最终继承自 System.Object 类，因此是一种引用类型，也就是说，new 一个类的实例时，在栈（stack）上存放该实例在托管堆（Managed Heap）中的地址，而实例的值保存在托管堆（Managed Heap）中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;托管堆&lt;/strong&gt;（&lt;strong&gt;Managed Heap&lt;/strong&gt;） ：&lt;strong&gt;托管堆&lt;/strong&gt;分配在被操作系统保留的一段内存区域中，这段内存区域是由 CLR 来管理的，这段内存称之为&lt;strong&gt;托管堆&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是struct?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;struct（结构）是一种值类型，用于将一组相关的变量组织为一个单一的变量实体 。所有的结构直接派生自 System.ValueType，间接派生自System.Object，但&lt;strong&gt;结构是隐式密封&lt;/strong&gt;的，不能作为基类再派生出其他的结构，也不能从类派生，但可以从接口派生。struct 实例在创建时分配在线程的栈（stack）上，它本身存储了值。所以在使用 struct 时，我们可以将其当作 int、char 这样的基本类型对待。&lt;/p&gt;
&lt;h4 id=&#34;使用区别&#34;&gt;使用区别&lt;/h4&gt;
&lt;p&gt;class是引用类型，struct是值类型；既然 class 是引用类型，class 可以设为 null；但是我们不能将 struct 设为 null，因为它是值类型。&lt;/p&gt;
&lt;p&gt;当你实例化一个 class，它将创建在&lt;strong&gt;堆&lt;/strong&gt;上。
而你实例化一个 struct，它将创建在&lt;strong&gt;栈&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;你使用的是一个对 class 实例的引用。
而你使用的不是对一个 struct 的引用（而是直接使用它们）。&lt;/p&gt;
&lt;p&gt;当我们将 class 作为参数传给一个方法，
我们传递的是一个引用。struct 传递的是值而非引用。&lt;/p&gt;
&lt;p&gt;class 可以定义析构器，但是 struct 不可以。&lt;/p&gt;
&lt;p&gt;class可以有显示的无参构造器，但是 struct不可以。&lt;/p&gt;
&lt;p&gt;class 的构造器不需要初始化全部字段。
struct 的构造器必须初始化所有字段。&lt;/p&gt;
&lt;p&gt;struct 在声明时不能对实例字段进行赋值。&lt;/p&gt;
&lt;p&gt;class使用前必须new关键字实例化(静态类除外)，struct不需要。&lt;/p&gt;
&lt;p&gt;class 支持继承和多态，struct 不支持。注意：但是 struct 可以和类一样实现接口。&lt;/p&gt;
&lt;p&gt;既然 struct 不支持继承，其成员不能以 protected 或 protected internal 修饰。&lt;/p&gt;
&lt;p&gt;class 比较适合大的和复杂的数据。
struct 适用于作为经常使用的一些数据组合成的新类型。&lt;/p&gt;
&lt;p&gt;struct 类型总是隐式密封的，因此在定义结构时不能使用 sealed 和 abstract 关键字。&lt;/p&gt;
&lt;p&gt;struct的函数成员不能声明为 abstract 和 virtual，但是可以使用 override 关键字，用以覆写它的基类 System.ValueType 中的方法。&lt;/p&gt;
&lt;h4 id=&#34;适用场合&#34;&gt;适用场合&lt;/h4&gt;
&lt;p&gt;struct 有性能优势，class 有面向对象的扩展优势.&lt;/p&gt;
&lt;p&gt;由于结构是值类型，并且直接存储数据，因此在一个对象的主要成员为数据且数据量不大的情况下，使用结构会带来更好的性能.&lt;/p&gt;
&lt;p&gt;将一个结构变量赋值给另一个结构变量，就是把数据从一个结构复制到另一个结构。而类则不同，在类的变量之间，复制的是引用，而不是类数据.&lt;/p&gt;
&lt;p&gt;当把一个结构类型的变量赋值给另一个结构时，对性能的影响取决于结构的大小，当数据比较大的时候，这种数据复制机制会带来较大的开销.&lt;/p&gt;
&lt;p&gt;对于点、矩形和颜色这样的轻量对象，假如要声明一个含有许多个颜色对象的数组，则 CLR 需要为每个对象分配内存，在此情况下，使用结构的成本较低.&lt;/p&gt;
&lt;p&gt;当堆栈的空间很有限，且有大量的逻辑对象时，创建类要比创建结构好一些.&lt;/p&gt;
&lt;p&gt;在表现抽象和多级别的对象层次时，类是最好的选择，因为结构不支持继承.&lt;/p&gt;
&lt;p&gt;用于底层数据存储的类型设计为 struct 类型，将用于定义应用程序行为的类型设计为 class。如果对类型将来的应用情况不能确定，应该使用 class.&lt;/p&gt;
&lt;h3 id=&#34;泛型的作用是什么它有什么优势它对性能有影响吗它在执行时的行为是什么net-bcl中有哪些泛型类型举例说明平时编程中您定义的泛型类型&#34;&gt;泛型的作用是什么？它有什么优势？它对性能有影响吗？它在执行时的行为是什么？.NET BCL中有哪些泛型类型？举例说明平时编程中您定义的泛型类型。&lt;/h3&gt;
&lt;h4 id=&#34;泛型的作用&#34;&gt;泛型的作用&lt;/h4&gt;
&lt;p&gt;泛型的作用在于“算法的重用”。&lt;/p&gt;
&lt;p&gt;比如，原来的ArrayList只能接受Object，现在通过List可以接受任何类型，也就是说ArrayList的方法都被各个类型重用了。但是Dot Net的泛型有个比较制肘地方，就是你很难对数值类型（值类型）进行算法抽象，因为这牵涉到运算符重载的问题，同时Dot Net的泛型的类型参数也不能约束成一个基元值类型，如int、double、float。&lt;/p&gt;
&lt;h4 id=&#34;泛型的优势&#34;&gt;泛型的优势&lt;/h4&gt;
&lt;p&gt;1.源代码保护。&lt;/p&gt;
&lt;p&gt;如果你知道C++模板对泛型的实现机制，就会知道C++在编译的时候根据对泛型的调用，自动“内联”了一个实现，这样泛型的内容就暴露了，尔DotNet的实现方式就不同了，泛型类和方法会被编译成IL，在执行的时候由JIT负责将IL变化为指定类型参数的本地代码，从而保护了源代码。&lt;/p&gt;
&lt;p&gt;2.类型安全。&lt;/p&gt;
&lt;p&gt;这点是最显而易见的，抛弃了使用ArrayList时各种丑陋的强制类型转换&lt;/p&gt;
&lt;p&gt;3.更清晰地代码。&lt;/p&gt;
&lt;p&gt;因为没有了强制类型转换，所以代码自然显得更清晰，但是使用泛型时候带来的&amp;lt;&amp;gt;有时候确实也会让人搞糊涂，幸好泛型方法可以用类型推断或者using语句来进一步简化写法。&lt;/p&gt;
&lt;p&gt;4.更好的性能。&lt;/p&gt;
&lt;p&gt;因为值类型可以避免装箱和拆箱所带来的损耗（垃圾回收的次数也会减少）。这点正是泛型神奇的地方，开发历史上抽象能力的上升往往意味着性能的下降，但是泛型却不是！泛型抽象了算法，但是C++和DotNet对泛型的实现能够让性能无损，并且更快。Java的擦除法泛型就没有这种性能上的好处。&lt;/p&gt;
&lt;h4 id=&#34;对性能的影响&#34;&gt;对性能的影响&lt;/h4&gt;
&lt;p&gt;对性能有积极的影响，因为值类型可以避免装箱和拆箱所带来的负面影响，避免了垃圾回收，使得性能显著提高。但是对引用类型这种影响就不明显了。但是需要注意的是首次为一个特定数据类型调用方法时，CLR都会为这个方法生成本地代码。这会增大应用程序的工作集大小，从而影响性能。&lt;/p&gt;
&lt;h4 id=&#34;泛型在执行时的行为是什么&#34;&gt;泛型在执行时的行为是什么&lt;/h4&gt;
&lt;p&gt;使用泛型类型参数的一个方法在进行JIT编译时，CLR获取IL，用指定的类型实参进行替换，然后创建本地代码。需要特别注意的是引用类型是共享代码的，而对值类型就会为每一种生成独立的一份类型代码。但是需要指出的是引用类型的这种代码共享并不会造成封闭类型只执行一次构造函数（包括静态构造函数）。&lt;/p&gt;
&lt;h4 id=&#34;net-bcl中有哪些泛型类型&#34;&gt;.NET BCL中有哪些泛型类型&lt;/h4&gt;
&lt;p&gt;List、Dictionary、Queue、Stack、SortedList和SortedDictionary、LinkedList等等。&lt;/p&gt;
&lt;h3 id=&#34;异常的作用是什么net-bcl中有哪些常见的异常在代码中您是如何捕获处理异常的在catch-ex中throw和throw-ex有什么区别您会如何设计异常的结构什么情况下您会抛出异常&#34;&gt;异常的作用是什么？.NET BCL中有哪些常见的异常？在代码中您是如何捕获/处理异常的？在“catch (ex)”中，“throw”和“throw ex”有什么区别？您会如何设计异常的结构，什么情况下您会抛出异常？&lt;/h3&gt;
&lt;h4 id=&#34;异常的作用是什么&#34;&gt;异常的作用是什么&lt;/h4&gt;
&lt;p&gt;异常用于处理系统级或者应用程序级的错误状态。异常处理是一种结构化的处理过程，个人认为他最大的优点就在于将“成功场景”剥离出来，使得代码更加清晰自然。但是异常处理相对于返回错误码有一个缺点，那就是他会失去发生异常的位置。不过异常本身提供了很多帮助调试问题的工具，一般都带有栈跟踪，这样位置的问题就得到一定程度的解决。还有就是IF和异常之间的选择，我记得以前有人讨论过在各种分支下是使用异常来处理各种“失败场景”的分支还是使用IF或者SWITCH来处理呢？这其实是一个假问题，因为异常和错误是有概念上的不同的，这里的错误是指有违“主成功场景”的“异常场景”，尔异常是指当程序不能完成其名字所表示功能时的错误。&lt;/p&gt;
&lt;h4 id=&#34;net-bcl中有哪些常见的异常&#34;&gt;.NET BCL中有哪些常见的异常&lt;/h4&gt;
&lt;p&gt;随便说几个，最著名的恐怕就是那句像绕口令一样的“&lt;strong&gt;未将对象引用设置到对象实例&lt;/strong&gt;”了，还有那些基本一出现整个应用程序就被判死刑的“&lt;strong&gt;堆栈溢出&lt;/strong&gt;”、“&lt;strong&gt;内存无法分配&lt;/strong&gt;”异常了&lt;/p&gt;
&lt;h4 id=&#34;在代码中您是如何捕获处理异常的&#34;&gt;在代码中您是如何捕获/处理异常的&lt;/h4&gt;
&lt;p&gt;的最多的CATCH就是抓住数据的异常，然后回滚数据库来事务处理。这是一个典型的场景，因为你明确并且能够很好的恢复状态&lt;/p&gt;
&lt;h4 id=&#34;在catch-ex中throw和throw-ex有什么区别&#34;&gt;在“catch (ex)”中，“throw”和“throw ex”有什么区别&lt;/h4&gt;
&lt;p&gt;throw 重新抛出异常但是不破坏异常发生的调用栈尔“throw ex”会重置调用栈这样捕获异常的人会以为代码出错在这里。&lt;/p&gt;
&lt;p&gt;直接使用throw ex会导致吃掉原始异常点，重置堆栈中的异常起始点&lt;/p&gt;
&lt;p&gt;推荐使用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt;{}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;catch&lt;/span&gt; (Exception ex)
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;经过进一步包装的异常&amp;#34;&lt;/span&gt;, ex);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;listt和t的区别是什么平时你如何进行选择dictionarytkey-tvalue是做什么的net-bcl中还有哪些常用的容器它们分别是如何实现的哪种数据结构分别是适用于哪些场景&#34;&gt;List&lt;!-- raw HTML omitted --&gt;和T[]的区别是什么，平时你如何进行选择？Dictionary&amp;lt;TKey, TValue&amp;gt;是做什么的？.NET BCL中还有哪些常用的容器？它们分别是如何实现的（哪种数据结构）？分别是适用于哪些场景？&lt;/h3&gt;
&lt;p&gt;List&lt;!-- raw HTML omitted --&gt;长度不固定，动态变化，支持方法较多；T[]固定大小的泛型数组。&lt;/p&gt;
&lt;p&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;是泛型字典，提供一对一的关系；&lt;/p&gt;
&lt;p&gt;.Net BCL中常用的集合有Stack&lt;!-- raw HTML omitted --&gt;、Queue&lt;!-- raw HTML omitted --&gt;、LinkedList&lt;!-- raw HTML omitted --&gt;，对应的数据结构是栈、队列和链表。&lt;/p&gt;
&lt;h3 id=&#34;抽象类和接口有什么区别使用时有什么需要注意的吗如何选择是定义一个完全抽象的抽象类还是接口什么是接口的显式实现为什么说它很重要&#34;&gt;抽象类和接口有什么区别？使用时有什么需要注意的吗？如何选择是定义一个“完全抽象”的抽象类，还是接口？什么是接口的“显式实现”？为什么说它很重要？&lt;/h3&gt;
&lt;p&gt;抽象类不能实例化。
抽象类的用途是提供多个派生类可共享的基类的公共定义。
抽象类也可以定义抽象方法。
抽象方法没有实现，所以方法定义后面是分号，而不是常规的方法块。
抽象类的派生类必须实现所有抽象方法。
抽象类只能单继承&lt;/p&gt;
&lt;p&gt;接口类似于抽象基类：实现接口的任何非抽象类型都必须实现接口的所有成员。
不能直接实例化接口。
接口可以包含事件、索引器、方法和属性。
接口不包含方法的实现。
类和结构可继承多个接口。
接口自身可从多个接口继承。&lt;/p&gt;
&lt;p&gt;相同点：都不能被实例化，都可以通过继承实现其抽象方法；&lt;/p&gt;
&lt;p&gt;不同点：接口支持多继承，抽象类不能；接口只能定义行为，抽象类既可以定义行为，还能提供实现；接口只包含方法、属性、索引器和事件的签名，不能包括自定义字段和实现方法，抽象类可以包含自定义字段和实现方法。&lt;/p&gt;
&lt;h4 id=&#34;显式地实现接口成员&#34;&gt;显式地实现接口成员&lt;/h4&gt;
&lt;p&gt;即创建一个仅通过该接口调用并且特定于该接口的类成员&lt;/p&gt;
&lt;p&gt;类成员 IControl.Paint 只能通过 IControl 接口使用， ISurface.Paint 只能通过 ISurface 使用。
两个方法实现都是分离的，都不可以直接在类中使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; IControl
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Paint();
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; ISurface
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Paint();
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;SampleClass&lt;/span&gt; : IControl, ISurface
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Paint()
    {
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;SampleClass obj = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; SampleClass();
&lt;span style=&#34;color:#228b22&#34;&gt;//obj.Paint(); // Compiler error.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
IControl c = (IControl)obj;
c.Paint(); &lt;span style=&#34;color:#228b22&#34;&gt;// Calls IControl.Paint on SampleClass.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
ISurface s = (ISurface)obj;
s.Paint(); &lt;span style=&#34;color:#228b22&#34;&gt;// Calls ISurface.Paint on SampleClass.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显式实现还用于解决两个接口分别声明具有相同名称的不同成员（如属性和方法）的情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; ILeft
{
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; P { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;;}
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; IRight
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; P();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了同时实现两个接口，类必须对属性 P 和/或方法 P 使用显式实现以避免编译器错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Middle&lt;/span&gt; : ILeft, IRight
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; P() { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ILeft.P { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt; { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; } }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;抽象类和接口的使用&#34;&gt;抽象类和接口的使用&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单的方法来控制组件版本；&lt;/li&gt;
&lt;li&gt;如果创建的功能将在大范围的全异对象间使用，则使用接口。如果要设计小而简练的功能块，则使用接口；&lt;/li&gt;
&lt;li&gt;如果要设计大的功能单元，则使用抽象类。如果要在组件的所有实现间提供通用的已实现功能，则使用抽象类；&lt;/li&gt;
&lt;li&gt;抽象类主要用于关系密切的对象；而接口适合为不相关的类提供通用功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;字符串是引用类型类型还是结构类型它和普通的引用类型相比有什么特别的地方吗使用字符串时有什么需要注意的地方为什么说stringbuilder比较高效在连接多个字符串时它无论何时都比直接相加更高效吗&#34;&gt;字符串是引用类型类型还是结构类型？它和普通的引用类型相比有什么特别的地方吗？使用字符串时有什么需要注意的地方？为什么说StringBuilder比较高效？在连接多个字符串时，它无论何时都比直接相加更高效吗？&lt;/h3&gt;
&lt;p&gt;MSDN 中明确指出 String 是引用类型而不是值类型，但 String 表面上用起来却像是值类型&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//值类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; a = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; b = a;
a = &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;;
Console.WriteLine(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;a is {0},b is {1}&amp;#34;&lt;/span&gt;, a, b);
 
&lt;span style=&#34;color:#228b22&#34;&gt;//引用类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; str1 = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;ab&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; str2 = str1;
str1 = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;;
Console.WriteLine(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;str1 is {0},str2 is {1}&amp;#34;&lt;/span&gt;, str1, str2);
Console.Read();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;//结果：
a is 2,b is 1
str1 is abc,str2 is ab
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原因：string对象是不可变的，包括长度和其中任何字符都是不可以改变的。&lt;/p&gt;
&lt;h4 id=&#34;string的不变性&#34;&gt;String的不变性&lt;/h4&gt;
&lt;p&gt;string 对象称为不可变的（只读），即字符串恒定性(Immutability)，字符串一经创建，就不可改变。有的时候看来似乎修改了，实际是string经过了特殊处理，每次改变值时都会建立一个新的string对象，变量会指向这个新的对象，而原来的还是指向原来的对象，所以不会改变。这也是string效率低下的原因。如果经常改变string的值则应该使用StringBuilder而不使用string。&lt;/p&gt;
&lt;h4 id=&#34;stringstringbuilder&#34;&gt;String、StringBuilder&lt;/h4&gt;
&lt;p&gt;当大量使用string进行拼接的时候，直接使用string+会影响效率，使用StringBuilder更为合适；&lt;/p&gt;
&lt;p&gt;在连接多个字符串时，StringBuilder并不总是比String高效，对于简单的字符串连接操作，在性能上StringBuilder不一定总是优于String，因为StringBuilder对象的创建代价比较大，在字符串连接目标较少的情况下，过度滥用StringBuilder会导致性能的浪费而非节约。只有大量的或者无法预知次数的字符串操作，才考虑以StringBuilder实现。&lt;/p&gt;
&lt;h3 id=&#34;如何高效地进行数组复制二维数组和数组的数组有什么区别在使用双重循环遍历一个二维数组时如何选择内外层的遍历顺序&#34;&gt;如何高效地进行数组复制？“二维数组”和“数组的数组”有什么区别？在使用双重循环遍历一个二维数组时，如何选择内外层的遍历顺序？&lt;/h3&gt;
&lt;h3 id=&#34;什么是元编程net有哪些元编程的手段和场景什么是反射能否举一些反射的常用场景有人说反射性能较差您怎么看待这个问题有什么办法可以提高反射的性能吗&#34;&gt;什么是元编程，.NET有哪些元编程的手段和场景？什么是反射？能否举一些反射的常用场景？有人说反射性能较差，您怎么看待这个问题？有什么办法可以提高反射的性能吗？&lt;/h3&gt;
&lt;h3 id=&#34;委托是什么匿名方法是什么在c-30中lambda表达式是什么扩展方法是什么linq是什么您觉得c-30中还有哪些重要的特性它们带来了什么优势bcl中哪些类库和这些特性有关您平时最常用哪些&#34;&gt;委托是什么？匿名方法是什么？在C# 3.0中，Lambda表达式是什么？扩展方法是什么？LINQ是什么？您觉得C# 3.0中还有哪些重要的特性，它们带来了什么优势？BCL中哪些类库和这些特性有关？您平时最常用哪些？&lt;/h3&gt;
&lt;h4 id=&#34;委托是什么&#34;&gt;委托是什么&lt;/h4&gt;
&lt;p&gt;MSND:委托是一种引用方法的类型，太抽象了这定义，看不懂&lt;/p&gt;
&lt;p&gt;我的理解是：委托就是对于一组方法的抽象，代表一组方法的共同特征。&lt;/p&gt;
&lt;h4 id=&#34;匿名方法是什么&#34;&gt;匿名方法是什么&lt;/h4&gt;
&lt;p&gt;匿名方法是指将一段代码块作为委托参数传递给另外一个方法中。&lt;/p&gt;
&lt;p&gt;匿名方法能访问方法中的变量和类中的成员。&lt;/p&gt;
&lt;p&gt;使用匿名方法，则不必创建当独的方法，因此减少了实例化委托所需的编码开销。&lt;/p&gt;
&lt;h4 id=&#34;lamdba表达式是什么&#34;&gt;lamdba表达式是什么&lt;/h4&gt;
&lt;p&gt;“Lambda 表达式”是一个匿名函数，它可以包含表达式和语句，并且可用于创建委托或表达式树类型。&lt;/p&gt;
&lt;h4 id=&#34;扩展方法是什么&#34;&gt;扩展方法是什么&lt;/h4&gt;
&lt;p&gt;扩展方法是使我们能在现有类型的基础上添加新方法，而无需创建派生类、重新编译或以其他方式修改原始类型。&lt;/p&gt;
&lt;h4 id=&#34;linq是什么&#34;&gt;LINQ是什么&lt;/h4&gt;
&lt;p&gt;语言级集成查询（Language INtegrated Query），是一组用于c#和Visual Basic语言的扩展。它允许编写C#或者Visual Basic代码以查询数据库相同的方式操作内存数据。&lt;/p&gt;
&lt;h3 id=&#34;工作之外您看哪些技术相关的书网站社区项目等等您还接触哪些net以外的技术能和net或net中有针对性的部分做个对比吗&#34;&gt;工作之外您看哪些技术相关的书、网站、社区、项目等等？您还接触哪些.NET以外的技术，能和.NET或.NET中有针对性的部分做个对比吗？&lt;/h3&gt;
&lt;h2 id=&#34;面试题&#34;&gt;面试题&lt;/h2&gt;
&lt;h3 id=&#34;concurrentdictionary-or-dictionary&#34;&gt;ConcurrentDictionary or Dictionary&lt;/h3&gt;
&lt;p&gt;ConcurrentDictionary是&lt;code&gt;System.Collections.Concurrent&lt;/code&gt;中线程安全的字典类&lt;/p&gt;
&lt;h3 id=&#34;redis&#34;&gt;Redis&lt;/h3&gt;
&lt;h3 id=&#34;高可用性和高可靠性&#34;&gt;高可用性和高可靠性&lt;/h3&gt;
&lt;p&gt;Reliability和Availability分别对应可靠性和可用性, 这两个概念既有区别也有联系:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reliability定义为一个服务连续无故障运行的时间，无故障运行的时间越长，可靠性就越高。&lt;/li&gt;
&lt;li&gt;Availiability定义为在足够长的时间里，比如一年的时间里，一个服务可用的时间，服务可用时间越长越好。一般用可服务时间除于总时间算出一个百分比，用百分比作为度量。比如一个服务如果有5个9的可用性，指的就是一年里99.999%时间里服务都是可用的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有两个极端的例子可以很好的说明这两个概念的区别:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假想一个服务，可靠性很高，平均来说可以稳定运行10年，但是一旦服务中断，要用一年的时间来恢复，那么它的可用性只有90%。&lt;/li&gt;
&lt;li&gt;假想另一个服务，可靠性很差，运行10秒就会宕机，但是恢复服务只需要1ms, 那么它的可用性是99.99%&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从这两个极端的例子可以看出，提高可用性有两条路:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一是提高可靠性，当然影响可靠性的原因有很多，包括硬件，软件，网络，运维等。但是有人做过统计，软件的bug是影响可靠性的最主要的因素。并且提高软件质量相较于使用更可靠的硬件也算成本较低的方式了，&lt;/li&gt;
&lt;li&gt;二是减少恢复时间，一旦出现宕机，如果能在秒级恢复，那对业务影响是很小的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;高可用性&#34;&gt;高可用性&lt;/h4&gt;
&lt;p&gt;高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。&lt;/p&gt;
&lt;p&gt;方法论上，高可用是通过&lt;strong&gt;冗余+自动故障转移&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;p&gt;整个互联网分层系统架构的高可用，又是通过每一层的&lt;strong&gt;冗余+自动故障转移&lt;/strong&gt;来综合实现的，具体的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移&lt;/li&gt;
&lt;li&gt;【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移&lt;/li&gt;
&lt;li&gt;【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移&lt;/li&gt;
&lt;li&gt;【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性&lt;/li&gt;
&lt;li&gt;【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移&lt;/li&gt;
&lt;li&gt;【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/dot-net-interview-questions/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>About</title>
        <link>https://www.openheart.icu/about/</link>
        <pubDate>Fri, 17 Jul 2020 22:57:45 +0800</pubDate>
        
        <guid>https://www.openheart.icu/about/</guid>
        <description>42th openheart https://www.openheart.icu/about/ -&lt;h2 id=&#34;关于我&#34;&gt;关于我&lt;/h2&gt;
&lt;p&gt;I am Kris Nie.&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&#34;https://github.com/Hyominn&#34;&gt;@Hyominn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Ins: &lt;a href=&#34;https://www.instagram.com/hehe54213/&#34;&gt;@krisnie42&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Twitter: &lt;a href=&#34;https://twitter.com/hehe54213&#34;&gt;@hehe54213&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;关于本站&lt;/h2&gt;
&lt;p&gt;This is my Hugo blog :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;42th openheart.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用来记录我的第42次不开心&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── Gossip			#谨言慎行
├── Technical			#问啥啥不会
├── ComputerScience		#计算机科学
├── Arithmetic			#算法
├── About			#关于
├── Category			#归类
├── Tags			#标签
└── RSS Feed			#RSS订阅
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;Thanks for theme makers:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Hugo Theme &lt;a href=&#34;https://github.com/amazingrise/hugo-theme-diary&#34;&gt;Diary&lt;/a&gt; by &lt;a href=&#34;https://amazingrise.net/&#34;&gt;Rise&lt;/a&gt; Ported from &lt;a href=&#34;https://mak1t0.cc/&#34;&gt;Makito&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;https://github.com/SumiMakito/hexo-theme-journal/&#34;&gt;Journal.&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
- https://www.openheart.icu/about/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>206. Reverse Linked List</title>
        <link>https://www.openheart.icu/arithmetic/206.-reverse-linked-list/</link>
        <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/arithmetic/206.-reverse-linked-list/</guid>
        <description>42th openheart https://www.openheart.icu/arithmetic/206.-reverse-linked-list/ -&lt;h1 id=&#34;reverse-a-singly-linked-listhttpsleetcode-cncomproblemsreverse-linked-list&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/reverse-linked-list&#34;&gt;Reverse a singly linked list.&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Follow up:&lt;/p&gt;
&lt;p&gt;A linked list can be reversed either iteratively or recursively. Could you implement both?&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;迭代&#34;&gt;迭代&lt;/h2&gt;
&lt;p&gt;将&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转化为&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NULL&amp;lt;-1&amp;lt;-2&amp;lt;-3&amp;lt;-4&amp;lt;-5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用一个prev节点存储上一个节点（初始为NULL），将当前curr节点的next指向prev节点，prev节点存储curr节点，curr存储curr的原next节点，完成一次迭代。最后返回prev（最后的curr是原ListNode的NULL）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * Definition for singly-linked list.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * public class ListNode {
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *     int val;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *     ListNode next;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *     ListNode(int x) { val = x; }
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * }
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; ListNode &lt;span style=&#34;color:#008b45&#34;&gt;reverseList&lt;/span&gt;(ListNode head) {
    ListNode prev = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
    ListNode curr = head;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (curr != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
        ListNode nextTemp = curr.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt;;
        curr.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; = prev;
        prev = curr;
        curr = nextTemp;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; prev;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;时间复杂度分析&#34;&gt;时间复杂度分析&lt;/h3&gt;
&lt;p&gt;时间复杂度：&lt;em&gt;O&lt;/em&gt;(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：&lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
&lt;h2 id=&#34;递归&#34;&gt;递归&lt;/h2&gt;
&lt;p&gt;将
$$
n_1→&amp;hellip;→n_{k−1}→n_k→n_{k+1}→&amp;hellip;→n_m→∅
$$
转化为
$$
n_1→&amp;hellip;→n_{k−1}→n_k→n_{k+1}←&amp;hellip;←n_m
$$
先转化原链表最后一个节点，然后依次转化直到n&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; ListNode &lt;span style=&#34;color:#008b45&#34;&gt;reverseList&lt;/span&gt;(ListNode head) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (head == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt; || head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; head;
    ListNode p = reverseList(head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt;);
    head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; = head;
    head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; p;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;时间复杂度分析-1&#34;&gt;时间复杂度分析&lt;/h3&gt;
&lt;p&gt;时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。
空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。&lt;/p&gt;
- https://www.openheart.icu/arithmetic/206.-reverse-linked-list/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
  </channel>
</rss> 