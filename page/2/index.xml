<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>42th openheart</title>
    <link>https://www.openheart.icu/</link>
    <description>Recent content on 42th openheart</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>ALL RIGHTS RESERVED KRIS NIE</copyright>
    <lastBuildDate>Sat, 15 Aug 2020 16:27:30 +0000</lastBuildDate>
    
        <atom:link href="https://www.openheart.icu/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Oracle</title>
        <link>https://www.openheart.icu/cs/oracle/</link>
        <pubDate>Tue, 21 Jul 2020 20:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/oracle/</guid>
        <description>42th openheart https://www.openheart.icu/cs/oracle/ -&lt;h1 id=&#34;common-operation&#34;&gt;Common Operation&lt;/h1&gt;
&lt;h2 id=&#34;删除操作前一定要先执行一遍查询&#34;&gt;删除操作前一定要先执行一遍查询&lt;/h2&gt;
&lt;p&gt;如题， 带的一个新员工做补丁把项目历史数据干掉了 My bad.&lt;/p&gt;
&lt;p&gt;2020-8-7&lt;/p&gt;
&lt;h1 id=&#34;optimize&#34;&gt;Optimize&lt;/h1&gt;
&lt;h2 id=&#34;索引失效&#34;&gt;索引失效&lt;/h2&gt;
&lt;p&gt;SQL在&lt;code&gt;WHERE&lt;/code&gt;条件里面使用了&lt;code&gt;IN&lt;/code&gt;导致有一个关联表的索引失效，Oracle版本为11g&lt;/p&gt;
&lt;p&gt;条件中有or，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引&lt;/p&gt;
&lt;p&gt;like查询是以%开头&lt;/p&gt;
&lt;p&gt;如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引&lt;/p&gt;
&lt;h2 id=&#34;分库-分表-分区&#34;&gt;分库 分表 分区&lt;/h2&gt;
&lt;h2 id=&#34;视图优化&#34;&gt;视图优化&lt;/h2&gt;
&lt;h3 id=&#34;基表增加索引&#34;&gt;基表增加索引&lt;/h3&gt;
&lt;p&gt;对基表中，视图查询SQL的&lt;code&gt;WHERE&lt;/code&gt;条件中用到的字段增加索引&lt;/p&gt;
&lt;h3 id=&#34;重新进行表分析&#34;&gt;重新进行表分析&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;-- 视图查询慢
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;

&lt;span style=&#34;color:#228b22&#34;&gt;-- 在当前用户下执行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;analyze table &amp;#39;&lt;/span&gt;||&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;||&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; compute statistics;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;IN&lt;/span&gt; (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;tablename&amp;#39;&lt;/span&gt;);   

&lt;span style=&#34;color:#228b22&#34;&gt;-- 得到如下语句，将这些语句整体执行一遍
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; PRODUCT_REF_LIST_NESTEDTAB compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#228b22&#34;&gt;-- ....
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;-- 查看统计信息
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;,num_rows &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分析的结果被Oracle用于基于成本的优化生成更好的查询计划。&lt;/p&gt;
&lt;p&gt;遇到当前表的查询或其他性能不好时，就可以对相应的表进行一次分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你的表经常由几千万变成几百万，又变成几千万那么需要制定分析计划定期表分析，同时可以一并分析索引，计算索引中数据的分布情况，这样CBO会选择更加准确的执行计划。&lt;/li&gt;
&lt;li&gt;如果表结构变化了也要做下，也就是经常对表做dml就需要分析，现在推荐使用dbms_stats包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;error&#34;&gt;ERROR&lt;/h1&gt;
&lt;h2 id=&#34;ora-01779-无法修改与非键值保存表对应的列&#34;&gt;ORA-01779: 无法修改与非键值保存表对应的列&lt;/h2&gt;
&lt;p&gt;这里要搞清楚三个概念：视图、联接视图、可更新的联接视图&lt;/p&gt;
&lt;h3 id=&#34;视图&#34;&gt;视图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;视图&lt;/strong&gt;可以分为视图对象和内嵌视图两种。&lt;/p&gt;
&lt;h4 id=&#34;视图对象view-object&#34;&gt;视图对象（View Object）&lt;/h4&gt;
&lt;p&gt;数据库里的&lt;strong&gt;视图对象&lt;/strong&gt;跟一张表或索引等一样，是数据库对象中的一种，它其实是将基于表中原始数据的查询给虚拟了一层之后，提供给外部查询的一种对象。
其本质是并不保存查询的实际结果，而只是将查询语句保存在数据库中，当用户查询某张视图的时候，就会找到并执行这个视图的语句。
而&lt;strong&gt;联接视图&lt;/strong&gt;其实就是在一个视图中将两个表建立关联就是了。&lt;/p&gt;
&lt;h4 id=&#34;内嵌视图inline-view&#34;&gt;内嵌视图（Inline View）&lt;/h4&gt;
&lt;p&gt;在SQL语句中，很多地方都可以写嵌套的语句，比如说，FROM后面可以套括号嵌套其他的语句，WHERE、SELECT、UPDATE、INSERT、DELETE后面都是可以写的。只是写的位置不同，执行的方式还有处理时的一些限制不同，这些SQL中嵌套的SQL被称为&lt;strong&gt;子查询（Subquery）&lt;/strong&gt; 。子查询可以分为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内嵌视图：位置位于FROM语句中，也相当于一个预处理结果集的概念&lt;/li&gt;
&lt;li&gt;标量子查询（Scalar Subquery）：只返还一个结果值的子查询。位于SELECT语句的子查询只能返还一个值，所以必然是标量子查询，WHERE语句里也会出现这样的子查询&lt;/li&gt;
&lt;li&gt;关联子查询：将查询的结果传递给子查询作为参数的使用的形式&lt;/li&gt;
&lt;li&gt;一般子查询：除了那些特殊形式的子查询以外的一般用法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;可更新联接视图updatable-join-view-&#34;&gt;可更新联接视图（Updatable Join View ）&lt;/h4&gt;
&lt;p&gt;将一个联接视图（包括视图对象和内嵌视图）放到UPADTE语句中这样的语法形式。&lt;/p&gt;
&lt;p&gt;同样的道理，如果只是用一个表来作为视图的基表，则可以对该视图直接进行&lt;code&gt;DELETE&lt;/code&gt;和&lt;code&gt;UPDATE&lt;/code&gt;，但无法直接执行&lt;code&gt;INSERT&lt;/code&gt;，因为该视图没有默认值的非空列(&lt;code&gt;brand_id&lt;/code&gt;)。该视图称为&lt;strong&gt;可更新视图&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;报错原理&#34;&gt;报错原理&lt;/h3&gt;
&lt;p&gt;Oracle的键值保存表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; *
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; DBA_UPDATABLE_COLUMNS
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;SCOTT&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;EMP_DEPT_V&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COLUMN_NAME&lt;/span&gt; | UPDATABLE | INSERTABLE | DELETABLE
SCOTT   EMP_DEPT_V     EMPNO            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     ENAME            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     SAL              &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     DEPTNO           &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     DNAME            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;视图&lt;code&gt;EMP_DEPT_V&lt;/code&gt;里的字段都无法变更。&lt;/p&gt;
&lt;p&gt;如果能保证DEPT_T表里的数据是唯一的就能够更新。也就是说在DEPT_T表上加&lt;code&gt;主键约束&lt;/code&gt;或&lt;code&gt;唯一约束&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; DEPT_T
     &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ADD&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;CONSTRAINT&lt;/span&gt; PK_DEPT_T &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;KEY&lt;/span&gt; (DEPTNO);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再看一下之前的视图：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; *
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; DBA_UPDATABLE_COLUMNS
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;SCOTT&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;EMP_DEPT_V&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COLUMN_NAME&lt;/span&gt; | UPDATABLE | INSERTABLE | DELETABLE
SCOTT   EMP_DEPT_V     EMPNO            YES         YES         YES
SCOTT   EMP_DEPT_V     ENAME            YES         YES         YES
SCOTT   EMP_DEPT_V     SAL              YES         YES         YES
SCOTT   EMP_DEPT_V     DEPTNO           YES         YES         YES
SCOTT   EMP_DEPT_V     DNAME             &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个时候就可以看到，视图中&lt;code&gt;EMP_DEPT_V&lt;/code&gt;表中原来的字段都是可以更新的了。&lt;/p&gt;
&lt;p&gt;在对联接视图进行变更的时候，必须保证修改后的值是唯一的，并且这个事实要让数据库知道，而告知数据库的方法是建立主键约束或唯一约束。&lt;/p&gt;
&lt;p&gt;并不是所有的表都可以随意建这些约束，有什么方法能够不添加约束也能变更？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加&lt;code&gt;/*+ BYPASS_UJVC */&lt;/code&gt; 提示，让ORACLE跳过检查（11g R2之后无效，不建议使用）&lt;/li&gt;
&lt;li&gt;改写&lt;code&gt;UPDATE&lt;/code&gt;语句，通过其他方式判断后处理&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;UPDATE&lt;/code&gt;改成&lt;code&gt;MERGE&lt;/code&gt;语句&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Oracle：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The concept of a &lt;strong&gt;key-preserved table&lt;/strong&gt; is fundamental to understanding the restrictions on &lt;strong&gt;modifying join views&lt;/strong&gt;. A table is key-preserved if every key of the table can also be a key of the result of the join. So, a key-preserved table has its keys preserved through a join.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;An &lt;strong&gt;updatable join view&lt;/strong&gt; (also referred to as a &lt;strong&gt;modifiable join view&lt;/strong&gt;) is a view that contains multiple tables in the top-level FROM clause of the SELECT statement, and is not restricted by the WITH READ ONLY clause.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/60a56760b19f&#34;&gt;https://www.jianshu.com/p/60a56760b19f&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.yiibai.com/oracle/oracle-updatable-view.html&#34;&gt;https://www.yiibai.com/oracle/oracle-updatable-view.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://www.openheart.icu/cs/oracle/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Speech</title>
        <link>https://www.openheart.icu/cs/speech/</link>
        <pubDate>Tue, 21 Jul 2020 19:45:28 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/speech/</guid>
        <description>42th openheart https://www.openheart.icu/cs/speech/ -&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;唯一不适应远程工作的是中层管理人员。&lt;/p&gt;
&lt;p&gt;基层员工对于在家工作感到很高兴，只要把活做好就可以了。高层管理人员只需要对销售和产量数字负责。中层管理人员的不适应在于，他们的职责是直接监控基层员工，最常用的判断方法是通过是否坐在座位上等迹象，来判断工作量和工作是否勤奋。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=23607203&#34;&gt;Hacker news 读者&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我有一种反英雄主义的精神。以前看电视时，我就对皇帝和将军不感兴趣，觉得他们已经有荣耀和风光了。&lt;/p&gt;
&lt;p&gt;我更关心皇帝和将军手下的那些小兵，有时战斗刚开始，他们就被杀死了。他们脑海里想的是什么？会有人记得他们，为他们哭泣吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 黄西自传《黄瓜的黄，西瓜的西》&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;时钟和镜子改变了人类社会。&lt;/p&gt;
&lt;p&gt;时钟创造了一种焦虑文化。&lt;/p&gt;
&lt;p&gt;镜子创造了一种自恋文化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; David Perell&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;100年前的中国，四千个人里面才有一个中学生，其他都是文盲。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 李敖&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;看到抽象的东西，应该尽量使它变得具体；看到具体的东西，应该尽量使它变得抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 李敖&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你花钱买，你就是客户，如果你免费获得，你就是产品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.wired.com/story/a-startup-is-testing-the-subscription-model-for-search-engines/&#34;&gt;《创业公司尝试搜索引擎的订阅模式》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;40年前算法很重要，大部分程序员都需要懂，因为硬件差，必须靠算法保证性能。&lt;/p&gt;
&lt;p&gt;但是今天只剩下不到1%的程序员直接跟算法打交道，其他人都使用现成的软件包，或从大公司购买算法，算法已成为一种商品，普通程序员不再需要自己生产了，也不需要有很深入的了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;http://shape-of-code.coding-guidelines.com/2020/07/05/algorithms-are-now-commodities/&#34;&gt;《算法现在是商品》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;本站100%无 JavaScript。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.swiftbysundell.com/special/javascript-free/&#34;&gt;swiftbysundell.com&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我希望 JavaScript 程序员、Java 程序员、PHP 程序员、Perl 程序员、Python 程序员、C 程序员、C ++ 程序员、以及其他重要语言的程序员，大家聚在一起开个会，一劳永逸地提出一个大家都遵守的解决方案，我们应该如何处理时间和日期。我厌倦了每个语言都有自己一套处理时间和日期的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=23781819&#34;&gt;《JavaScript 语言准备提出新的时间和日期 API》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;至少12年 Kubernetes 经验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Required Technical and Professional Expertise&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Minimum 12+ years’ experience in Kubernetes administration and management&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; IBM 招聘云工程师的&lt;a href=&#34;https://intellijobs.ai/job/IBMCloud-Native-Infrastructure-Engineer-Architect-bvJJ6yraexfWOk1nMRKP-bvJJ6yraexfWOk1nMRKP&#34;&gt;公告&lt;/a&gt;，但 Kubernetes 是2014年发布的。&lt;/p&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;一家公司获得垄断地位以后，就不需要从任何形式的产品开发获益了，只通过市场营销或金融工程就能增加利润。最终，公司就会被销售人员和财务人员控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 史蒂夫·乔布斯&lt;/p&gt;
&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;锚定偏差（anchoring bias）指的是决策时严重依赖第一个可用的信息。&lt;/p&gt;
&lt;p&gt;比如，你走进一家体育用品商店，发现的第一件商品，是一条价值500美元的运动裤。接着，你看到另一条价格为300美元的运动裤时，就会觉得它很便宜，实际上如果首先看到这条300美元的裤子，你会觉得它根本不便宜。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://models.substack.com/p/why-are-we-anchored-often&#34;&gt;《锚定偏差》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;信息成瘾指的是强迫性信息消费：明明已经看完所有内容，你仍在继续滚动浏览 Facebook；你刚刚关闭 Instagram，立即再次打开它；你每五分钟拿起手机，检查有没有新的通知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.defetter.com/&#34;&gt;《什么是信息成瘾》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;14&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;谷歌的网页排名算法 PageRank，得名于创始人拉里·佩奇（ Larry Page），实际含义是佩奇的算法（Page&amp;rsquo;s rank）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://notes.rolandcrosby.com/posts/unexpectedly-eponymous/&#34;&gt;《意想不到的来自人名的事物》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;低本底钢（Low-background steel）指的是1945年第一枚核弹爆炸之前生产的任何钢铁。此后有了核爆，大气中辐射物质增加，影响了所生产的所有钢铁。&lt;/p&gt;
&lt;p&gt;低本底钢目前用于需要最高灵敏度的放射性核检测设备中，主要来源是在第一次核爆发生前建造的船只，它们大多沉没在水底。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://en.wikipedia.org/wiki/Low-background_steel&#34;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;16&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我一直是“强观点，弱立场”（strong opinions, weakly held）。&lt;/p&gt;
&lt;p&gt;不管什么事情，我都会凭直觉得到一个结论，这就是“强观点”；只要有任何与结论相悖的信息，我就会修正自己的观点，这就是“弱立场”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://commoncog.com/blog/strong-opinions-weakly-held-is-bad/&#34;&gt;《强观点，弱立场》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;17&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;几乎所有的企业软件公司，都是销售人员多于工程人员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=23907923&#34;&gt;Hacker News 读者&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;18&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;地球与火星之间的通讯大约需要40分钟，发出一条指令，40分钟以后才能收到，这意味着火星登陆器必须高度自动化，具有自主决策的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://thediplomat.com/2020/07/why-is-china-going-to-mars/&#34;&gt;《中国为什么想去火星》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;19&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;女：你觉得怎样才是“完美的约会”（the perfect date）？&lt;/p&gt;
&lt;p&gt;男： DD/MM/YYYY，别的日期格式（date format）都容易产生误会。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://twitter.com/rafrasenberg/status/1286968074323865602&#34;&gt;推特&lt;/a&gt;。英语里面，约会和日期是同一个词&lt;code&gt;date&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;20&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;REST 和 GraphQL 的最大区别是处理缓存的方式。&lt;/p&gt;
&lt;p&gt;当你用 REST 方式构建 API 时，基本上可以自动获得 HTTP 的缓存能力。如果选择 GraphQL，你就需要自己为客户端或应用程序添加缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.stxnext.com/blog/how-to-build-a-good-api-that-wont-embarrass-you&#34;&gt;《如何构建优秀 API》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;21&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;不要轻易说出自己痛苦，能体会的人很少，看热闹的人很多。&lt;/p&gt;
&lt;p&gt;也不要轻易炫耀，会替你感到高兴的人很少，等着看你最后下场的人很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 推特用户&lt;/p&gt;
&lt;ol start=&#34;22&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;所谓完美，不是指不能再添加别的东西了，而是指没有东西可以从其中拿掉了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.brainyquote.com/quotes/antoine_de_saintexupery_103610&#34;&gt;安托万·德圣埃克絮佩里&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;23&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;公司刚成立时，需要瑞士军刀型人才。&lt;/p&gt;
&lt;p&gt;公司一旦发展壮大，需要菜刀型人才。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; David Perell&lt;/p&gt;
&lt;ol start=&#34;24&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;硬件总是变得越来越快，但软件总是变得越来越慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://en.wikipedia.org/wiki/Wirth&#39;s_law&#34;&gt;维尔斯定律&lt;/a&gt;（Wirth&amp;rsquo;s law）&lt;/p&gt;
&lt;ol start=&#34;25&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;SSD 固态硬盘变成主流，导致 Windows 10 在 HDD 机械硬盘上几乎无法使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=24015218&#34;&gt;Hacker News 读者&lt;/a&gt;&lt;/p&gt;
- https://www.openheart.icu/cs/speech/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>剑指 Offer 46. 把数字翻译成字符串</title>
        <link>https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/</link>
        <pubDate>Tue, 21 Jul 2020 19:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/</guid>
        <description>42th openheart https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/ -&lt;h1 id=&#34;把数字翻译成字符串httpsleetcode-cncomproblemsba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/&#34;&gt;把数字翻译成字符串&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是&lt;code&gt;bccfi&lt;/code&gt;, &lt;code&gt;bwfi&lt;/code&gt;, &lt;code&gt;bczi&lt;/code&gt;, &lt;code&gt;mcfi&lt;/code&gt;和&lt;code&gt;mzi&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0 &amp;lt;= num &amp;lt; 2&lt;!-- raw HTML omitted --&gt;31&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;动态规划&#34;&gt;动态规划&lt;/h2&gt;
&lt;p&gt;拿示例看&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先考虑每个数字单独翻译的情况，即翻译&lt;code&gt;[1,2,2,4,8]&lt;/code&gt;，结果为&lt;code&gt;bccfi&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以将数字拼接为两位的情况，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[12,2,4,8]&lt;/code&gt; &lt;code&gt;mcfi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[12,24,8]&lt;/code&gt; &lt;code&gt;mzi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[12,2,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,22,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,22,4,8]&lt;/code&gt; &lt;code&gt;bwfi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,2,24,8]&lt;/code&gt; &lt;code&gt;bczi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,2,2,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;归纳规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以单独作为一位来翻译&lt;/li&gt;
&lt;li&gt;如果第 &lt;code&gt;i−1&lt;/code&gt; 位和第 &lt;code&gt;i&lt;/code&gt; 位组成的数字在 10 到 25 之间，可以把这两位连起来翻译&lt;/li&gt;
&lt;/ul&gt;
- https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>DNS</title>
        <link>https://www.openheart.icu/cs/dns/</link>
        <pubDate>Sun, 19 Jul 2020 12:50:56 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/dns/</guid>
        <description>42th openheart https://www.openheart.icu/cs/dns/ -&lt;h2 id=&#34;dnspod-dns&#34;&gt;DNSPod DNS+&lt;/h2&gt;
&lt;p&gt;​            首选：119.29.29.29&lt;/p&gt;
&lt;p&gt;​            备选：182.254.116.116&lt;/p&gt;
&lt;h3 id=&#34;114dns&#34;&gt;114DNS&lt;/h3&gt;
&lt;p&gt;​            首选：114.114.114.114&lt;/p&gt;
&lt;p&gt;​            备选：114.114.114.115&lt;/p&gt;
&lt;h3 id=&#34;阿里-alidns&#34;&gt;阿里 AliDNS&lt;/h3&gt;
&lt;p&gt;​            首选：223.5.5.5&lt;/p&gt;
&lt;p&gt;​            备选：223.6.6.6&lt;/p&gt;
&lt;h3 id=&#34;dns派&#34;&gt;DNS派&lt;/h3&gt;
&lt;p&gt;​            首选（电信/移动/铁通）：101.226.4.6&lt;/p&gt;
&lt;p&gt;​            备选（电信/移动/铁通）：218.30.118.6&lt;/p&gt;
&lt;p&gt;​            首选（联通）：123.125.81.6&lt;/p&gt;
&lt;p&gt;​            备选（联通）：140.207.198.6&lt;/p&gt;
&lt;h3 id=&#34;百度-baidudns&#34;&gt;百度 BaiduDNS&lt;/h3&gt;
&lt;p&gt;​            首选：180.76.76.76&lt;/p&gt;
&lt;h3 id=&#34;cnnic-sdns&#34;&gt;CNNIC SDNS&lt;/h3&gt;
&lt;p&gt;​            首选：1.2.4.8&lt;/p&gt;
&lt;p&gt;​            备选：202.98.0.68&lt;/p&gt;
&lt;h3 id=&#34;opendns&#34;&gt;OpenDNS&lt;/h3&gt;
&lt;p&gt;​            208.67.222.222&lt;/p&gt;
&lt;p&gt;​            208.67.220.220&lt;/p&gt;
&lt;p&gt;​            208.67.222.220&lt;/p&gt;
&lt;p&gt;​            208.67.220.222&lt;/p&gt;
&lt;h3 id=&#34;family-shield-servers&#34;&gt;Family Shield Servers&lt;/h3&gt;
&lt;p&gt;可以阻挡成人网站和含有恶意网站&lt;/p&gt;
&lt;p&gt;​            208.67.222.123&lt;/p&gt;
&lt;p&gt;​            208.67.220.123&lt;/p&gt;
&lt;h3 id=&#34;ipv6地址实验&#34;&gt;IPv6地址(实验)&lt;/h3&gt;
&lt;p&gt;​            2620:0:ccc::2&lt;/p&gt;
&lt;p&gt;​            2620:0:ccd::2&lt;/p&gt;
- https://www.openheart.icu/cs/dns/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title> 当面调试</title>
        <link>https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/</link>
        <pubDate>Sat, 18 Jul 2020 10:28:50 +0000</pubDate>
        
        <guid>https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/</guid>
        <description>42th openheart https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/ -&lt;p&gt;当我在被面试的时候我再想些什么？&lt;/p&gt;
- https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>.NET INTERVIEW</title>
        <link>https://www.openheart.icu/cs/dot-net-interview/</link>
        <pubDate>Fri, 17 Jul 2020 23:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/dot-net-interview/</guid>
        <description>42th openheart https://www.openheart.icu/cs/dot-net-interview/ -&lt;h1 id=&#34;net-interview&#34;&gt;.NET INTERVIEW&lt;/h1&gt;
&lt;h2 id=&#34;from-jeffrey-zhaos-blog&#34;&gt;from Jeffrey Zhao&amp;rsquo;s blog&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.zhaojie.me/2011/03/my-interview-questions-for-dotnet-programmers.html&#34;&gt;我在面试.NET/C#程序员时会提出的问题&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;什么是net什么是cli什么是clril是什么jit是什么它是如何工作的gc是什么简述一下gc的工作方式&#34;&gt;什么是.NET？什么是CLI？什么是CLR？IL是什么？JIT是什么，它是如何工作的？GC是什么，简述一下GC的工作方式？&lt;/h3&gt;
&lt;h4 id=&#34;什么是net&#34;&gt;什么是.net&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;.NET是个平台，你就把它看成C#&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一个.NET应用是一个运行于.NET Framework之上的应用程序。（更精确的说，一个.NET应用是一个使用.NET Framework类库来编写，并运行于公共语言运行时 Common Language Runtime之上的应用程序。）如果一个应用程序跟.NET Framework无关，它就不能叫做.NET程序。比如，仅仅使用了XML并不就是.NET应用，仅仅使用SOAP SDK调用一个Web Service也不是.NET应用&lt;/p&gt;
&lt;p&gt;开发平台（Dot Net Framework）：包含通用语言运行时（CLR）和Dot Net框架类库（FCL）两个部分。他们提供了一致的编程模型，简化的编程方式，可靠的版本机制（用全局程序集缓存GAC来避免DLL Hell），轻便的部署管理（程序集自带的元数据可以避免ini文件和注册表） ，广泛的平台支持（只要这台机器兼容标准下的CLR和FCL就可以部署，当然运行的时候IL会变成本机代码），无缝的语言集成，自动化的内存管理（垃圾收集），类型安全（CLR会阻止利用缓冲区溢出错误进行的攻击），CLR支持跨语言调试，统一的错误报告，全新的安全策略（CAS），兼容以往的COM组件&lt;/p&gt;
&lt;h4 id=&#34;什么是clr&#34;&gt;什么是CLR&lt;/h4&gt;
&lt;p&gt;CLR(公用语言运行时)和Java虚拟机一样也是一个&lt;strong&gt;运行时环境&lt;/strong&gt;，它负责资源管理（内存分配和垃圾收集），并保证应用和底层操作系统之间必要的分离。.NET Framework 提供了一个称为公共语言运行时的运行时环境**（Commen Language Runtime）**，它运行代码并提供使开发过程更轻松的服务。公共语言运行时的功能通过编译器和工具公开，你可以编写利用此托管执行环境的代码。 使用基于公共语言运行时的语言编译器开发的代码称为托管代码；托管代码具有许多优点，例如：跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。&lt;/p&gt;
&lt;h4 id=&#34;什么是cli&#34;&gt;什么是CLI&lt;/h4&gt;
&lt;p&gt;通用语言基础结构（Common Language Infrastructure，CLI）是CLR的一个子集，也就是.NET中最终对编译成MSIL代码的应用程序的运行环境进行管理的那一部分。在 CLR结构图中CLI位于下半部分，主要包括类加载器(Class Loader)、实时编译器(IL To Native Compilers)和一个运行时环境的垃圾收集器(Garbage Collector)。CLI是.Net和CLR的灵魂，CLI为IL代码提供运行的环境，你可以将使用任何语言编写的代码通过其特定的编译器转换为 MSIL代码之后运行其上，甚至还可以自己写MSIL代码在CLI上面运行。&lt;/p&gt;
&lt;h4 id=&#34;什么是il&#34;&gt;什么是IL&lt;/h4&gt;
&lt;p&gt;IL是微软.NET平台上衍生出来的一门中间语言，.NET平台上的各种高级语言（如C#，VB，F#）的编译器会将各自的文字表述方式转化为 IL。各种不同的文字形式最终被统一到了IL的表述方式，其中包含了.NET平台上的各种元素，如“范型”，“类”、、“接口”、“模块”、“属性”等 等。值得注意的是，各种高级语言本身可能根本没有这些“概念”在里头，如IronScheme是一个在.NET平台上的Scheme语言实现，其中根本没有前面提到的这些IL——亦或说是.NET平台上的名词。IL本身并不知道自己是由哪种高级语言转化而来的，哪种语言中有哪些特性，IL也根本不会关心。&lt;/p&gt;
&lt;h4 id=&#34;什么是jit&#34;&gt;什么是JIT&lt;/h4&gt;
&lt;p&gt;JIT（Just In Time, JIT）是.Net边运行边编译的一种机制。&lt;/p&gt;
&lt;p&gt;开发人员需要通过IL与CLR进行交流, 虽然IL本身支持一些面向对象的概念, 但是对于开发人员来讲还是过于复杂低效, 于是C#应运而生, 程序员只需编写C#代码, csc编译器会将其翻译成IL;虽然CLR理解IL, 但是CPU只认识二进制指令, 所以CLR需要JIT的帮助, 将IL翻译成CPU指令. JIT按需工作, 当一个.NET方法即将被执行时, JIT会介入, 把该方法(IL指令) 编译成CPU指令, 并保存以供重用。&lt;/p&gt;
&lt;h4 id=&#34;什么是gc以及它的工作方式&#34;&gt;什么是GC，以及它的工作方式&lt;/h4&gt;
&lt;p&gt;GC:.NET Framework 的垃圾回收器管理应用程序的内存分配和释放&lt;/p&gt;
&lt;h5 id=&#34;分配内存&#34;&gt;分配内存&lt;/h5&gt;
&lt;p&gt;初始化新进程时，运行时会为进程保留一个连续的地址空间区域。 这个保留的地址空间被称为托管堆。 托管堆维护着一个指针，用它指向将在堆中分配的下一个对象的地址。 最初，该指针设置为指向托管堆的基址。 托管堆上包含了所有&lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/common-type-system&#34;&gt;引用类型&lt;/a&gt;。 应用程序创建第一个引用类型时，将为托管堆的基址中的类型分配内存。 应用程序创建下一个对象时，垃圾回收器在紧接第一个对象后面的地址空间内为它分配内存。 只要地址空间可用，垃圾回收器就会继续以这种方式为新对象分配空间。&lt;/p&gt;
&lt;p&gt;从托管堆中分配内存要比非托管内存分配速度快。 由于运行时通过为指针添加值来为对象分配内存，所以这几乎和从堆栈中分配内存一样快。 另外，由于连续分配的新对象在托管堆中是连续存储，所以应用程序可以快速访问这些对象。&lt;/p&gt;
&lt;h5 id=&#34;释放内存&#34;&gt;释放内存&lt;/h5&gt;
&lt;p&gt;垃圾回收器的优化引擎根据所执行的分配决定执行回收的最佳时间。 垃圾回收器在执行回收时，会释放应用程序不再使用的对象的内存。 它通过检查应用程序的根来确定不再使用的对象。 每个应用程序都有一组根。 每个根或者引用托管堆中的对象，或者设置为空。 应用程序的根包含线程堆栈上的静态字段、局部变量和参数以及 CPU 寄存器。 垃圾回收器可以访问由&lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process&#34;&gt;实时 (JIT) 编译器&lt;/a&gt;和运行时维护的活动根的列表。 垃圾回收器对照此列表检查应用程序的根，并在此过程中创建一个图表，在其中包含所有可从这些根中访问的对象。&lt;/p&gt;
&lt;p&gt;不在该图表中的对象将无法从应用程序的根中访问。 垃圾回收器会考虑无法访问的对象垃圾，并释放为它们分配的内存。 在回收中，垃圾回收器检查托管堆，查找无法访问对象所占据的地址空间块。 发现无法访问的对象时，它就使用内存复制功能来压缩内存中可以访问的对象，释放分配给不可访问对象的地址空间块。 在压缩了可访问对象的内存后，垃圾回收器就会做出必要的指针更正，以便应用程序的根指向新地址中的对象。 它还将托管堆指针定位至最后一个可访问对象之后。 请注意，只有在回收发现大量的无法访问的对象时，才会压缩内存。 如果托管堆中的所有对象均未被回收，则不需要压缩内存。&lt;/p&gt;
&lt;p&gt;为了改进性能，运行时为单独堆中的大型对象分配内存。 垃圾回收器会自动释放大型对象的内存。 但是，为了避免移动内存中的大型对象，不会压缩此内存。&lt;/p&gt;
&lt;h5 id=&#34;级别和性能&#34;&gt;级别和性能&lt;/h5&gt;
&lt;p&gt;为优化垃圾回收器的性能，将托管堆分为三代：第 0 代、第 1 代和第 2 代。运行时的垃圾回收算法基于以下几个普遍原理，这些垃圾回收方案的原理已在计算机软件业通过实验得到了证实。 首先，压缩托管堆的一部分内存要比压缩整个托管堆速度快。 其次，较新的对象生存期较短，而较旧的对象生存期则较长。 最后，较新的对象趋向于相互关联，并且大致同时由应用程序访问。&lt;/p&gt;
&lt;p&gt;运行时的垃圾回收器将新对象存储在第 0 级中。 在应用程序生存期的早期创建的对象如果未被回收，则被升级并存储在第 1 级和第 2 级中。因为压缩托管堆的一部分要比压缩整个托管堆速度快，所以此方案允许垃圾回收器在每次执行回收时释放特定级别的内存，而不是整个托管堆的内存。&lt;/p&gt;
&lt;p&gt;实际上，垃圾回收器在第 0 级托管堆已满时执行回收。 如果应用程序在第 0 级托管堆已满时尝试新建对象，垃圾回收器将会发现第 0 级托管堆中没有可分配给该对象的剩余地址空间。 垃圾回收器执行回收，尝试为对象释放第 0 级托管堆中的地址空间。 垃圾回收器从检查第 0 级托管堆中的对象（而不是托管堆中的所有对象）开始执行回收。 这是最有效的途径，因为新对象的生存期往往较短，并且期望在执行回收时，应用程序不再使用第 0 级托管堆中的许多对象。 另外，单独回收第 0 级托管堆通常可以回收足够的内存，这样，应用程序便可以继续创建新对象。&lt;/p&gt;
&lt;p&gt;垃圾回收器执行第 0 级托管堆的回收后，会压缩可访问对象的内存，如本主题前面的&lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/standard/automatic-memory-management#cpconautomaticmemorymanagementreleasingmemoryanchor1&#34;&gt;释放内存&lt;/a&gt;中所述。 然后，垃圾回收器升级这些对象，并考虑第 1 级托管堆的这一部分。 因为未被回收的对象往往具有较长的生存期，所以将它们升级至更高的级别很有意义。 因此，垃圾回收器在每次执行第 0 级托管堆的回收时，不必重新检查第 1 级和第 2 级托管堆中的对象。&lt;/p&gt;
&lt;p&gt;在执行第 0 级托管堆的首次回收并把可访问的对象升级至第 1 级托管堆后，垃圾回收器将考虑第 0 级托管堆的其余部分。 它将继续为第 0 级托管堆中的新对象分配内存，直至第 0 级托管堆已满并需执行另一回收为止。 这时，垃圾回收器的优化引擎会决定是否需要检查较旧的级别中的对象。 例如，如果第 0 级托管堆的回收没有回收足够的内存，不能使应用程序成功完成创建新对象的尝试，垃圾回收器就会先执行第 1 级托管堆的回收，然后再执行第 2 级托管堆的回收。 如果这样仍不能回收足够的内存，垃圾回收器将执行第 2、1 和 0 级托管堆的回收。 每次回收后，垃圾回收器都会压缩第 0 级托管堆中的可访问对象并将它们升级至第 1 级托管堆。 第 1 级托管堆中未被回收的对象将会升级至第 2 级托管堆。 由于垃圾回收器只支持三个级别，因此第 2 级托管堆中未被回收的对象会继续保留在第 2 级托管堆中，直到在将来的回收中确定它们为无法访问为止。&lt;/p&gt;
&lt;h3 id=&#34;类class和结构struct的区别是什么它们对性能有影响吗net-bcl里有哪些是类结构为什么它们不是结构类在自定义类型时您如何选择是类还是结构&#34;&gt;类（class）和结构（struct）的区别是什么？它们对性能有影响吗？.NET BCL里有哪些是类（结构），为什么它们不是结构（类）？在自定义类型时，您如何选择是类还是结构？&lt;/h3&gt;
&lt;h4 id=&#34;什么是class和struct&#34;&gt;什么是class和struct&lt;/h4&gt;
&lt;p&gt;class 和struct 最本质的区别: class 是引用类型，它在堆中分配空间，栈中保存的只是引用；而struct 是值类型，它在栈中分配空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是class?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;class（类）是面向对象编程的基本概念，是一种自定义数据结构类型，通常包含字段、属性、方法、构造函数、索引器、操作符等。在.NET中，所有的类都最终继承自 System.Object 类，因此是一种引用类型，也就是说，new 一个类的实例时，在栈（stack）上存放该实例在托管堆（Managed Heap）中的地址，而实例的值保存在托管堆（Managed Heap）中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;托管堆&lt;/strong&gt;（&lt;strong&gt;Managed Heap&lt;/strong&gt;） ：&lt;strong&gt;托管堆&lt;/strong&gt;分配在被操作系统保留的一段内存区域中，这段内存区域是由 CLR 来管理的，这段内存称之为&lt;strong&gt;托管堆&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是struct?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;struct（结构）是一种值类型，用于将一组相关的变量组织为一个单一的变量实体 。所有的结构直接派生自 System.ValueType，间接派生自System.Object，但&lt;strong&gt;结构是隐式密封&lt;/strong&gt;的，不能作为基类再派生出其他的结构，也不能从类派生，但可以从接口派生。struct 实例在创建时分配在线程的栈（stack）上，它本身存储了值。所以在使用 struct 时，我们可以将其当作 int、char 这样的基本类型对待。&lt;/p&gt;
&lt;h4 id=&#34;使用区别&#34;&gt;使用区别&lt;/h4&gt;
&lt;p&gt;class是引用类型，struct是值类型；既然 class 是引用类型，class 可以设为 null；但是我们不能将 struct 设为 null，因为它是值类型。&lt;/p&gt;
&lt;p&gt;当你实例化一个 class，它将创建在&lt;strong&gt;堆&lt;/strong&gt;上。
而你实例化一个 struct，它将创建在&lt;strong&gt;栈&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;你使用的是一个对 class 实例的引用。
而你使用的不是对一个 struct 的引用（而是直接使用它们）。&lt;/p&gt;
&lt;p&gt;当我们将 class 作为参数传给一个方法，
我们传递的是一个引用。struct 传递的是值而非引用。&lt;/p&gt;
&lt;p&gt;class 可以定义析构器，但是 struct 不可以。&lt;/p&gt;
&lt;p&gt;class可以有显示的无参构造器，但是 struct不可以。&lt;/p&gt;
&lt;p&gt;class 的构造器不需要初始化全部字段。
struct 的构造器必须初始化所有字段。&lt;/p&gt;
&lt;p&gt;struct 在声明时不能对实例字段进行赋值。&lt;/p&gt;
&lt;p&gt;class使用前必须new关键字实例化(静态类除外)，struct不需要。&lt;/p&gt;
&lt;p&gt;class 支持继承和多态，struct 不支持。注意：但是 struct 可以和类一样实现接口。&lt;/p&gt;
&lt;p&gt;既然 struct 不支持继承，其成员不能以 protected 或 protected internal 修饰。&lt;/p&gt;
&lt;p&gt;class 比较适合大的和复杂的数据。
struct 适用于作为经常使用的一些数据组合成的新类型。&lt;/p&gt;
&lt;p&gt;struct 类型总是隐式密封的，因此在定义结构时不能使用 sealed 和 abstract 关键字。&lt;/p&gt;
&lt;p&gt;struct的函数成员不能声明为 abstract 和 virtual，但是可以使用 override 关键字，用以覆写它的基类 System.ValueType 中的方法。&lt;/p&gt;
&lt;h4 id=&#34;适用场合&#34;&gt;适用场合&lt;/h4&gt;
&lt;p&gt;struct 有性能优势，class 有面向对象的扩展优势.&lt;/p&gt;
&lt;p&gt;由于结构是值类型，并且直接存储数据，因此在一个对象的主要成员为数据且数据量不大的情况下，使用结构会带来更好的性能.&lt;/p&gt;
&lt;p&gt;将一个结构变量赋值给另一个结构变量，就是把数据从一个结构复制到另一个结构。而类则不同，在类的变量之间，复制的是引用，而不是类数据.&lt;/p&gt;
&lt;p&gt;当把一个结构类型的变量赋值给另一个结构时，对性能的影响取决于结构的大小，当数据比较大的时候，这种数据复制机制会带来较大的开销.&lt;/p&gt;
&lt;p&gt;对于点、矩形和颜色这样的轻量对象，假如要声明一个含有许多个颜色对象的数组，则 CLR 需要为每个对象分配内存，在此情况下，使用结构的成本较低.&lt;/p&gt;
&lt;p&gt;当堆栈的空间很有限，且有大量的逻辑对象时，创建类要比创建结构好一些.&lt;/p&gt;
&lt;p&gt;在表现抽象和多级别的对象层次时，类是最好的选择，因为结构不支持继承.&lt;/p&gt;
&lt;p&gt;用于底层数据存储的类型设计为 struct 类型，将用于定义应用程序行为的类型设计为 class。如果对类型将来的应用情况不能确定，应该使用 class.&lt;/p&gt;
&lt;h3 id=&#34;泛型的作用是什么它有什么优势它对性能有影响吗它在执行时的行为是什么net-bcl中有哪些泛型类型举例说明平时编程中您定义的泛型类型&#34;&gt;泛型的作用是什么？它有什么优势？它对性能有影响吗？它在执行时的行为是什么？.NET BCL中有哪些泛型类型？举例说明平时编程中您定义的泛型类型。&lt;/h3&gt;
&lt;h4 id=&#34;泛型的作用&#34;&gt;泛型的作用&lt;/h4&gt;
&lt;p&gt;泛型的作用在于“算法的重用”。&lt;/p&gt;
&lt;p&gt;比如，原来的ArrayList只能接受Object，现在通过List可以接受任何类型，也就是说ArrayList的方法都被各个类型重用了。但是Dot Net的泛型有个比较制肘地方，就是你很难对数值类型（值类型）进行算法抽象，因为这牵涉到运算符重载的问题，同时Dot Net的泛型的类型参数也不能约束成一个基元值类型，如int、double、float。&lt;/p&gt;
&lt;h4 id=&#34;泛型的优势&#34;&gt;泛型的优势&lt;/h4&gt;
&lt;p&gt;1.源代码保护。&lt;/p&gt;
&lt;p&gt;如果你知道C++模板对泛型的实现机制，就会知道C++在编译的时候根据对泛型的调用，自动“内联”了一个实现，这样泛型的内容就暴露了，尔DotNet的实现方式就不同了，泛型类和方法会被编译成IL，在执行的时候由JIT负责将IL变化为指定类型参数的本地代码，从而保护了源代码。&lt;/p&gt;
&lt;p&gt;2.类型安全。&lt;/p&gt;
&lt;p&gt;这点是最显而易见的，抛弃了使用ArrayList时各种丑陋的强制类型转换&lt;/p&gt;
&lt;p&gt;3.更清晰地代码。&lt;/p&gt;
&lt;p&gt;因为没有了强制类型转换，所以代码自然显得更清晰，但是使用泛型时候带来的&amp;lt;&amp;gt;有时候确实也会让人搞糊涂，幸好泛型方法可以用类型推断或者using语句来进一步简化写法。&lt;/p&gt;
&lt;p&gt;4.更好的性能。&lt;/p&gt;
&lt;p&gt;因为值类型可以避免装箱和拆箱所带来的损耗（垃圾回收的次数也会减少）。这点正是泛型神奇的地方，开发历史上抽象能力的上升往往意味着性能的下降，但是泛型却不是！泛型抽象了算法，但是C++和DotNet对泛型的实现能够让性能无损，并且更快。Java的擦除法泛型就没有这种性能上的好处。&lt;/p&gt;
&lt;h4 id=&#34;对性能的影响&#34;&gt;对性能的影响&lt;/h4&gt;
&lt;p&gt;对性能有积极的影响，因为值类型可以避免装箱和拆箱所带来的负面影响，避免了垃圾回收，使得性能显著提高。但是对引用类型这种影响就不明显了。但是需要注意的是首次为一个特定数据类型调用方法时，CLR都会为这个方法生成本地代码。这会增大应用程序的工作集大小，从而影响性能。&lt;/p&gt;
&lt;h4 id=&#34;泛型在执行时的行为是什么&#34;&gt;泛型在执行时的行为是什么&lt;/h4&gt;
&lt;p&gt;使用泛型类型参数的一个方法在进行JIT编译时，CLR获取IL，用指定的类型实参进行替换，然后创建本地代码。需要特别注意的是引用类型是共享代码的，而对值类型就会为每一种生成独立的一份类型代码。但是需要指出的是引用类型的这种代码共享并不会造成封闭类型只执行一次构造函数（包括静态构造函数）。&lt;/p&gt;
&lt;h4 id=&#34;net-bcl中有哪些泛型类型&#34;&gt;.NET BCL中有哪些泛型类型&lt;/h4&gt;
&lt;p&gt;List、Dictionary、Queue、Stack、SortedList和SortedDictionary、LinkedList等等。&lt;/p&gt;
&lt;h3 id=&#34;异常的作用是什么net-bcl中有哪些常见的异常在代码中您是如何捕获处理异常的在catch-ex中throw和throw-ex有什么区别您会如何设计异常的结构什么情况下您会抛出异常&#34;&gt;异常的作用是什么？.NET BCL中有哪些常见的异常？在代码中您是如何捕获/处理异常的？在“catch (ex)”中，“throw”和“throw ex”有什么区别？您会如何设计异常的结构，什么情况下您会抛出异常？&lt;/h3&gt;
&lt;h4 id=&#34;异常的作用是什么&#34;&gt;异常的作用是什么&lt;/h4&gt;
&lt;p&gt;异常用于处理系统级或者应用程序级的错误状态。异常处理是一种结构化的处理过程，个人认为他最大的优点就在于将“成功场景”剥离出来，使得代码更加清晰自然。但是异常处理相对于返回错误码有一个缺点，那就是他会失去发生异常的位置。不过异常本身提供了很多帮助调试问题的工具，一般都带有栈跟踪，这样位置的问题就得到一定程度的解决。还有就是IF和异常之间的选择，我记得以前有人讨论过在各种分支下是使用异常来处理各种“失败场景”的分支还是使用IF或者SWITCH来处理呢？这其实是一个假问题，因为异常和错误是有概念上的不同的，这里的错误是指有违“主成功场景”的“异常场景”，尔异常是指当程序不能完成其名字所表示功能时的错误。&lt;/p&gt;
&lt;h4 id=&#34;net-bcl中有哪些常见的异常&#34;&gt;.NET BCL中有哪些常见的异常&lt;/h4&gt;
&lt;p&gt;随便说几个，最著名的恐怕就是那句像绕口令一样的“&lt;strong&gt;未将对象引用设置到对象实例&lt;/strong&gt;”了，还有那些基本一出现整个应用程序就被判死刑的“&lt;strong&gt;堆栈溢出&lt;/strong&gt;”、“&lt;strong&gt;内存无法分配&lt;/strong&gt;”异常了&lt;/p&gt;
&lt;h4 id=&#34;在代码中您是如何捕获处理异常的&#34;&gt;在代码中您是如何捕获/处理异常的&lt;/h4&gt;
&lt;p&gt;的最多的CATCH就是抓住数据的异常，然后回滚数据库来事务处理。这是一个典型的场景，因为你明确并且能够很好的恢复状态&lt;/p&gt;
&lt;h4 id=&#34;在catch-ex中throw和throw-ex有什么区别&#34;&gt;在“catch (ex)”中，“throw”和“throw ex”有什么区别&lt;/h4&gt;
&lt;p&gt;throw 重新抛出异常但是不破坏异常发生的调用栈尔“throw ex”会重置调用栈这样捕获异常的人会以为代码出错在这里。&lt;/p&gt;
&lt;p&gt;直接使用throw ex会导致吃掉原始异常点，重置堆栈中的异常起始点&lt;/p&gt;
&lt;p&gt;推荐使用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt;{}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;catch&lt;/span&gt; (Exception ex)
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;经过进一步包装的异常&amp;#34;&lt;/span&gt;, ex);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;listt和t的区别是什么平时你如何进行选择dictionarytkey-tvalue是做什么的net-bcl中还有哪些常用的容器它们分别是如何实现的哪种数据结构分别是适用于哪些场景&#34;&gt;List&lt;!-- raw HTML omitted --&gt;和T[]的区别是什么，平时你如何进行选择？Dictionary&amp;lt;TKey, TValue&amp;gt;是做什么的？.NET BCL中还有哪些常用的容器？它们分别是如何实现的（哪种数据结构）？分别是适用于哪些场景？&lt;/h3&gt;
&lt;p&gt;List&lt;!-- raw HTML omitted --&gt;长度不固定，动态变化，支持方法较多；T[]固定大小的泛型数组。&lt;/p&gt;
&lt;p&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;是泛型字典，提供一对一的关系；&lt;/p&gt;
&lt;p&gt;.Net BCL中常用的集合有Stack&lt;!-- raw HTML omitted --&gt;、Queue&lt;!-- raw HTML omitted --&gt;、LinkedList&lt;!-- raw HTML omitted --&gt;，对应的数据结构是栈、队列和链表。&lt;/p&gt;
&lt;h3 id=&#34;抽象类和接口有什么区别使用时有什么需要注意的吗如何选择是定义一个完全抽象的抽象类还是接口什么是接口的显式实现为什么说它很重要&#34;&gt;抽象类和接口有什么区别？使用时有什么需要注意的吗？如何选择是定义一个“完全抽象”的抽象类，还是接口？什么是接口的“显式实现”？为什么说它很重要？&lt;/h3&gt;
&lt;p&gt;抽象类不能实例化。
抽象类的用途是提供多个派生类可共享的基类的公共定义。
抽象类也可以定义抽象方法。
抽象方法没有实现，所以方法定义后面是分号，而不是常规的方法块。
抽象类的派生类必须实现所有抽象方法。
抽象类只能单继承&lt;/p&gt;
&lt;p&gt;接口类似于抽象基类：实现接口的任何非抽象类型都必须实现接口的所有成员。
不能直接实例化接口。
接口可以包含事件、索引器、方法和属性。
接口不包含方法的实现。
类和结构可继承多个接口。
接口自身可从多个接口继承。&lt;/p&gt;
&lt;p&gt;相同点：都不能被实例化，都可以通过继承实现其抽象方法；&lt;/p&gt;
&lt;p&gt;不同点：接口支持多继承，抽象类不能；接口只能定义行为，抽象类既可以定义行为，还能提供实现；接口只包含方法、属性、索引器和事件的签名，不能包括自定义字段和实现方法，抽象类可以包含自定义字段和实现方法。&lt;/p&gt;
&lt;h4 id=&#34;显式地实现接口成员&#34;&gt;显式地实现接口成员&lt;/h4&gt;
&lt;p&gt;即创建一个仅通过该接口调用并且特定于该接口的类成员&lt;/p&gt;
&lt;p&gt;类成员 IControl.Paint 只能通过 IControl 接口使用， ISurface.Paint 只能通过 ISurface 使用。
两个方法实现都是分离的，都不可以直接在类中使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; IControl
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Paint();
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; ISurface
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Paint();
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;SampleClass&lt;/span&gt; : IControl, ISurface
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Paint()
    {
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;SampleClass obj = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; SampleClass();
&lt;span style=&#34;color:#228b22&#34;&gt;//obj.Paint(); // Compiler error.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
IControl c = (IControl)obj;
c.Paint(); &lt;span style=&#34;color:#228b22&#34;&gt;// Calls IControl.Paint on SampleClass.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
ISurface s = (ISurface)obj;
s.Paint(); &lt;span style=&#34;color:#228b22&#34;&gt;// Calls ISurface.Paint on SampleClass.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显式实现还用于解决两个接口分别声明具有相同名称的不同成员（如属性和方法）的情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; ILeft
{
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; P { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;;}
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; IRight
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; P();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了同时实现两个接口，类必须对属性 P 和/或方法 P 使用显式实现以避免编译器错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Middle&lt;/span&gt; : ILeft, IRight
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; P() { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ILeft.P { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt; { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; } }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;抽象类和接口的使用&#34;&gt;抽象类和接口的使用&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单的方法来控制组件版本；&lt;/li&gt;
&lt;li&gt;如果创建的功能将在大范围的全异对象间使用，则使用接口。如果要设计小而简练的功能块，则使用接口；&lt;/li&gt;
&lt;li&gt;如果要设计大的功能单元，则使用抽象类。如果要在组件的所有实现间提供通用的已实现功能，则使用抽象类；&lt;/li&gt;
&lt;li&gt;抽象类主要用于关系密切的对象；而接口适合为不相关的类提供通用功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;字符串是引用类型类型还是结构类型它和普通的引用类型相比有什么特别的地方吗使用字符串时有什么需要注意的地方为什么说stringbuilder比较高效在连接多个字符串时它无论何时都比直接相加更高效吗&#34;&gt;字符串是引用类型类型还是结构类型？它和普通的引用类型相比有什么特别的地方吗？使用字符串时有什么需要注意的地方？为什么说StringBuilder比较高效？在连接多个字符串时，它无论何时都比直接相加更高效吗？&lt;/h3&gt;
&lt;p&gt;MSDN 中明确指出 String 是引用类型而不是值类型，但 String 表面上用起来却像是值类型&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//值类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; a = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; b = a;
a = &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;;
Console.WriteLine(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;a is {0},b is {1}&amp;#34;&lt;/span&gt;, a, b);
 
&lt;span style=&#34;color:#228b22&#34;&gt;//引用类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; str1 = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;ab&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; str2 = str1;
str1 = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;;
Console.WriteLine(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;str1 is {0},str2 is {1}&amp;#34;&lt;/span&gt;, str1, str2);
Console.Read();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;//结果：
a is 2,b is 1
str1 is abc,str2 is ab
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原因：string对象是不可变的，包括长度和其中任何字符都是不可以改变的。&lt;/p&gt;
&lt;h4 id=&#34;string的不变性&#34;&gt;String的不变性&lt;/h4&gt;
&lt;p&gt;string 对象称为不可变的（只读），即字符串恒定性(Immutability)，字符串一经创建，就不可改变。有的时候看来似乎修改了，实际是string经过了特殊处理，每次改变值时都会建立一个新的string对象，变量会指向这个新的对象，而原来的还是指向原来的对象，所以不会改变。这也是string效率低下的原因。如果经常改变string的值则应该使用StringBuilder而不使用string。&lt;/p&gt;
&lt;h4 id=&#34;stringstringbuilder&#34;&gt;String、StringBuilder&lt;/h4&gt;
&lt;p&gt;当大量使用string进行拼接的时候，直接使用string+会影响效率，使用StringBuilder更为合适；&lt;/p&gt;
&lt;p&gt;在连接多个字符串时，StringBuilder并不总是比String高效，对于简单的字符串连接操作，在性能上StringBuilder不一定总是优于String，因为StringBuilder对象的创建代价比较大，在字符串连接目标较少的情况下，过度滥用StringBuilder会导致性能的浪费而非节约。只有大量的或者无法预知次数的字符串操作，才考虑以StringBuilder实现。&lt;/p&gt;
&lt;h3 id=&#34;如何高效地进行数组复制二维数组和数组的数组有什么区别在使用双重循环遍历一个二维数组时如何选择内外层的遍历顺序&#34;&gt;如何高效地进行数组复制？“二维数组”和“数组的数组”有什么区别？在使用双重循环遍历一个二维数组时，如何选择内外层的遍历顺序？&lt;/h3&gt;
&lt;h3 id=&#34;什么是元编程net有哪些元编程的手段和场景什么是反射能否举一些反射的常用场景有人说反射性能较差您怎么看待这个问题有什么办法可以提高反射的性能吗&#34;&gt;什么是元编程，.NET有哪些元编程的手段和场景？什么是反射？能否举一些反射的常用场景？有人说反射性能较差，您怎么看待这个问题？有什么办法可以提高反射的性能吗？&lt;/h3&gt;
&lt;h3 id=&#34;委托是什么匿名方法是什么在c-30中lambda表达式是什么扩展方法是什么linq是什么您觉得c-30中还有哪些重要的特性它们带来了什么优势bcl中哪些类库和这些特性有关您平时最常用哪些&#34;&gt;委托是什么？匿名方法是什么？在C# 3.0中，Lambda表达式是什么？扩展方法是什么？LINQ是什么？您觉得C# 3.0中还有哪些重要的特性，它们带来了什么优势？BCL中哪些类库和这些特性有关？您平时最常用哪些？&lt;/h3&gt;
&lt;h4 id=&#34;委托是什么&#34;&gt;委托是什么&lt;/h4&gt;
&lt;p&gt;MSND:委托是一种引用方法的类型，太抽象了这定义，看不懂&lt;/p&gt;
&lt;p&gt;我的理解是：委托就是对于一组方法的抽象，代表一组方法的共同特征。&lt;/p&gt;
&lt;h4 id=&#34;匿名方法是什么&#34;&gt;匿名方法是什么&lt;/h4&gt;
&lt;p&gt;匿名方法是指将一段代码块作为委托参数传递给另外一个方法中。&lt;/p&gt;
&lt;p&gt;匿名方法能访问方法中的变量和类中的成员。&lt;/p&gt;
&lt;p&gt;使用匿名方法，则不必创建当独的方法，因此减少了实例化委托所需的编码开销。&lt;/p&gt;
&lt;h4 id=&#34;lamdba表达式是什么&#34;&gt;lamdba表达式是什么&lt;/h4&gt;
&lt;p&gt;“Lambda 表达式”是一个匿名函数，它可以包含表达式和语句，并且可用于创建委托或表达式树类型。&lt;/p&gt;
&lt;h4 id=&#34;扩展方法是什么&#34;&gt;扩展方法是什么&lt;/h4&gt;
&lt;p&gt;扩展方法是使我们能在现有类型的基础上添加新方法，而无需创建派生类、重新编译或以其他方式修改原始类型。&lt;/p&gt;
&lt;h4 id=&#34;linq是什么&#34;&gt;LINQ是什么&lt;/h4&gt;
&lt;p&gt;语言级集成查询（Language INtegrated Query），是一组用于c#和Visual Basic语言的扩展。它允许编写C#或者Visual Basic代码以查询数据库相同的方式操作内存数据。&lt;/p&gt;
&lt;h3 id=&#34;工作之外您看哪些技术相关的书网站社区项目等等您还接触哪些net以外的技术能和net或net中有针对性的部分做个对比吗&#34;&gt;工作之外您看哪些技术相关的书、网站、社区、项目等等？您还接触哪些.NET以外的技术，能和.NET或.NET中有针对性的部分做个对比吗？&lt;/h3&gt;
&lt;h2 id=&#34;面试题&#34;&gt;面试题&lt;/h2&gt;
&lt;h3 id=&#34;concurrentdictionary-or-dictionary&#34;&gt;ConcurrentDictionary or Dictionary&lt;/h3&gt;
&lt;p&gt;ConcurrentDictionary是&lt;code&gt;System.Collections.Concurrent&lt;/code&gt;中线程安全的字典类&lt;/p&gt;
&lt;h3 id=&#34;kestrel&#34;&gt;Kestrel&lt;/h3&gt;
&lt;p&gt;Kestrel 是 ASP.NET Core 项目模板指定的默认 Web 服务器。&lt;/p&gt;
&lt;p&gt;以下部署方案中的 ASP.NET Core 支持 &lt;a href=&#34;https://httpwg.org/specs/rfc7540.html&#34;&gt;HTTP/2&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kestrel
&lt;ul&gt;
&lt;li&gt;操作系统
&lt;ul&gt;
&lt;li&gt;Windows Server 2016/Windows 10 或更高版本†&lt;/li&gt;
&lt;li&gt;具有 OpenSSL 1.0.2 或更高版本的 Linux（例如，Ubuntu 16.04 或更高版本）&lt;/li&gt;
&lt;li&gt;macOS 的未来版本将支持 HTTP/2。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目标框架：.NET Core 2.2 或更高版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTTP.sys
&lt;ul&gt;
&lt;li&gt;Windows Server 2016/Windows 10 或更高版本&lt;/li&gt;
&lt;li&gt;目标框架：不适用于 HTTP.sys 部署。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IIS（进程内）
&lt;ul&gt;
&lt;li&gt;Windows Server 2016/Windows 10 或更高版本；IIS 10 或更高版本&lt;/li&gt;
&lt;li&gt;目标框架：.NET Core 2.2 或更高版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IIS（进程外）
&lt;ul&gt;
&lt;li&gt;Windows Server 2016/Windows 10 或更高版本；IIS 10 或更高版本&lt;/li&gt;
&lt;li&gt;面向公众的边缘服务器连接使用 HTTP/2，但与 Kestrel 的反向代理连接使用 HTTP/1.1。&lt;/li&gt;
&lt;li&gt;目标框架：不适用于 IIS 进程外部署。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading&#34;&gt;&lt;/h4&gt;
- https://www.openheart.icu/cs/dot-net-interview/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>About</title>
        <link>https://www.openheart.icu/about/</link>
        <pubDate>Fri, 17 Jul 2020 22:57:45 +0800</pubDate>
        
        <guid>https://www.openheart.icu/about/</guid>
        <description>42th openheart https://www.openheart.icu/about/ -&lt;h2 id=&#34;关于我&#34;&gt;关于我&lt;/h2&gt;
&lt;p&gt;I am Kris Nie.&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&#34;https://github.com/Hyominn&#34;&gt;@Hyominn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Ins: &lt;a href=&#34;https://www.instagram.com/krisnie42/&#34;&gt;@krisnie42&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Twitter: &lt;a href=&#34;https://twitter.com/hehe54213&#34;&gt;@hehe54213&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;关于本站&lt;/h2&gt;
&lt;p&gt;This is my Hugo blog :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;42th openheart.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用来记录我的第42次不开心&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── Gossip			#谨言慎行
├── ComputerScience		#计算机科学
├── Arithmetic			#算法
├── About			#关于
├── Category			#归类
└── Tags			#标签
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;Thanks for theme makers:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Hugo Theme &lt;a href=&#34;https://github.com/amazingrise/hugo-theme-diary&#34;&gt;Diary&lt;/a&gt; by &lt;a href=&#34;https://amazingrise.net/&#34;&gt;Rise&lt;/a&gt; Ported from &lt;a href=&#34;https://mak1t0.cc/&#34;&gt;Makito&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;https://github.com/SumiMakito/hexo-theme-journal/&#34;&gt;Journal.&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
- https://www.openheart.icu/about/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>206. Reverse Linked List</title>
        <link>https://www.openheart.icu/arithmetic/206.-reverse-linked-list/</link>
        <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/arithmetic/206.-reverse-linked-list/</guid>
        <description>42th openheart https://www.openheart.icu/arithmetic/206.-reverse-linked-list/ -&lt;h1 id=&#34;reverse-a-singly-linked-listhttpsleetcode-cncomproblemsreverse-linked-list&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/reverse-linked-list&#34;&gt;Reverse a singly linked list.&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Follow up:&lt;/p&gt;
&lt;p&gt;A linked list can be reversed either iteratively or recursively. Could you implement both?&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;迭代&#34;&gt;迭代&lt;/h2&gt;
&lt;p&gt;将&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转化为&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NULL&amp;lt;-1&amp;lt;-2&amp;lt;-3&amp;lt;-4&amp;lt;-5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用一个prev节点存储上一个节点（初始为NULL），将当前curr节点的next指向prev节点，prev节点存储curr节点，curr存储curr的原next节点，完成一次迭代。最后返回prev（最后的curr是原ListNode的NULL）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * Definition for singly-linked list.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * public class ListNode {
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *     int val;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *     ListNode next;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *     ListNode(int x) { val = x; }
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * }
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; ListNode &lt;span style=&#34;color:#008b45&#34;&gt;reverseList&lt;/span&gt;(ListNode head) {
    ListNode prev = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
    ListNode curr = head;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (curr != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
        ListNode nextTemp = curr.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt;;
        curr.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; = prev;
        prev = curr;
        curr = nextTemp;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; prev;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;时间复杂度分析&#34;&gt;时间复杂度分析&lt;/h3&gt;
&lt;p&gt;时间复杂度：&lt;em&gt;O&lt;/em&gt;(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：&lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
&lt;h2 id=&#34;递归&#34;&gt;递归&lt;/h2&gt;
&lt;p&gt;将
$$
n_1→&amp;hellip;→n_{k−1}→n_k→n_{k+1}→&amp;hellip;→n_m→∅
$$
转化为
$$
n_1→&amp;hellip;→n_{k−1}→n_k→n_{k+1}←&amp;hellip;←n_m
$$
先转化原链表最后一个节点，然后依次转化直到n&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; ListNode &lt;span style=&#34;color:#008b45&#34;&gt;reverseList&lt;/span&gt;(ListNode head) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (head == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt; || head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; head;
    ListNode p = reverseList(head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt;);
    head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; = head;
    head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; p;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;时间复杂度分析-1&#34;&gt;时间复杂度分析&lt;/h3&gt;
&lt;p&gt;时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。&lt;/p&gt;
&lt;p&gt;空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。&lt;/p&gt;
- https://www.openheart.icu/arithmetic/206.-reverse-linked-list/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Computer network</title>
        <link>https://www.openheart.icu/cs/computer-network/</link>
        <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/computer-network/</guid>
        <description>42th openheart https://www.openheart.icu/cs/computer-network/ -&lt;h1 id=&#34;网络的七层架构&#34;&gt;网络的七层架构&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;物理层&lt;/li&gt;
&lt;li&gt;数据链路层&lt;/li&gt;
&lt;li&gt;网络层&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;会话层&lt;/li&gt;
&lt;li&gt;表示层&lt;/li&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;tcpip-原理&#34;&gt;TCP/IP 原理&lt;/h2&gt;
&lt;h2 id=&#34;tcp-三次握手四次挥手&#34;&gt;TCP 三次握手/四次挥手&lt;/h2&gt;
&lt;h3 id=&#34;三次握手&#34;&gt;三次握手&lt;/h3&gt;
&lt;p&gt;TCP 在传输之前会进行三次沟通，一般称为“三次握手”。&lt;/p&gt;
&lt;h3 id=&#34;四次挥手&#34;&gt;四次挥手&lt;/h3&gt;
&lt;p&gt;TCP在传输完数据断开的时候要进行四次沟通，一般称为“四次挥手”。&lt;/p&gt;
- https://www.openheart.icu/cs/computer-network/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Git</title>
        <link>https://www.openheart.icu/cs/git/</link>
        <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/git/</guid>
        <description>42th openheart https://www.openheart.icu/cs/git/ -&lt;h2 id=&#34;idea设置git&#34;&gt;idea设置git&lt;/h2&gt;
&lt;p&gt;idea -&amp;gt;VSC -&amp;gt;Create Git Repository
右击工程文件 -&amp;gt;git-&amp;gt;add
右击工程文件 -&amp;gt;git-&amp;gt;commit&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;git remote add origin git@github.com:Hyominn/java_demo.git
git pull git@github.com:Hyominn/java_demo.git
git add .
dir                                                &lt;span style=&#34;color:#228b22&#34;&gt;# 查看有哪些文件夹&lt;/span&gt;
git rm -r --cached target   &lt;span style=&#34;color:#228b22&#34;&gt;# 删除target文件夹&lt;/span&gt;
git commit –m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;版本更新信息&amp;#34;&lt;/span&gt;
git push git@github.com:Hyominn/java_demo.git   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;设置git代理&#34;&gt;设置git代理&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;git config --global https.proxy http://127.0.0.1:1080
git config --global https.proxy https://127.0.0.1:1080

git config --global http.proxy &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;socks5://127.0.0.1:1080&amp;#39;&lt;/span&gt;
git config --global https.proxy &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;socks5://127.0.0.1:1080&amp;#39;&lt;/span&gt;

git config --global --unset http.proxy
git config --global --unset https.proxy

npm config delete proxy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;遇到pull不下来&#34;&gt;遇到pull不下来&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;git reset --hard FETCH_HEAD
git clone  https://www.github.com/Hyominn/openheart.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;更改用户名邮箱&#34;&gt;更改用户名邮箱&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;git config --global user.name &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Kris Nie&amp;#34;&lt;/span&gt;
git config --global user.email krisnie@qq.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;查看git安装路径&#34;&gt;查看git安装路径&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Mac: &lt;code&gt;which git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Windows: &lt;code&gt;where git&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading&#34;&gt;&lt;/h2&gt;
- https://www.openheart.icu/cs/git/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
  </channel>
</rss> 