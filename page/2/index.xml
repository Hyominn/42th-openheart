<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>42th openheart</title>
    <link>https://www.openheart.icu/</link>
    <description>Recent content on 42th openheart</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>ALL RIGHTS RESERVED KRIS NIE</copyright>
    <lastBuildDate>Sat, 14 Nov 2020 16:55:11 +0000</lastBuildDate>
    
        <atom:link href="https://www.openheart.icu/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Interesting</title>
        <link>https://www.openheart.icu/cs/interesting/</link>
        <pubDate>Wed, 22 Jul 2020 19:45:28 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/interesting/</guid>
        <description>42th openheart https://www.openheart.icu/cs/interesting/ -&lt;h3 id=&#34;texturesjshttpsriccardoscalcoittextures&#34;&gt;&lt;a href=&#34;https://riccardoscalco.it/textures/&#34;&gt;Textures.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 JS 纹理库，基于 D3.js&lt;/p&gt;
&lt;h3 id=&#34;elevatorjshttpsgithubcomtholmanelevatorjs&#34;&gt;&lt;a href=&#34;https://github.com/tholman/elevator.js&#34;&gt;elevator.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Finally, a &amp;ldquo;back to top&amp;rdquo; button that behaves like a real elevator, by adding elevator music to quietly soothe the awkwardness that can ensue when being smoothly scrolled to the top of the screen.&lt;/p&gt;
&lt;p&gt;This is very serious stuff, &lt;a href=&#34;http://tholman.com/elevator.js&#34;&gt;here&amp;rsquo;s a demo&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;一个使得“回到顶部”的网页滚动，具有电梯效果的 JS 库。&lt;/p&gt;
&lt;h3 id=&#34;mownedhttpsmownedcom&#34;&gt;&lt;a href=&#34;https://mowned.com/&#34;&gt;Mowned&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个手机数据库&lt;/p&gt;
&lt;h3 id=&#34;javascript-生成艺术图形教程httpsgenerativeartistrycomtutorials&#34;&gt;&lt;a href=&#34;https://generativeartistry.com/tutorials/&#34;&gt;JavaScript 生成艺术图形教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;介绍 如何使用JavaScript 生成8种艺术图形。&lt;/p&gt;
&lt;h3 id=&#34;使用-raspberry-pi-学习操作系统开发httpss-matyukevichgithubioraspberry-pi-os&#34;&gt;&lt;a href=&#34;https://s-matyukevich.github.io/raspberry-pi-os/&#34;&gt;使用 Raspberry Pi 学习操作系统开发&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这是一个免费英文教程，教大家怎么用树莓派，一步步开发一个简单的操作系统内核，每一步都有实例代码&lt;/p&gt;
&lt;h3 id=&#34;vim-的由来httpspragmaticpineapplecomhow-did-vim-become-so-popular&#34;&gt;&lt;a href=&#34;https://pragmaticpineapple.com/how-did-vim-become-so-popular/&#34;&gt;Vim 的由来&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Vim 有30多年历史，目前依然是最流行的编辑器之一。本文简要地回顾了历史，它的一些主要的设计决定，到底是怎么来的&lt;/p&gt;
&lt;h3 id=&#34;makefile-的静态网站实现httpsmetinnextcorgpoststhe_idea_of_makefile_bloghtml&#34;&gt;&lt;a href=&#34;https://metin.nextc.org/posts/The_Idea_Of_Makefile_Blog.html&#34;&gt;Makefile 的静态网站实现&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;现在有各种各样的静态网站工具，比如 Jekyll 和 Hugo 等。作者提出，Makefile 也可以用来实现静态网站，这样就不需要任何外部工具了，只维护一个 Makefile 配置文件即可&lt;/p&gt;
&lt;h3 id=&#34;字体反爬的攻与防httpscjtingme20200701douyu-crawler-and-font-anti-crawling&#34;&gt;&lt;a href=&#34;https://cjting.me/2020/07/01/douyu-crawler-and-font-anti-crawling/&#34;&gt;字体反爬的攻与防&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者因为业务原因需要爬取一批斗鱼主播的相关数据，结果发现斗鱼使用了一种很有意思的反爬技术：字体反爬&lt;/p&gt;
&lt;h3 id=&#34;分页查询不要使用-offset-和-limit-语法httpshackernooncomplease-dont-use-offset-and-limit-for-your-pagination-8ux3u4y&#34;&gt;&lt;a href=&#34;https://hackernoon.com/please-dont-use-offset-and-limit-for-your-pagination-8ux3u4y&#34;&gt;分页查询不要使用 OFFSET 和 LIMIT 语法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;数据查询时，如果数据多，就需要分页，一般使用 OFFSET 和 LIMIT 语法。这篇文章提出，这样做不好，耗费资源，有性能问题&lt;/p&gt;
&lt;h3 id=&#34;git-多行提交信息的简单方法httpswwwstefanjudiscomtoday-i-learnedgit-commit-accepts-several-message-flags-m-to-allow-multiline-commits&#34;&gt;&lt;a href=&#34;https://www.stefanjudis.com/today-i-learned/git-commit-accepts-several-message-flags-m-to-allow-multiline-commits/&#34;&gt;Git 多行提交信息的简单方法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt;命令的&lt;code&gt;-m&lt;/code&gt;参数用来指定提交信息，但是这样提交的信息只有一行。本文介绍实现多行信息的简单方法&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;git co -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;commit title&amp;#34;&lt;/span&gt; -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;commit description&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;盲文的由来httpsstitcherioblogbraille-and-the-history-of-software&#34;&gt;&lt;a href=&#34;https://stitcher.io/blog/braille-and-the-history-of-software&#34;&gt;盲文的由来&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如题&lt;/p&gt;
&lt;h3 id=&#34;漫长的雨httpwwwsamwellernetbradbury-120181129the-essential-bradbury&#34;&gt;&lt;a href=&#34;http://www.samweller.net/bradbury-1/2018/11/29/the-essential-bradbury&#34;&gt;漫长的雨&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;《漫长的雨》（The long rain，&lt;strong&gt;&lt;a href=&#34;https://www.sohu.com/a/337866552_771944&#34;&gt;中译全文&lt;/a&gt;&lt;/strong&gt;）是美国科幻小说作家雷·布拉德伯里（Ray Bradbury）1950年发表的一篇短篇小说。&lt;/p&gt;
&lt;p&gt;它讲述四个宇航员因为火箭失事，来到一个不停下雨的星球。这个星球永远在下瓢泼大雨，过去10年一秒都没有停过。宇航员冒着雨水，在丛林里面穿行，拼命寻找前人修建的“阳光穹顶”，那里是一个大屋顶，有温暖的人造阳光，以及充足的食物和休息的场所。&lt;/p&gt;
&lt;p&gt;小说的开头是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;大雨，永远的雨，升腾着汗水和蒸汽的雨。这是密集的瓢泼大雨，像鞭子一样打在眼睛上，飞溅到脚踝上。它是一场淹没其他所有雨水的雨，让人遗忘所有关于雨水的记忆。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6个最常见的网页可访问性问题httpsblogscottlogiccom202007026-most-common-accessibility-problemshtmlempty-links-and-empty-buttons&#34;&gt;&lt;a href=&#34;https://blog.scottlogic.com/2020/07/02/6-most-common-accessibility-problems.html#empty-links-and-empty-buttons&#34;&gt;6个最常见的网页可访问性问题&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可访问性（accessibility）指的是，网页对生理缺陷的用户是否友好。本文总结了6个最常见的可访问性问题及其解决方法&lt;/p&gt;
&lt;h3 id=&#34;伪随机数生成器httpsgithubcombryccodeblobmasterjshashprngsmd&#34;&gt;&lt;a href=&#34;https://github.com/bryc/code/blob/master/jshash/PRNGs.md&#34;&gt;伪随机数生成器&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;伪随机数指的是通过一种算法，由种子值得到的随机数。本文介绍了几种简单的伪随机数算法&lt;/p&gt;
&lt;h3 id=&#34;75行代码入门-webglhttpsavikdascom20200708barebones-webgl-in-75-lines-of-codehtml&#34;&gt;&lt;a href=&#34;https://avikdas.com/2020/07/08/barebones-webgl-in-75-lines-of-code.html&#34;&gt;75行代码入门 WebGL&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WebGL 是浏览器对 OpenGL API 的调用接口，可以在浏览器里面实现 3D 动画。本文用一个简短的例子，介绍了这个 API。这只是一篇简介，另有&lt;a href=&#34;https://www.toptal.com/javascript/3d-graphics-a-webgl-tutorial&#34;&gt;完整的 WebGL 教程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;redisearchhttpsossredislabscomredisearch&#34;&gt;&lt;a href=&#34;https://oss.redislabs.com/redisearch/&#34;&gt;RediSearch&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;以 Redis 作为后端的全文搜索引擎，支持中文&lt;/p&gt;
&lt;h3 id=&#34;onelook-thesaurushttpswwwonelookcomthesaurus&#34;&gt;&lt;a href=&#34;https://www.onelook.com/thesaurus/&#34;&gt;OneLook Thesaurus&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;英语的同义词词典，可以查询同义词，也可以根据描述返回对应的词（比如 &lt;a href=&#34;https://www.onelook.com/thesaurus/?s=large%20birds&amp;amp;loc=revfp&#34;&gt;large bird&lt;/a&gt; 对应哪些词），加载速度很快&lt;/p&gt;
&lt;h3 id=&#34;crdttechhttpscrdttech&#34;&gt;&lt;a href=&#34;https://crdt.tech/&#34;&gt;CRDT.tech&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;CRDT 是一种数据结构，用于分布式网络的数据同步，最典型的例子就是多人同时编辑文档。该网站收集了 CRDT 的相关资料&lt;/p&gt;
&lt;h3 id=&#34;progressive-app-storehttpsprogressiveappstorehome&#34;&gt;&lt;a href=&#34;https://progressiveapp.store/home&#34;&gt;Progressive App Store&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个渐进式 App 的在线商店，收集各种 Progessive App，是网友搭建的&lt;/p&gt;
&lt;h3 id=&#34;网页设计博物馆httpswwwwebdesignmuseumorg&#34;&gt;&lt;a href=&#34;https://www.webdesignmuseum.org/&#34;&gt;网页设计博物馆&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站收集了1600多个经过精心挑选和分类的网页，展示了1991年至2006年之间的网站设计趋势&lt;/p&gt;
&lt;h3 id=&#34;窗口交换httpswindow-swapcom&#34;&gt;&lt;a href=&#34;https://window-swap.com/&#34;&gt;窗口交换&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站让世界各地的人上传他们窗外的镜像，一段5到10分钟的视频。其他用户就可以在网站上随机看到别人的窗外&lt;/p&gt;
&lt;h3 id=&#34;cnetcomhttpswwwcnetcompicturesinside-the-kansas-survival-condo-designed-to-save-you-from-nuclear-winter&#34;&gt;&lt;a href=&#34;https://www.cnet.com/pictures/inside-the-kansas-survival-condo-designed-to-save-you-from-nuclear-winter/&#34;&gt;cnet.com&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;幸存者公寓&lt;/p&gt;
&lt;h3 id=&#34;平流层飞船httpswwwgeekwirecom2020space-perspective-reboots-vision-flying-passengers-stratosphere-balloon&#34;&gt;&lt;a href=&#34;https://www.geekwire.com/2020/space-perspective-reboots-vision-flying-passengers-stratosphere-balloon/&#34;&gt;平流层飞船&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;美国一家私人公司提出了“平流层飞船”计划，让游客乘坐飞船上升到平流层（距离地面30公里），体验一下太空的感觉，票价预计为每人12.5万美元。飞船可以乘坐八名乘客和一名飞行员，先进行长达两个小时的上升，然后在空中停留两个小时，最后再花两个小时下降。&lt;/p&gt;
&lt;p&gt;飞船的上升动力，主要来自一个巨大的充满氢气的气球。飞船内部有酒吧，还有一个“拥有世界上最佳视野”的厕所，甚至有 Wifi。该公司计划飞船在2024年完工，目前已经在&lt;a href=&#34;https://thespaceperspective.com/fly/&#34;&gt;官网&lt;/a&gt;接受预订。&lt;/p&gt;
&lt;h3 id=&#34;sha-256-的原理httpsqvaultio20200708how-sha-2-works-step-by-step-sha-256&#34;&gt;&lt;a href=&#34;https://qvault.io/2020/07/08/how-sha-2-works-step-by-step-sha-256/&#34;&gt;SHA-256 的原理&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文通过一个简单的例子，一步步演示 SHA-256 算法，如何将字符串变成一个256位的哈希值。&lt;/p&gt;
&lt;h3 id=&#34;javascript-函数作用域解释httpsbloggreenrootsinfojavascript-scope-fundamentals-with-tom-and-jerry-ckcq723h4007vkxs18dxa97ae&#34;&gt;&lt;a href=&#34;https://blog.greenroots.info/javascript-scope-fundamentals-with-tom-and-jerry-ckcq723h4007vkxs18dxa97ae&#34;&gt;JavaScript 函数作用域解释&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;通过一个简单的例子，解释 JavaScript 的函数作用域规则&lt;/p&gt;
&lt;h3 id=&#34;gpt-3-模型的图灵测试httplackerioai20200706giving-gpt-3-a-turing-testhtml&#34;&gt;&lt;a href=&#34;http://lacker.io/ai/2020/07/06/giving-gpt-3-a-turing-test.html&#34;&gt;GPT-3 模型的图灵测试&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;GPT-3 是 OpenAI 公司开发的一个 AI 模型，能够自动生成文本。作者对它进行了图灵测试，跟它对话，看能不能分辨出对方是一个软件。&lt;/p&gt;
&lt;h3 id=&#34;pastemecnhttpspastemecn&#34;&gt;&lt;a href=&#34;https://pasteme.cn/&#34;&gt;PasteMe.cn&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个文本分享网站，不需要注册，会对输入的文本或代码生成 URL，支持密码和阅后即焚&lt;/p&gt;
&lt;h3 id=&#34;shoelacehttpsshoelacestyle&#34;&gt;&lt;a href=&#34;https://shoelace.style/&#34;&gt;Shoelace&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 Web Components 组件库，易用&lt;/p&gt;
&lt;h3 id=&#34;3d-封面生成器https3d-book-cssnetlifyapp&#34;&gt;&lt;a href=&#34;https://3d-book-css.netlify.app/&#34;&gt;3D 封面生成器&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在线工具，让一张平面图片变成 3D 书籍封面。&lt;/p&gt;
&lt;h3 id=&#34;easy-monitorhttpsgithubcomhyj1991easy-monitor&#34;&gt;&lt;a href=&#34;https://github.com/hyj1991/easy-monitor&#34;&gt;easy-monitor&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Node.js 应用的性能监控工具，可以定位线上故障。代码开源，支持私有部署&lt;/p&gt;
&lt;h3 id=&#34;remark42httpsgithubcomumputunremark42&#34;&gt;&lt;a href=&#34;https://github.com/umputun/remark42&#34;&gt;remark42&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;开源的评论服务，可以用来为静态网页加上留言功能。&lt;/p&gt;
&lt;h3 id=&#34;wikijshttpswikijsorg&#34;&gt;&lt;a href=&#34;https://wiki.js.org/&#34;&gt;Wiki.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;架设个人 Wiki 的 Node.js 应用。&lt;/p&gt;
&lt;h3 id=&#34;rust-语言之旅httpstourofrustcom00_zh-cnhtml&#34;&gt;&lt;a href=&#34;https://tourofrust.com/00_zh-cn.html&#34;&gt;Rust 语言之旅&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Rust 语言的中文版在线教程，通过可以运行的小例子介绍语法，从 Hello World 开始讲起&lt;/p&gt;
&lt;h3 id=&#34;木星相册httpswwwflickrcomphotoskevinmgillalbums72157709069900506&#34;&gt;&lt;a href=&#34;https://www.flickr.com/photos/kevinmgill/albums/72157709069900506&#34;&gt;木星相册&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个天文爱好者收集的木星照片。&lt;/p&gt;
&lt;h3 id=&#34;麻省理工学院的统计学课件httpsocwmiteducoursesmathematics18-650-statistics-for-applications-fall-2016lecture-slides&#34;&gt;&lt;a href=&#34;https://ocw.mit.edu/courses/mathematics/18-650-statistics-for-applications-fall-2016/lecture-slides/&#34;&gt;麻省理工学院的统计学课件&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;麻省理工学院本科生统计学课程的 PPT 课件&lt;/p&gt;
&lt;h3 id=&#34;没有博士学位者的-tensorflow-和深度学习教程httpscodelabsdevelopersgooglecomcodelabscloud-tensorflow-mnist&#34;&gt;&lt;a href=&#34;https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/&#34;&gt;没有博士学位者的 TensorFlow 和深度学习教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;谷歌发布的英文教程，没有高深的数学，向初学者介绍 TensorFlow 和深度学习。&lt;/p&gt;
&lt;h3 id=&#34;javascript-的第三纪元httpswwwswyxiowritingjs-third-age&#34;&gt;&lt;a href=&#34;https://www.swyx.io/writing/js-third-age/&#34;&gt;JavaScript 的第三纪元&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者认为，JavaScript 的发展可以分成三个阶段：原始阶段、Node.js 阶段和目前的超越阶段。&lt;/p&gt;
&lt;p&gt;当前阶段的主要特征是，JavaScript 开始作为底层技术，ES6 模块、TypeScript、WebAssembly 逐渐普及&lt;/p&gt;
&lt;h3 id=&#34;如何构建优秀的-apihttpswwwstxnextcombloghow-to-build-a-good-api-that-wont-embarrass-you&#34;&gt;&lt;a href=&#34;https://www.stxnext.com/blog/how-to-build-a-good-api-that-wont-embarrass-you&#34;&gt;如何构建优秀的 API&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文介绍设计一个优秀的 RESTful API 的注意事项，以及 REST 和 GraphQL 两种 API 的差异&lt;/p&gt;
&lt;h3 id=&#34;python-的-sqlite-数据库教程httpstowardsdatasciencecomdo-you-know-python-has-a-built-in-database-d553989c87bd&#34;&gt;&lt;a href=&#34;https://towardsdatascience.com/do-you-know-python-has-a-built-in-database-d553989c87bd&#34;&gt;Python 的 SQLite 数据库教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文是入门教程，介绍如何在 Python 语言使用内置的 SQLite 数据库，不需要任何安装步骤&lt;/p&gt;
&lt;h3 id=&#34;10个有用的-git-log-技巧httpshackernooncomten-useful-git-log-tricks-7nt3yxy&#34;&gt;&lt;a href=&#34;https://hackernoon.com/ten-useful-git-log-tricks-7nt3yxy&#34;&gt;10个有用的 git log 技巧&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文介绍&lt;code&gt;git log&lt;/code&gt;命令的10个参数用法&lt;/p&gt;
&lt;h3 id=&#34;async-函数的一个注意点httpswwwbrandonsmithninjablogasync-await&#34;&gt;&lt;a href=&#34;https://www.brandonsmith.ninja/blog/async-await&#34;&gt;async 函数的一个注意点&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文提醒大家注意，使用 JavaScript 的 async/await 函数时，要区分并发操作和继发操作&lt;/p&gt;
&lt;h3 id=&#34;react-spectrumhttpsreact-spectrumadobecomreact-spectrumindexhtml&#34;&gt;&lt;a href=&#34;https://react-spectrum.adobe.com/react-spectrum/index.html&#34;&gt;React Spectrum&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Adobe 公司的 React 组件库&lt;/p&gt;
&lt;h3 id=&#34;css-sweeperhttpsgithubcompropjockeycss-sweeper&#34;&gt;&lt;a href=&#34;https://github.com/propjockey/css-sweeper&#34;&gt;css-sweeper&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个只用 HTML 和 CSS 实现的扫雷游戏，不使用 JavaScript&lt;/p&gt;
&lt;h3 id=&#34;react-tablehttpsgithubcomtannerlinsleyreact-table&#34;&gt;&lt;a href=&#34;https://github.com/tannerlinsley/react-table&#34;&gt;react-table&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;React 的表格组件库，新的 7.0 版完全采用 Hooks 设计&lt;/p&gt;
&lt;h3 id=&#34;数据可视化图表目录httpsdatavizcataloguecomzh&#34;&gt;&lt;a href=&#34;https://datavizcatalogue.com/ZH/&#34;&gt;数据可视化图表目录&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个网站收集各种数据可视化的图表类型，简要讲解每种类型的用途和特点&lt;/p&gt;
&lt;h3 id=&#34;拥抱扩展扑灭httpsenwikipediaorgwikiembrace_extend_and_extinguish&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Embrace,_extend,_and_extinguish&#34;&gt;拥抱，扩展，扑灭&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;1996年，美国司法部发现，微软公司内部使用“拥抱，扩展，扑灭”（Embrace, extend, and extinguish，简称 EEE ）这个短语，描述对付竞争对手的策略。&lt;/p&gt;
&lt;p&gt;首先，拥抱对方的产品种类，进入对方的市场；然后，使用自己的专有功能扩展产品标准；最后，利用这些差异，使竞争对手处于不利地位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;拥抱阶段&lt;/strong&gt; ：开发与竞争产品基本兼容的软件，或实施公共标准。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展阶段&lt;/strong&gt;：添加和推广竞争对手或标准不支持的功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扑灭阶段&lt;/strong&gt;：由于市场份额的扩展，添加的功能成为事实上的标准时，再将竞争对手边缘化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;微软的 IE 浏览器就是使用这种策略的最好例子。&lt;/p&gt;
&lt;p&gt;现在有人认为，微软对于开源软件的态度，从敌对变成拥抱，也有可能是在实施这种策略。另一方面，谷歌公司在很多技术领域的作为，也让人疑虑，它在实施这种策略。&lt;/p&gt;
&lt;h3 id=&#34;javascript-语言的多态httpszellwkcomblogpolymorphism-javascript&#34;&gt;&lt;a href=&#34;https://zellwk.com/blog/polymorphism-javascript/&#34;&gt;JavaScript 语言的多态&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;多态（Polymorph）是面向对象编程的一个术语，有多种含义。本文讨论 JavaScript 语言如何实现多态&lt;/p&gt;
&lt;h3 id=&#34;github-actions-的-go-语言示例httpswwwfreecodecamporgnewsgo-automate-your-github-profile-readme&#34;&gt;&lt;a href=&#34;https://www.freecodecamp.org/news/go-automate-your-github-profile-readme/&#34;&gt;GitHub Actions 的 Go 语言示例&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文介绍如何在 GitHub 仓库里面定时跑 Go 语言脚本，再将代码推送回仓库&lt;/p&gt;
&lt;h3 id=&#34;javascript-测试框架比较httpsgithubcomscraggocomparing-javascript-test-runnersblobmasterreadmemd&#34;&gt;&lt;a href=&#34;https://github.com/scraggo/comparing-javascript-test-runners/blob/master/README.md&#34;&gt;JavaScript 测试框架比较&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Mocha、Ava、Jest 是目前非常流行的三大 JavaScript 测试框架，本文对它们进行了比较，每个框架最合适的运行场景&lt;/p&gt;
&lt;h3 id=&#34;git-工作流程的图示httpszepelioblog5-git-workflows-to-improve-development&#34;&gt;&lt;a href=&#34;https://zepel.io/blog/5-git-workflows-to-improve-development/&#34;&gt;Git 工作流程的图示&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文用清晰的图形解释了五种 Git 工作流程&lt;/p&gt;
&lt;h3 id=&#34;tailwind-css从业余项目到数百万美元的业务httpsadamwathanmetailwindcss-from-side-project-byproduct-to-multi-mullion-dollar-business&#34;&gt;&lt;a href=&#34;https://adamwathan.me/tailwindcss-from-side-project-byproduct-to-multi-mullion-dollar-business/&#34;&gt;Tailwind CSS：从业余项目到数百万美元的业务&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Tailwind CSS 的作者介绍这个框架的诞生过程，以及他们如何通过它赚到几百万美元。&lt;/p&gt;
&lt;h3 id=&#34;windows-10-阻止修改-hosts-文件httpswwwbleepingcomputercomnewsmicrosoftwindows-10-hosts-file-blocking-telemetry-is-now-flagged-as-a-risk&#34;&gt;&lt;a href=&#34;https://www.bleepingcomputer.com/news/microsoft/windows-10-hosts-file-blocking-telemetry-is-now-flagged-as-a-risk/&#34;&gt;Windows 10 阻止修改 HOSTS 文件&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;HOSTS 文件用于修改网站域名对应的 IP 地址，WIndows 10 内置的 Windows Defender 软件最近开始警告和阻止修改这个文件。&lt;/p&gt;
&lt;h3 id=&#34;我用-gpt-3-写了一篇博客文章httpsliampsubstackcompmy-gpt-3-blog-got-26-thousand-visitors&#34;&gt;&lt;a href=&#34;https://liamp.substack.com/p/my-gpt-3-blog-got-26-thousand-visitors&#34;&gt;我用 GPT-3 写了一篇博客文章&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;GPT-3 是目前最先进的人工智能模型，可以根据输入，返回一篇人类可读的文章。&lt;/p&gt;
&lt;p&gt;作者输入文章的标题和简介，GPT-3 就自动返回了一篇博客文章，这篇文章还登上了 Hacker News 的第一名，许多人都没有发现这是计算机写的。&lt;/p&gt;
&lt;h3 id=&#34;随机数据生成器httpsrandom-data-apicom&#34;&gt;&lt;a href=&#34;https://random-data-api.com/&#34;&gt;随机数据生成器&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个网站提供一个 API，可以让你定制想要的随机数据，以 JSON 格式返回。&lt;/p&gt;
&lt;h3 id=&#34;compiler-explorerhttpsgodboltorg&#34;&gt;&lt;a href=&#34;https://godbolt.org/&#34;&gt;Compiler Explorer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个在线的编译器学习工具，可以显示高级语言对应的汇编代码，支持多种语言。&lt;/p&gt;
&lt;h3 id=&#34;yandex-图片搜索httpsyandexcomimages&#34;&gt;&lt;a href=&#34;https://yandex.com/images/&#34;&gt;Yandex 图片搜索&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;俄罗斯的搜索引擎 Yandex&lt;/p&gt;
&lt;h3 id=&#34;nightcafehttpscreatornightcafestudio&#34;&gt;&lt;a href=&#34;https://creator.nightcafe.studio/&#34;&gt;NightCafe&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个图片处理的在线工具，可以让普通照片变成世界名画&lt;/p&gt;
&lt;h3 id=&#34;js-1024-竞赛httpsjs1024funresults2020&#34;&gt;&lt;a href=&#34;https://js1024.fun/results/2020&#34;&gt;JS 1024 竞赛&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这是代码长度不超过1024字节的 JS 程序的比赛，2020年的结果已经公布了。第一名是一个&lt;a href=&#34;https://js1024.fun/demos/2020/16&#34;&gt;钢琴键盘&lt;/a&gt;，第二名和第三名是动画渲染，第四名是一个游戏。&lt;/p&gt;
&lt;h3 id=&#34;stackoverflow-top-cpphttpsgithubcomethsonliustackoverflow-top-cpptreemasterquestion&#34;&gt;&lt;a href=&#34;https://github.com/EthsonLiu/stackoverflow-top-cpp/tree/master/question&#34;&gt;stackoverflow-top-cpp&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;StackOverflow 上面高票排名的 C/C++ 问题的中文翻译&lt;/p&gt;
&lt;h3 id=&#34;gitenberghttpswwwgitenbergorg&#34;&gt;&lt;a href=&#34;https://www.gitenberg.org/&#34;&gt;Gitenberg&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个公共领域的英文电子书的搜索引擎。&lt;/p&gt;
&lt;h3 id=&#34;svg-repohttpswwwsvgrepocom&#34;&gt;&lt;a href=&#34;https://www.svgrepo.com/&#34;&gt;SVG Repo&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 SVG 图片（主要是图标）的搜索引擎。&lt;/p&gt;
&lt;h3 id=&#34;motherboard-dbhttpsmotherboarddbcom&#34;&gt;&lt;a href=&#34;https://motherboarddb.com/&#34;&gt;Motherboard DB&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;电脑主板的数据库&lt;/p&gt;
&lt;h3 id=&#34;kindle-的诞生httpsthreadreaderappcomthread1287944667414196225html&#34;&gt;&lt;a href=&#34;https://threadreaderapp.com/thread/1287944667414196225.html&#34;&gt;Kindle 的诞生&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如题&lt;/p&gt;
&lt;h3 id=&#34;我参加-pixar-2020-渲染大赛的作品httpsblogyiningkarllicom202007shipshape-renderman-challengehtml&#34;&gt;&lt;a href=&#34;https://blog.yiningkarlli.com/2020/07/shipshape-renderman-challenge.html&#34;&gt;我参加 Pixar 2020 渲染大赛的作品&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Pixar 动画公司每年举办一个比赛，提供一些数字模型，邀请全世界爱好者对它们进行渲染着色，评选出优胜者。作者介绍了他如何创作第一名作品&lt;/p&gt;
&lt;h3 id=&#34;如何自己实现一个全文搜索引擎httpsartemkrylysovcomblog20200728lets-build-a-full-text-search-engine&#34;&gt;&lt;a href=&#34;https://artem.krylysov.com/blog/2020/07/28/lets-build-a-full-text-search-engine/&#34;&gt;如何自己实现一个全文搜索引擎&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者通过一个简单的例子，讲解全文搜索引擎的原理，自己如何实现倒排索引。举例用的是 Go 语言，代码很简单，接近伪代码&lt;/p&gt;
&lt;h3 id=&#34;如何发布-deno-模块httpsdevtocraigmortenhow-to-publish-deno-modules-2cg6&#34;&gt;&lt;a href=&#34;https://dev.to/craigmorten/how-to-publish-deno-modules-2cg6&#34;&gt;如何发布 Deno 模块&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Deno 是一个 TypeScript 运行时，可以替代 Node.js。它有一个模块托管服务，本文介绍如果将 GitHub 上面的模块源码，通过 Webhook 发布到官方的托管服务。&lt;/p&gt;
&lt;h3 id=&#34;财政部为什么使用-arctan-函数调节工资总额httpsmpweixinqqcomsig_ftmp6xbbse7q-xr70fa&#34;&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/ig_FTMp6XbbSE7q-XR70fA&#34;&gt;财政部为什么使用 arctan 函数调节工资总额&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;财政部最近下发了一个文件，使用 arctan 函数调节国有金融企业的工资总额。这个函数到底有什么特别之处？&lt;/p&gt;
&lt;h3 id=&#34;2020年值得推荐的13本-java-书籍httpsmediumcomjavarevisited10-books-java-developers-should-read-in-2020-e6222f25cc72&#34;&gt;&lt;a href=&#34;https://medium.com/javarevisited/10-books-java-developers-should-read-in-2020-e6222f25cc72&#34;&gt;2020年值得推荐的13本 Java 书籍&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者列了一个书单，推荐了13本 Java 学习书籍。&lt;/p&gt;
&lt;p&gt;2020-8-14&lt;/p&gt;
&lt;h3 id=&#34;如何在谷歌查找到任何信息httpswwwalecfyidorking-how-to-find-anything-on-the-internethtml&#34;&gt;&lt;a href=&#34;https://www.alec.fyi/dorking-how-to-find-anything-on-the-internet.html&#34;&gt;如何在谷歌查找到任何信息&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文通过一些小例子，介绍谷歌的搜索语法。这里还有完整的&lt;a href=&#34;https://ahrefs.com/blog/google-advanced-search-operators/&#34;&gt;搜索命令列表&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;张汝京谈中国半导体产业的发展httpswwwtmtpostcom4616621html&#34;&gt;&lt;a href=&#34;https://www.tmtpost.com/4616621.html&#34;&gt;张汝京谈中国半导体产业的发展&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;张汝京是中芯国际创始人，他在最近一次演讲中，回顾了第一到第三代半导体的发展，以及谈了中国半导体产业如何实现“超车”、第三代半导体未来的发展模式是什么等问题。&lt;/p&gt;
&lt;h3 id=&#34;停电时冰箱会保持低温多长时间httpswoodgearscaheatingfreezerhtml&#34;&gt;&lt;a href=&#34;https://woodgears.ca/heating/freezer.html&#34;&gt;停电时，冰箱会保持低温多长时间？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者做了一个有趣的实验，在冰箱里面放入传感器和树莓派，看看停电后，冷冻室能保持低温多长时间。结果发现，室温19°C的房间中，冷冻室每小时损失的冷度为2.6％，大约26小时后温度将达到0°。&lt;/p&gt;
&lt;h3 id=&#34;fasthttpsfastdesigndocsintroduction&#34;&gt;&lt;a href=&#34;https://fast.design/docs/introduction&#34;&gt;Fast&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;微软官方的 Web Components 组件库。&lt;/p&gt;
&lt;h3 id=&#34;p2httpswordpresscomp2&#34;&gt;&lt;a href=&#34;https://wordpress.com/p2/&#34;&gt;P2&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WordPress 团队新发布的团队协作工具，有点类似公司内部的博客系统，可以免费使用，计划会在未来开源。&lt;/p&gt;
&lt;h3 id=&#34;hasura-graphql-引擎httpsgithubcomhasuragraphql-engineblobmastertranslationsreadmechinesemd&#34;&gt;&lt;a href=&#34;https://github.com/hasura/graphql-engine/blob/master/translations/README.chinese.md&#34;&gt;Hasura GraphQL 引擎&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个高性能的 GraphQL 服务器，提供 Postgres上开箱即用的实时GraphQL API&lt;/p&gt;
&lt;h3 id=&#34;codotahttpswwwcodotacom&#34;&gt;&lt;a href=&#34;https://www.codota.com/&#34;&gt;codota&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个人工智能的代码提示和补全插件，支持各大主要的 IDE。&lt;/p&gt;
&lt;h3 id=&#34;github-readme-statshttpsgithubcomanuraghazragithub-readme-statsblobmasterdocsreadme_cnmd&#34;&gt;&lt;a href=&#34;https://github.com/anuraghazra/github-readme-stats/blob/master/docs/readme_cn.md&#34;&gt;github-readme-stats&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个可以自己部署的服务，生成个人 GitHub 账户的统计，可以插在自述文件里面。这里还有另一个&lt;a href=&#34;https://github.com/athul/waka-readme&#34;&gt;类似的服务&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;danfojshttpsgithubcomopensource9jadanfojs&#34;&gt;&lt;a href=&#34;https://github.com/opensource9ja/danfojs&#34;&gt;Danfo.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个提供跟 Pandas 相同功能的 JS 数学计算库。&lt;/p&gt;
&lt;h3 id=&#34;meilisearchhttpsgithubcommeilisearchmeilisearch&#34;&gt;&lt;a href=&#34;https://github.com/meilisearch/MeiliSearch&#34;&gt;MeiliSearch&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个开源的全文搜索软件，可以自己搭建服务，支持汉语搜索。&lt;/p&gt;
&lt;h3 id=&#34;mvpcsshttpsandybrewergithubiomvp&#34;&gt;&lt;a href=&#34;https://andybrewer.github.io/mvp/&#34;&gt;mvp.css&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个最简化的 CSS 库，不提供任何自定义的类，只给出最基本的 HTML 元素的样式，适合在它的基础上添加自定义的样式。&lt;/p&gt;
&lt;h3 id=&#34;技术树httpsgithubcomgithubarchive-programblobmasterthetechtreemd&#34;&gt;&lt;a href=&#34;https://github.com/github/archive-program/blob/master/TheTechTree.md&#34;&gt;技术树&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;为了让后代了解我们如何开发和使用软件，GitHub 官方开出了一个书单，称为“技术树”（the Tech Tree），包括16个大类的200多本经典书籍。这些书籍的数字化版本，将存放在 GitHub 的北极仓库。&lt;/p&gt;
&lt;h3 id=&#34;sql-实例教程httpswwwsqlteachingcom&#34;&gt;&lt;a href=&#34;https://www.sqlteaching.com/&#34;&gt;SQL 实例教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个针对初学者的 SQL 简单教程，通过在网页上运行示例来学习 SQL&lt;/p&gt;
&lt;h3 id=&#34;如何管理-redis-数据库httpswwwdigitaloceancomcommunitybookshow-to-manage-a-redis-database-ebook&#34;&gt;&lt;a href=&#34;https://www.digitalocean.com/community/books/how-to-manage-a-redis-database-ebook&#34;&gt;如何管理 Redis 数据库&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;DigitalOcean 发布的免费英文电子书，向初学者介绍什么是 Redis 和它的基本用法。&lt;/p&gt;
&lt;h3 id=&#34;bui-app-开发教程httpsmpweixinqqcommpappmsgalbum__bizmziynjqxnjuwmgactiongetalbumalbum_id1338511290868006913subscene159subscene158scenenotehttpsmpweixinqqcoms__bizmziynjqxnjuwmgmid2247483675idx1snfc494fc7e05dd5d05c2049e04816190dchksme8718302df060a14dc64d5ffddc76c319fd7cbfc8f7ac9c2ca09975a5431f23e85309cdb1820scene158rdwechat_redirect&#34;&gt;&lt;a href=&#34;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIyNjQxNjUwMg==&amp;amp;action=getalbum&amp;amp;album_id=1338511290868006913&amp;amp;subscene=159&amp;amp;subscene=158&amp;amp;scenenote=https://mp.weixin.qq.com/s?__biz=MzIyNjQxNjUwMg==&amp;amp;mid=2247483675&amp;amp;idx=1&amp;amp;sn=fc494fc7e05dd5d05c2049e04816190d&amp;amp;chksm=e8718302df060a14dc64d5ffddc76c319fd7cbfc8f7ac9c2ca09975a5431f23e85309cdb1820&amp;amp;scene=158#rd#wechat_redirect&#34;&gt;BUI App 开发教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;BUI 是一个国产的移动端 H5 框架，这是框架作者写的系列教程，演示如何用 BUI 开发一个网易新闻 App。&lt;/p&gt;
&lt;h3 id=&#34;鞋带暗语httpswwwfieggencomshoelacecialacinghtm&#34;&gt;&lt;a href=&#34;https://www.fieggen.com/shoelace/cialacing.htm&#34;&gt;鞋带暗语&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;冷战时期，中央情报局曾经采用一种鞋带暗语。只要根据鞋面上，鞋带交叉的位置和次数，就能传递事先约定的信息。这种方法非常简单，不受环境约束，外人很难察觉。&lt;/p&gt;
&lt;h3 id=&#34;css-生成艺术httpsgenerative-art-with-csscommonshost&#34;&gt;&lt;a href=&#34;https://generative-art-with-css.commons.host/&#34;&gt;CSS 生成艺术&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如何用 CSS 生成各种形状的图形&lt;/p&gt;
&lt;h3 id=&#34;manjaro-与-arch-linux-的区别httpsitsfosscommanjaro-vs-arch-linux&#34;&gt;&lt;a href=&#34;https://itsfoss.com/manjaro-vs-arch-linux/&#34;&gt;Manjaro 与 Arch Linux 的区别&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Manjaro 与 Arch 都是流行的 Linux 发行版，Manjaro 基于 Arch，但是有自己显著的特点。&lt;/p&gt;
&lt;h3 id=&#34;单个创始人的表现更好httpswwwgrowthclubonlinepostresearch-says-solo-founders-perform-better-here-is-why&#34;&gt;&lt;a href=&#34;https://www.growthclub.online/post/research-says-solo-founders-perform-better-here-is-why&#34;&gt;单个创始人的表现更好&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;统计显示，单个创始人的公司更可能盈利，本文分析原因&lt;/p&gt;
&lt;h3 id=&#34;熵的羊群解释httpsaatishbcomentropy&#34;&gt;&lt;a href=&#34;https://aatishb.com/entropy/&#34;&gt;熵的羊群解释&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;较为通俗地解释了，物理学的熵（entropy）是概率导致的。&lt;/p&gt;
&lt;h3 id=&#34;crdt-算法是否适合多人实时编辑httpsblogkevinjahnsdeare-crdts-suitable-for-shared-editing&#34;&gt;&lt;a href=&#34;https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing/&#34;&gt;CRDT 算法是否适合多人实时编辑？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;CRDT 算法用于分布式服务实现数据同步，比如同一篇文档的多人实时编辑。&lt;a href=&#34;https://github.com/yjs/yjs&#34;&gt;Yjs&lt;/a&gt; 是 CRDT 的一个实现，本文是它的作者对这个算法的解释，内容有一定深度。&lt;/p&gt;
&lt;h3 id=&#34;typescript-简明介绍httpswwwwarambilcomtypescript-why-is-so-important&#34;&gt;&lt;a href=&#34;https://www.warambil.com/typescript-why-is-so-important&#34;&gt;TypeScript 简明介绍&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;针对初学者的 TypeScript 介绍&lt;/p&gt;
&lt;h3 id=&#34;html-smuggling-解释httpsoutflanknlblog20180814html-smuggling-explained&#34;&gt;&lt;a href=&#34;https://outflank.nl/blog/2018/08/14/html-smuggling-explained/&#34;&gt;HTML smuggling 解释&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;很多人不知道，JavaScript 可以脚本生成 exe 文件，让用户下载。本文介绍如何在网页里面嵌入一个恶意的可执行文件。&lt;/p&gt;
&lt;h3 id=&#34;广告短信的退订内幕httpsdailyzhihucomstory9726870&#34;&gt;&lt;a href=&#34;https://daily.zhihu.com/story/9726870&#34;&gt;广告短信的退订内幕&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;很多促销广告短信都说回复 T 退订，但是回复了 T 之后会发生什么&lt;/p&gt;
&lt;h3 id=&#34;qrpicturehttpswwwqrpicturecom&#34;&gt;&lt;a href=&#34;https://www.qrpicture.com/&#34;&gt;QRpicture&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个在线工具，把图片变成可以扫描的二维码。&lt;/p&gt;
&lt;h3 id=&#34;screenplaysubshttpsscreenplaysubscom&#34;&gt;&lt;a href=&#34;https://screenplaysubs.com/&#34;&gt;ScreenplaySubs&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;浏览器插件，播放 Netflix 视频的时候，同步显示剧本内容。&lt;/p&gt;
&lt;h3 id=&#34;umamihttpsumamiis&#34;&gt;&lt;a href=&#34;https://umami.is/&#34;&gt;umami&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个开源的网站访问统计服务。&lt;/p&gt;
&lt;h3 id=&#34;ts-migratehttpsgithubcomairbnbts-migrate&#34;&gt;&lt;a href=&#34;https://github.com/airbnb/ts-migrate&#34;&gt;ts-migrate&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Airbnb 公司新的开源项目，可以将 JavaScript 代码转成 TypeScript 代码。&lt;/p&gt;
&lt;h3 id=&#34;jscoolhttpsgithubcomjs-cooljscool&#34;&gt;&lt;a href=&#34;https://github.com/js-cool/js.cool&#34;&gt;js.cool&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;为开源项目提供免费的&lt;code&gt;js.cool&lt;/code&gt;的子域名，类似&lt;code&gt;js.org&lt;/code&gt;，支持 CNAME 绑定&lt;/p&gt;
&lt;h3 id=&#34;screen-share-partyhttpsbanetscreen-share-party&#34;&gt;&lt;a href=&#34;https://ba.net/screen-share-party&#34;&gt;Screen Share Party&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站通过 WebRTC 协议把你的桌面分享给其他人。它生成一个 URL，其他人访问这个 URL，就能看到你的桌面&lt;/p&gt;
&lt;h3 id=&#34;mazahttpsgithubcomtanraxmaza-ad-blocking&#34;&gt;&lt;a href=&#34;https://github.com/tanrax/maza-ad-blocking&#34;&gt;maza&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个本地的广告拦截器，通过封锁 DNS 达到拦截广告的目的。它的特点就是非常简单，就是一个 Bash 脚本，可以作为学习脚本编程的范例。&lt;/p&gt;
&lt;h3 id=&#34;统计学习导论httpfacultymarshalluscedugareth-jamesislan-introduction-to-statistical-learning&#34;&gt;&lt;a href=&#34;http://faculty.marshall.usc.edu/gareth-james/ISL/&#34;&gt;统计学习导论&lt;/a&gt;（An Introduction to Statistical Learning）&lt;/h3&gt;
&lt;p&gt;免费英文电子书，可以作为非数学专业学生的统计学教材，侧重机器学习的统计基础，提供 R 语言的例子。&lt;/p&gt;
&lt;h3 id=&#34;1940年纽约历史地图https1940snycmap&#34;&gt;&lt;a href=&#34;https://1940s.nyc/map/&#34;&gt;1940年纽约历史地图&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个网站提供1940年代的纽约在线地图，并且还可以查看各个地点的历史照片。&lt;/p&gt;
&lt;h3 id=&#34;ai-还原古罗马皇帝httpsvoshartcomroman-emperor-project&#34;&gt;&lt;a href=&#34;https://voshart.com/ROMAN-EMPEROR-PROJECT&#34;&gt;AI 还原古罗马皇帝&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个项目使用 AI 模型，将古罗马皇帝的塑像还原成高清晰度人像照片。&lt;/p&gt;
&lt;h3 id=&#34;物理学书单httpswwwsusanjfowlercomblog2016813so-you-want-to-learn-physics&#34;&gt;&lt;a href=&#34;https://www.susanjfowler.com/blog/2016/8/13/so-you-want-to-learn-physics&#34;&gt;物理学书单&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者列了一个英文书单，对于想自学物理学、达到本科以及研究生水平的读者，应该阅读哪些教材。&lt;/p&gt;
&lt;h3 id=&#34;covid-19-舆论新闻可视化httpspearminigiteeioncovis-2020&#34;&gt;&lt;a href=&#34;https://pearmini.gitee.io/ncovis-2020/#/&#34;&gt;COVID-19 舆论新闻可视化&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;山东大学 VisLab 的一个可视化项目，分析疫情对舆论和新闻的影响&lt;/p&gt;
&lt;h3 id=&#34;next-徽标httpswwwlogodesignlovecomnext-logo-paul-rand&#34;&gt;&lt;a href=&#34;https://www.logodesignlove.com/next-logo-paul-rand&#34;&gt;NeXT 徽标&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;1986年，乔布斯向著名的平面设计师保罗·兰德（Paul Rand）支付了10万美元，要求为自己的 NeXT 计算机公司设计徽标。&lt;/p&gt;
&lt;h3 id=&#34;姆潘巴现象httpsenwikipediaorgwikimpemba_effect&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Mpemba_effect&#34;&gt;姆潘巴现象&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;1963年，坦桑尼亚的一个高中上烹饪课，学生们做冰淇淋。&lt;/p&gt;
&lt;p&gt;一个叫做姆潘巴（Erasto Mpemba）的学生，发现了一个奇怪的现象。两个装有相同体积水的容器，一个是35°C，另一个是100°C，同时放进冰箱，竟然是100°C的水首先开始结冰。也就是说，温度高的水会更快结冰，这是为什么？&lt;/p&gt;
&lt;p&gt;物理老师也不知道这是怎么回事，就把这个结果发表出来。这引起物理学界的争论，科学家也无法解释，就把它称为“姆潘巴现象”。&lt;/p&gt;
&lt;p&gt;2012年，英国皇家化学学会举行了一场竞赛，征集论文，对姆潘巴现象进行解释。共有22,000人参加，获胜者提出了两种解释。&lt;/p&gt;
&lt;p&gt;（1）过冷（Supercooling）。低温液体会在一定时间内存在过冷现象，低于凝固点仍维持液体。&lt;/p&gt;
&lt;p&gt;（2）对流。温度高的液体有更高的对流，有利于散热。&lt;/p&gt;
&lt;h3 id=&#34;网络安全工程师的修炼途径httpsdanielmiesslercomblogbuild-successful-infosec-career&#34;&gt;&lt;a href=&#34;https://danielmiessler.com/blog/build-successful-infosec-career/&#34;&gt;网络安全工程师的修炼途径&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者在网络安全方面有20年的从业经验。他在本文中介绍网络安全工程所需的技能和培养途径。他提出，学习者一定要有自己的实验室，熟练使用虚拟机测试各种系统。&lt;/p&gt;
&lt;h3 id=&#34;如何用神经网络玩超级马里奥兄弟httpschrispressogithubioai_learns_to_play_smb_using_ga_and_nn&#34;&gt;&lt;a href=&#34;https://chrispresso.github.io/AI_Learns_To_Play_SMB_Using_GA_And_NN&#34;&gt;如何用神经网络玩超级马里奥兄弟&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/341c2569aca0476fcea72a82669b5926fd8311d6/68747470733a2f2f7777772e77616e67626173652e636f6d2f626c6f67696d672f61737365742f3230323030382f6267323032303038323230312e6a7067&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/341c2569aca0476fcea72a82669b5926fd8311d6/68747470733a2f2f7777772e77616e67626173652e636f6d2f626c6f67696d672f61737365742f3230323030382f6267323032303038323230312e6a7067&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者展示了如何用 Python 写一个神经网络模型，自动玩超级马里奥兄弟，可以很清晰地看懂他的算法，就是将游戏画面转化成一帧帧的像素网格（注意下图两侧画面的对比），根据网格的变化，程序自动做出反应。&lt;/p&gt;
&lt;h3 id=&#34;深入了解-python的官方-docker-映像httpspythonspeedcomarticlesofficial-python-docker-image&#34;&gt;&lt;a href=&#34;https://pythonspeed.com/articles/official-python-docker-image/&#34;&gt;深入了解 Python的官方 Docker 映像&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文是一篇 Docker 教程，一步步介绍 Python 官方的 Docker 镜像是怎么制作的，详细解读 Dockefile 文件&lt;/p&gt;
&lt;h3 id=&#34;理解-python-哈希表httpthepythoncornercomdevhash-tables-understanding-dictionaries&#34;&gt;&lt;a href=&#34;http://thepythoncorner.com/dev/hash-tables-understanding-dictionaries/&#34;&gt;理解 Python 哈希表&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文详细讲解 Python 哈希函数的用法，然后用它实现一个简单的哈希表。&lt;/p&gt;
&lt;h3 id=&#34;如何在谷歌云安装-pi-holehttpsmediumcomdevinjaystokeshow-to-set-up-a-pi-hole-ad-blocking-vpn-server-on-google-clouds-always-free-usage-tier-ff1d8a8c407e&#34;&gt;&lt;a href=&#34;https://medium.com/@devinjaystokes/how-to-set-up-a-pi-hole-ad-blocking-vpn-server-on-google-clouds-always-free-usage-tier-ff1d8a8c407e&#34;&gt;如何在谷歌云安装 Pi-Hole&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一篇非常详细的教程，一步步教你在谷歌云上安装 Pi-Hole，自己搭建一个 DNS 服务器，能够屏蔽广告。&lt;/p&gt;
&lt;h3 id=&#34;如何使用-firebase-开发一个自己的评论系统httpswwwsmashingmagazinecom202008comment-system-firebase英文&#34;&gt;&lt;a href=&#34;https://www.smashingmagazine.com/2020/08/comment-system-firebase/&#34;&gt;如何使用 Firebase 开发一个自己的评论系统&lt;/a&gt;（英文）&lt;/h3&gt;
&lt;p&gt;Firebase 是谷歌的实时数据库服务，本文是如何使用它来储存前端数据的详细教程&lt;/p&gt;
&lt;h3 id=&#34;使用-safari-web-share-api-窃取本地文件httpsblogredteampl202008stealing-local-files-using-safari-webhtml&#34;&gt;&lt;a href=&#34;https://blog.redteam.pl/2020/08/stealing-local-files-using-safari-web.html&#34;&gt;使用 Safari Web Share API 窃取本地文件&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文介绍如何在苹果设备上，利用 Safari 浏览器的 Web Share API 在用户不知情的情况下，将本地文件分享出去。&lt;/p&gt;
&lt;h3 id=&#34;cipheyhttpsgithubcomcipheyciphey&#34;&gt;&lt;a href=&#34;https://github.com/Ciphey/Ciphey&#34;&gt;Ciphey&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有时，我们有一段加密文本，但是不知道它使用什么加密方法。这个命令行工具，会根据人工智能算法，自动判断加密方法，能不能解密。&lt;/p&gt;
&lt;h3 id=&#34;ztextjshttpsbennettfeelycomztext&#34;&gt;&lt;a href=&#34;https://bennettfeely.com/ztext/&#34;&gt;ztext.js&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个 JS 库可以将任何字体变成 3D 效果，支持中文。&lt;/p&gt;
&lt;h3 id=&#34;css-渐变魔法httpswwwgradientmagiccom&#34;&gt;&lt;a href=&#34;https://www.gradientmagic.com/&#34;&gt;CSS 渐变魔法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站收集各种 CSS 渐变图像，可以复制到自己的项目。&lt;/p&gt;
&lt;h3 id=&#34;labuladong-的算法小抄httpslabuladonggitbookioalgo&#34;&gt;&lt;a href=&#34;https://labuladong.gitbook.io/algo/&#34;&gt;labuladong 的算法小抄&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;100 多道 LeetCode 算法题目的中文解释。&lt;/p&gt;
&lt;h3 id=&#34;不可能的几何形状httpsim-possibleinfoenglishlibraryindexhtml&#34;&gt;&lt;a href=&#34;https://im-possible.info/english/library/index.html&#34;&gt;不可能的几何形状&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站收集各种不可能的几何形状图片，目前已经有两千多张了。&lt;/p&gt;
&lt;h3 id=&#34;puppeteer--playwright-学习教程httpstheheadlessdev&#34;&gt;&lt;a href=&#34;https://theheadless.dev/&#34;&gt;Puppeteer &amp;amp; Playwright 学习教程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一份英语教程，介绍无头浏览器操作库 Puppeteer 和 Playwright 的用法。&lt;/p&gt;
&lt;h3 id=&#34;讲解开源项目httpsgithubcomhellogithub-teamarticle&#34;&gt;&lt;a href=&#34;https://github.com/HelloGitHub-Team/Article&#34;&gt;讲解开源项目&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一组中文的系列文章，介绍各种开源项目和用法&lt;/p&gt;
&lt;h3 id=&#34;富士山公路httpswwwatlasobscuracomarticlessnow-canyon-japan&#34;&gt;&lt;a href=&#34;https://www.atlasobscura.com/articles/snow-canyon-japan&#34;&gt;富士山公路&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;日本有一条通往富士山的高速公路。冬天下雪时，积雪有时厚达几米。扫除路上的积雪以后，就形成了公路两边有雪墙的奇特景象。&lt;/p&gt;
&lt;h3 id=&#34;大公司如何合法避税httpswwwredditcomrcoolguidescommentsifz1nohow_to_not_pay_taxes&#34;&gt;&lt;a href=&#34;https://www.reddit.com/r/coolguides/comments/ifz1no/how_to_not_pay_taxes/&#34;&gt;大公司如何合法避税&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如题&lt;/p&gt;
&lt;h3 id=&#34;肉鸡的由来httpswwwtheguardiancomenvironment2020aug17from-farm-to-factory-the-unstoppable-rise-of-american-chicken&#34;&gt;&lt;a href=&#34;https://www.theguardian.com/environment/2020/aug/17/from-farm-to-factory-the-unstoppable-rise-of-american-chicken&#34;&gt;肉鸡的由来&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如题&lt;/p&gt;
&lt;h3 id=&#34;如何用简单英语写作httpwwwplainenglishcoukhow-to-write-in-plain-englishhtml&#34;&gt;&lt;a href=&#34;http://www.plainenglish.co.uk/how-to-write-in-plain-english.html&#34;&gt;如何用简单英语写作&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文介绍几个很实用的英语写作规则，帮助你写出简单易懂的英语。&lt;/p&gt;
&lt;h3 id=&#34;gps-定位原理httpsblogdigitalbunkerdev20200828how-do-global-positioning-systems-gps-work&#34;&gt;&lt;a href=&#34;https://blog.digitalbunker.dev/2020/08/28/how-do-global-positioning-systems-gps-work/&#34;&gt;GPS 定位原理&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文介绍 GPS 卫星系统如何能够定位，写得比较容易懂。定位的关键是卫星上的原子钟必须准确报时。&lt;/p&gt;
&lt;h3 id=&#34;异步操作需要设置超时httpsrobertovitillocomdefault-timeouts&#34;&gt;&lt;a href=&#34;https://robertovitillo.com/default-timeouts/&#34;&gt;异步操作需要设置超时&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文是一个提醒，进行异步操作的时候（比如 AJAX 请求），要设置超时。因为 AJAX 默认没有超时限制，浏览器会一直等下去，极端情况下，可能会耗尽套接字的资源池。&lt;/p&gt;
&lt;h3 id=&#34;如何让-linux-不区分文件名大小写httpswwwcollaboracomnews-and-blogblog20200827using-the-linux-kernel-case-insensitive-feature-in-ext4&#34;&gt;&lt;a href=&#34;https://www.collabora.com/news-and-blog/blog/2020/08/27/using-the-linux-kernel-case-insensitive-feature-in-ext4/&#34;&gt;如何让 Linux 不区分文件名大小写&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Linux 5.2 开始，支持不区分文件名大小写，本文教你怎么打开这个功能。&lt;/p&gt;
&lt;h3 id=&#34;短消息发送一次性验证码的标准httpstrineocomblog202008phishing-resistant-one-time-codes&#34;&gt;&lt;a href=&#34;https://trineo.com/blog/2020/08/phishing-resistant-one-time-codes&#34;&gt;短消息发送一次性验证码的标准&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;很多网站采用短消息发送一次性验证码，作为用户认证的手段。苹果和谷歌已经商定了短消息格式标准，GitHub 开始采用这个标准。&lt;/p&gt;
&lt;h3 id=&#34;react-列表-key-属性的三个常见错误httpsdevtothawkin3common-mistakes-with-react-keys-1jcc&#34;&gt;&lt;a href=&#34;https://dev.to/thawkin3/common-mistakes-with-react-keys-1jcc&#34;&gt;React 列表 key 属性的三个常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;React 框架要求列表的每一项都带有&lt;code&gt;key&lt;/code&gt;属性，本文介绍这个属性的三个需要注意的地方。&lt;/p&gt;
&lt;h3 id=&#34;bootstrap-图标库httpsgithubcomtwbsicons&#34;&gt;&lt;a href=&#34;https://github.com/twbs/icons&#34;&gt;Bootstrap 图标库&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Bootstrap 的图标库发布1.0正式版，包含1100多个图标，全部都是 SVG 格式，可以插入 img 标签。&lt;/p&gt;
&lt;h3 id=&#34;lunarhttpsgithubcomalin23lunar&#34;&gt;&lt;a href=&#34;https://github.com/alin23/Lunar&#34;&gt;Lunar&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;调节 Mac 电脑外接显示器亮度的软件，可以根据时间，自动调节亮度。&lt;/p&gt;
&lt;h3 id=&#34;nginx-日志分析可视化httpsgithubcomturbowaybigdata_practice&#34;&gt;&lt;a href=&#34;https://github.com/TurboWay/bigdata_practice&#34;&gt;nginx 日志分析可视化&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个完整的大数据实践项目，通过 hive 分析 nginx 日志，将分析结果通过 flask + echarts 进行可视化展示。&lt;/p&gt;
&lt;h3 id=&#34;go-zerohttpsgithubcomtal-techgo-zero&#34;&gt;&lt;a href=&#34;https://github.com/tal-tech/go-zero&#34;&gt;go-zero&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个国产的 web 和 rpc 微服务框架，含极简的 API 定义和生成工具 goctl，可以根据定义的 api 文件一键生成各语言的调用代码。&lt;/p&gt;
&lt;h3 id=&#34;ios-开发课程httpscs193psitesstanfordedu&#34;&gt;&lt;a href=&#34;https://cs193p.sites.stanford.edu/&#34;&gt;iOS 开发课程&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;斯坦福大学的高质量免费课程，使用了最新的 SwiftUI，充分展示了 APP 开发的整个流程，适合新手进行 iOS 的开发入门。&lt;/p&gt;
&lt;h3 id=&#34;1gb-手机流量的价格httpswwwcablecoukmobilesworldwide-data-pricing&#34;&gt;&lt;a href=&#34;https://www.cable.co.uk/mobiles/worldwide-data-pricing/&#34;&gt;1GB 手机流量的价格&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站收集全世界各国家和地区的 1GB 手机流量的价格。中国大陆的平均价格是0.61美元，排在第12位，属于手机上网很便宜的地方。美国平均需要8美元，排在第188位，是非常贵的地方。&lt;/p&gt;
&lt;h3 id=&#34;面向初学者的-python-项目httpswwwcodewithreplitpython-projects-for-beginnershtml&#34;&gt;&lt;a href=&#34;https://www.codewithrepl.it/python-projects-for-beginners.html&#34;&gt;面向初学者的 Python 项目&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如题，一本免费 Python 教程，使用 Repl.it 在线编程环境学习 Python。&lt;/p&gt;
&lt;h3 id=&#34;在线工具秘籍httpsgithubcomzhaooleeonlinetoolsbook&#34;&gt;&lt;a href=&#34;https://github.com/zhaoolee/OnlineToolsBook&#34;&gt;在线工具秘籍&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个中文仓库收集各种好用的在线小工具。&lt;/p&gt;
&lt;h3 id=&#34;面向程序员的实用深度学习httpscoursefastai&#34;&gt;&lt;a href=&#34;https://course.fast.ai/&#34;&gt;面向程序员的实用深度学习&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;fast.ai 公司推出的深度学习教程。&lt;/p&gt;
&lt;h3 id=&#34;世界最长的火车路线httpsbasementgeographercomthe-longest-train-ride-in-the-world&#34;&gt;&lt;a href=&#34;https://basementgeographer.com/the-longest-train-ride-in-the-world/&#34;&gt;世界最长的火车路线&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;目前，世界最长的火车路线是从葡萄牙首都波尔多开始，一直到达越南南部，全长17000公里。你可以全程乘坐火车，但需要经过多次换车。&lt;/p&gt;
&lt;p&gt;整个路程最快也要耗时327小时，相当于13天半，总票价2000美元以上。&lt;/p&gt;
&lt;h3 id=&#34;巴比伦乘法公式httpswwwiquilezlesorgblogp4582&#34;&gt;&lt;a href=&#34;https://www.iquilezles.org/blog/?p=4582&#34;&gt;巴比伦乘法公式&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;古代巴比伦人使用下面的公式，计算两个数的乘积。
$$
ab=\frac{(a+b)^2-(a-b)^2}4
$$&lt;/p&gt;
&lt;h3 id=&#34;高德納自述我对电子邮件的态度httpswww-cs-facultystanfordeduknuthemailhtml&#34;&gt;&lt;a href=&#34;https://www-cs-faculty.stanford.edu/~knuth/email.html&#34;&gt;高德納自述：我对电子邮件的态度&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Donald E. Knuth 教授
计算机科学系 斯坦福大学
盖茨大楼4B
斯坦福大学
CA 94305-9045美国&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;沙皇核弹纪录片httpsthebarentsobservercomensecurity202008rosatom-releases-previously-classified-documentary-video-50-mt-novaya-zemlya-test&#34;&gt;&lt;a href=&#34;https://thebarentsobserver.com/en/security/2020/08/rosatom-releases-previously-classified-documentary-video-50-mt-novaya-zemlya-test&#34;&gt;沙皇核弹纪录片&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;今年8月20日，为了纪念苏联核工业发展75周年，俄罗斯在 YouTube 上发布了一部讲述沙皇核弹的纪录片。&lt;/p&gt;
&lt;h3 id=&#34;我的业余作品如何以3万美元出售httpsmarciotweet-photo-acquired&#34;&gt;&lt;a href=&#34;https://marc.io/tweet-photo-acquired&#34;&gt;我的业余作品如何以3万美元出售&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者最初写了一篇文章，介绍如何将 Instagram 图片同步到推特，结果发现浏览量很高。有人还写信，愿意付费使用该功能。作者就把它做成一个小服务，结果被3万美元收购。&lt;/p&gt;
&lt;h3 id=&#34;如何使用-github-管理个人笔记httpswwwbit-101comblog202009git-based-wiki&#34;&gt;&lt;a href=&#34;https://www.bit-101.com/blog/2020/09/git-based-wiki/&#34;&gt;如何使用 GitHub 管理个人笔记&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者介绍他如何将 GitHub 仓库当作 Wiki 使用，管理个人笔记。&lt;/p&gt;
&lt;h3 id=&#34;10个你可能不知道的-web-apihttpsbloggreenrootsinfo10-lesser-known-web-apis-you-may-want-to-use-ckejv75cr012y70s158n85yhn&#34;&gt;&lt;a href=&#34;https://blog.greenroots.info/10-lesser-known-web-apis-you-may-want-to-use-ckejv75cr012y70s158n85yhn&#34;&gt;10个你可能不知道的 Web API&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Chrome 浏览器提供的 Web API 非常多，本文介绍其中10个。&lt;/p&gt;
&lt;h3 id=&#34;如何在浏览器里制作一个互动地球仪httpsstripecomblogglobe&#34;&gt;&lt;a href=&#34;https://stripe.com/blog/globe&#34;&gt;如何在浏览器里制作一个互动地球仪&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者介绍如何使用 WebGL（通过 three.js）在浏览器里面做出一个可以互动的地球仪。&lt;/p&gt;
&lt;h3 id=&#34;浮点数原理httpstimroderickcomfloating-point-introduction&#34;&gt;&lt;a href=&#34;https://timroderick.com/floating-point-introduction/&#34;&gt;浮点数原理&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文较为通俗地解释，什么是浮点数，为什么这么设计。&lt;/p&gt;
&lt;h3 id=&#34;如何在亚马逊网络服务上部署一个-react-apphttpsawsamazoncomgetting-startedhands-onbuild-react-app-amplify-graphqlmodule-one&#34;&gt;&lt;a href=&#34;https://aws.amazon.com/getting-started/hands-on/build-react-app-amplify-graphql/module-one/&#34;&gt;如何在亚马逊网络服务上部署一个 React App&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;官方文档，介绍如何用 AWS Amplify 自动构建和部署一个 React 应用。跟亚马逊的其他文档相比，写得非常好懂。&lt;/p&gt;
&lt;h3 id=&#34;mongodb-的历史httpswwwquickprogrammingtipscommongodbmongodb-historyhtml&#34;&gt;&lt;a href=&#34;https://www.quickprogrammingtips.com/mongodb/mongodb-history.html&#34;&gt;MongoDB 的历史&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;MongoDB 是现在最流行的 NoSQL 数据库，本文详尽介绍了它的历史，以及早期的设计决定。&lt;/p&gt;
&lt;h3 id=&#34;55k-月用户的-web-应用成本httpskeepthescorecoblogpostscosts-of-running-webapp&#34;&gt;&lt;a href=&#34;https://keepthescore.co/blog/posts/costs-of-running-webapp/&#34;&gt;55K 月用户的 Web 应用成本&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者维护着一个 Python flask 应用，每月有5.5万访问者。本文总结了他每月花在这个网站上的账单。&lt;/p&gt;
&lt;h3 id=&#34;responsivelyhttpsgithubcomresponsively-orgresponsively-app&#34;&gt;&lt;a href=&#34;https://github.com/responsively-org/responsively-app&#34;&gt;responsively&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个方便的桌面软件，集成了开发和调试响应式网页的各种功能。&lt;/p&gt;
&lt;h3 id=&#34;网页骨架布局生成器httpsskeletonreactcom&#34;&gt;&lt;a href=&#34;https://skeletonreact.com/&#34;&gt;网页骨架布局生成器&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有些网页加载时，会显示一个骨架布局（上图），获取正式内容后再替换掉。这个在线工具就用来生成骨架布局，支持 React、React Native、Vue 和 普通 HTML。&lt;/p&gt;
&lt;h3 id=&#34;解决算法和数据结构问题python-版httpswwwcsaucklandacnzcompsci105s1cresourcesproblemsolvingwithalgorithmsanddatastructurespdf&#34;&gt;&lt;a href=&#34;https://www.cs.auckland.ac.nz/compsci105s1c/resources/ProblemSolvingwithAlgorithmsandDataStructures.pdf&#34;&gt;解决算法和数据结构问题（Python 版）&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;免费的英文电子书， 使用 Python 语言介绍基本的算法和数据结构，内容比较简单，也不厚200多页，适合初学者。&lt;/p&gt;
&lt;h3 id=&#34;degooglehttpsdegooglejmooredev&#34;&gt;&lt;a href=&#34;https://degoogle.jmoore.dev/&#34;&gt;degoogle&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站收集各种谷歌服务的替代品。&lt;/p&gt;
&lt;h3 id=&#34;winamp-皮肤图书馆httpsskinswebamporg&#34;&gt;&lt;a href=&#34;https://skins.webamp.org/&#34;&gt;Winamp 皮肤图书馆&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该网站收集各种 Winamp 播放器的皮肤。&lt;/p&gt;
&lt;h3 id=&#34;web-api-设计httpslivebookmanningcombookthe-design-of-web-apischapter-1originproduct-tocthe-design-of-web-apis&#34;&gt;&lt;a href=&#34;https://livebook.manning.com/book/the-design-of-web-apis/chapter-1?origin=product-toc&#34;&gt;Web API 设计&lt;/a&gt;（The Design of Web APIs）&lt;/h3&gt;
&lt;p&gt;Manning 出版社的英文书籍，现在官方提供在线免费阅读，内容很不错，关于怎么设计 Web 应用的 API。&lt;/p&gt;
&lt;h3 id=&#34;inux-从零开始httpwwwlinuxfromscratchorglfsview100-rc1prologueforewordhtmllinux-from-scratch&#34;&gt;&lt;a href=&#34;http://www.linuxfromscratch.org/lfs/view/10.0-rc1/prologue/foreword.html&#34;&gt;inux 从零开始&lt;/a&gt;（Linux From Scratch）&lt;/h3&gt;
&lt;p&gt;一本英文的免费书籍，讲述如何从源码一步步编译一个自己的 Linux 系统，帮助你深入理解 Linux。&lt;/p&gt;
&lt;h3 id=&#34;水上飞行器-ekranoplanhttpswwwpopularmechanicscommilitaryaviationa33808381russia-ekranoplan-plane-boat-wrecked&#34;&gt;&lt;a href=&#34;https://www.popularmechanics.com/military/aviation/a33808381/russia-ekranoplan-plane-boat-wrecked/&#34;&gt;水上飞行器 Ekranoplan&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;RT.&lt;/p&gt;
&lt;h3 id=&#34;核电池可以用于太空旅行httpswwwgenerationatomicorgskimthe-nuclear-heartbeat-of-space-exploration&#34;&gt;&lt;a href=&#34;https://www.generationatomic.org/skim/the-nuclear-heartbeat-of-space-exploration&#34;&gt;核电池可以用于太空旅行&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文介绍了核电池的原理（利用放射性元素衰变产生的能量），以及用于太空旅行的可能性。&lt;/p&gt;
&lt;h3 id=&#34;使用蒙特卡洛算法玩2048httpsxtrpioblog20200912using-the-monte-carlo-tree-search-algorithm-in-an-ai-to-beat-2048-and-other-games&#34;&gt;&lt;a href=&#34;https://xtrp.io/blog/2020/09/12/using-the-monte-carlo-tree-search-algorithm-in-an-ai-to-beat-2048-and-other-games/&#34;&gt;使用蒙特卡洛算法玩2048&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;2048 是一个4x4的方块游戏，只要两个相同数字相邻，就可以合并为一个数字。本文讲解了如何用蒙特卡洛算法进行简单模拟，让计算机自己解决2048游戏。&lt;/p&gt;
&lt;h3 id=&#34;for-await--of-语句解释httpswwwmikealchecomsoftware-developmenta-simple-explanation-of-the-for-await-of-statement-in-node-js&#34;&gt;&lt;a href=&#34;https://www.mikealche.com/software-development/a-simple-explanation-of-the-for-await-of-statement-in-node-js&#34;&gt;for await &amp;hellip; of 语句解释&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;ES6 引入了 for await &amp;hellip; of 新语法，用来遍历异步迭代器，很多人还不熟悉。本文是对它的简单解释。&lt;/p&gt;
&lt;h3 id=&#34;使用-react-钩子而不是类的6个理由httpsblogbitsrcio6-reasons-to-use-react-hooks-instead-of-classes-7e3ee745fe04&#34;&gt;&lt;a href=&#34;https://blog.bitsrc.io/6-reasons-to-use-react-hooks-instead-of-classes-7e3ee745fe04&#34;&gt;使用 React 钩子而不是类的6个理由&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文总结 React 钩子比类更有优势的6个方面，比如不再有 this 问题，也不用再绑定方法了。&lt;/p&gt;
&lt;h3 id=&#34;avif-格式初探httpsjakearchibaldcom2020avif-has-landed&#34;&gt;&lt;a href=&#34;https://jakearchibald.com/2020/avif-has-landed/&#34;&gt;AVIF 格式初探&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/5a8b70251077f1c3b472fcd2438532845eeb85d0/68747470733a2f2f7777772e77616e67626173652e636f6d2f626c6f67696d672f61737365742f3230323030392f6267323032303039313731312e6a7067&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;AVIF 是一种开源图片格式，源自 AV1 视频格式。各个平台基本上都会支持，这篇文章对比了它与 JPEG 和 WebP 格式，结果很不错。&lt;/p&gt;
&lt;h3 id=&#34;nodejs-如何下载流传输文件httpsphilnashblog20200806how-to-stream-file-downloads-in-node-js-with-got&#34;&gt;&lt;a href=&#34;https://philna.sh/blog/2020/08/06/how-to-stream-file-downloads-in-Node-js-with-got/&#34;&gt;Node.js 如何下载流传输文件&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文介绍如何使用 Got 这个库，以流传输的形式（stream）下载文件。&lt;/p&gt;
&lt;h3 id=&#34;diffcheckerhttpswwwdiffcheckercom&#34;&gt;&lt;a href=&#34;https://www.diffchecker.com/&#34;&gt;Diffchecker&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个在线工具，可以检查文本、图片、PDF 之间的差异。&lt;/p&gt;
&lt;h3 id=&#34;screelyhttpswwwscreelycom&#34;&gt;&lt;a href=&#34;https://www.screely.com/&#34;&gt;Screely&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个在线工具，可以生成网页展示效果的示意图。&lt;/p&gt;
&lt;h3 id=&#34;poolside-fmhttpspoolsidefm&#34;&gt;&lt;a href=&#34;https://poolside.fm/&#34;&gt;Poolside FM&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个在线的复古风格音乐电台。&lt;/p&gt;
&lt;h3 id=&#34;mimestreamhttpsmimestreamcom&#34;&gt;&lt;a href=&#34;https://mimestream.com/&#34;&gt;Mimestream&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;前苹果邮件客户端工程师 Neil Jhaveri 推出的 Gmail macOS 原生客户端，外观简洁大方，十分契合原生风格&lt;/p&gt;
&lt;h3 id=&#34;kibana-eyehttpsgithubcomcasterwxkibana-eye&#34;&gt;&lt;a href=&#34;https://github.com/CasterWx/kibana-eye&#34;&gt;kibana-eye&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;ELK 平台（Elasticsearch，Logstash，Kibana）的定时任务管理工具，可以聚合处理日志，生成报表信息，通过邮件/钉钉等方式发送通知。&lt;/p&gt;
&lt;h3 id=&#34;lofimusichttpslofimusicapp&#34;&gt;&lt;a href=&#34;https://lofimusic.app/&#34;&gt;LofiMusic&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个开源的背景音乐播放网站。&lt;/p&gt;
&lt;h3 id=&#34;beewarehttpsbeewareorg&#34;&gt;&lt;a href=&#34;https://beeware.org/&#34;&gt;BeeWare&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 Python 工具，让你的 Python 代码可以打包成跨平台图形界面应用，尤其是可以打包成手机 App，支持 iOS、Android、Windows、MacOS、Linux、Web 等平台。&lt;/p&gt;
&lt;h3 id=&#34;aggregated-awesomehttpsaggregatedawesomecom&#34;&gt;&lt;a href=&#34;https://aggregatedawesome.com/&#34;&gt;Aggregated Awesome&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;GitHub 上面有很多 awesome 的仓库，收集某个主题的所有有用的内容。这个网页整理了一个 awesome 仓库的清单。&lt;/p&gt;
&lt;h3 id=&#34;fuel-collectionhttpsappignitionroboticsorggoogleresearchfuelcollectionsgoogle-scanned-objects&#34;&gt;[Fuel Collection](&lt;a href=&#34;https://app.ignitionrobotics.org/GoogleResearch/fuel/collections/Google&#34;&gt;https://app.ignitionrobotics.org/GoogleResearch/fuel/collections/Google&lt;/a&gt; Scanned Objects)&lt;/h3&gt;
&lt;p&gt;谷歌对大量日常物品进行了 3D 扫描，将数据放在网上，提供公开下载。&lt;/p&gt;
&lt;h3 id=&#34;prime-curioshttpsprimesutmeducurios&#34;&gt;&lt;a href=&#34;https://primes.utm.edu/curios/&#34;&gt;Prime Curios!&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个网站收集各种与质数相关的数字，比如 561 的平方加2和减2会得到两个连续的质数。&lt;/p&gt;
&lt;h3 id=&#34;顶级域名列表httpdataianaorgtldtlds-alpha-by-domaintxt&#34;&gt;&lt;a href=&#34;http://data.iana.org/TLD/tlds-alpha-by-domain.txt&#34;&gt;顶级域名列表&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;互联网号码分配局（IANA）官方的目前所有顶级域名（TLD）的列表，共有1508个。如果排除国家和地区的 TLD，则为1260个。&lt;/p&gt;
&lt;h3 id=&#34;如何写一个简单的-c-语言解释器httpsgithubcomlotaboutwrite-a-c-interpretertreemastertutorialen&#34;&gt;&lt;a href=&#34;https://github.com/lotabout/write-a-C-interpreter/tree/master/tutorial/en&#34;&gt;如何写一个简单的 C 语言解释器&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个英语教程，通过写一个简单的 C 语言解释器，理解编译原理。&lt;/p&gt;
&lt;h3 id=&#34;webrtc-示例仓库httpswebrtcgithubiosamples&#34;&gt;&lt;a href=&#34;https://webrtc.github.io/samples/&#34;&gt;WebRTC 示例仓库&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WebRTC 是浏览器点对点通信的 API，这个仓库给出了各种使用示例，覆盖了主要的使用场景。&lt;/p&gt;
&lt;h3 id=&#34;黑河-腾冲线httpszhwikipediaorgwiki黑河-腾冲线&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%BB%91%E6%B2%B3-%E8%85%BE%E5%86%B2%E7%BA%BF&#34;&gt;黑河-腾冲线&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;中国地图上，从黑河到腾冲画一条线，这条线以东住着全国94%的人口。这是1935年由地理学家胡焕庸首次提出。&lt;/p&gt;
&lt;h3 id=&#34;内卷化是什么&#34;&gt;内卷化是什么？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;“内卷化，指一种社会或文化模式在某一发展阶段达到一种确定的形式后，便停滞不前或无法转化为另一种高级模式的现象。”（&lt;a href=&#34;https://baike.baidu.com/item/%E5%86%85%E5%8D%B7%E5%8C%96&#34;&gt;百度百科&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网上说，这个词是美国人首先提出的，英语单词是 involution，出自1960年的一本著作《农业内卷化——印度尼西亚的生态变化过程》（Agricultural Involution）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/43670d57cc2dda62be2c511252673eb480023b1d/68747470733a2f2f7777772e77616e67626173652e636f6d2f626c6f67696d672f61737365742f3230323030392f6267323032303039313930342e6a7067&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;Involution 是一个很罕见的英语单词，平时用得很少，小型词典都不收，维基百科甚至都没有加入“发展停滞”这个涵义，反而是中国人比较多用“内卷化”这个概念。&lt;/p&gt;
&lt;p&gt;虽然不熟悉 involution，但是我想起另外两个常用词：evolution（进化）和 revolution（革命）。它们共同的词根&lt;code&gt;volute&lt;/code&gt;，拉丁语原意是“滚动”。&lt;/p&gt;
&lt;p&gt;有了“滚动”这个词根，这些词的含义就比较清楚了。&lt;code&gt;evolution&lt;/code&gt;的前缀是&lt;code&gt;ex-&lt;/code&gt;（“向外的”），向外滚动就是进化；&lt;code&gt;revolution&lt;/code&gt;的前缀是&lt;code&gt;re-&lt;/code&gt;（“再次的”），再次滚动、颠覆现状就是革命；&lt;code&gt;involution&lt;/code&gt;的前缀是&lt;code&gt;in-&lt;/code&gt;（“向内的”），向内滚动当然就是内卷了。&lt;/p&gt;
&lt;p&gt;我现在对“内卷化”的理解是， &lt;strong&gt;当一个组织不能或不愿向外发展时，成员的精力就只好用到组织内部，这时就会出现“内卷化”，也就是内部的过度发展。&lt;/strong&gt; 举例来说，海上的一艘船，外卷化就是大家齐心协力划向对岸，内卷化就是大家心思不在划船，而放在内部的互相牵扯（组织建设、规章制度、人事安排等等）。&lt;/p&gt;
&lt;p&gt;一旦出现“内卷化”，对外的扩张和发展就停滞了。希望我们国家继续“外卷化”，不要出现“内卷化”。&lt;/p&gt;
&lt;h3 id=&#34;板书的直播方法httpsmothershipsg202009cd-zoom-hack-camera-teacher&#34;&gt;&lt;a href=&#34;https://mothership.sg/2020/09/cd-zoom-hack-camera-teacher/&#34;&gt;板书的直播方法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;疫情期间，老师们都通过网络直播进行教学。但是，摄像头都是拍人脸，直播板书非常困难。美国一个老师想出了简单的解决方法，她在笔记本盖子上，用胶纸绑了一支铅笔，然后以铅笔作为支柱，放了一张 CD 碟片，当作反光的镜子。&lt;/p&gt;
&lt;p&gt;她把本子放在键盘上做笔记，内容就会通过 CD 碟片反射到摄像头，从而直播出去。&lt;/p&gt;
&lt;h3 id=&#34;a-picture-of-java-in-2020httpsblogjetbrainscomidea202009a-picture-of-java-in-2020&#34;&gt;&lt;a href=&#34;https://blog.jetbrains.com/idea/2020/09/a-picture-of-java-in-2020/&#34;&gt;A Picture of Java in 2020&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;IntelliJ IDEA 的最新调查发现，中国有51%的程序员使用 Java 语言，这个比例全球最高。由于 Java 主要是大中型企业在用，这是不是说明，中国的个人开发者和小企业程序员其实比例很小？&lt;/p&gt;
&lt;h3 id=&#34;vscode-如何调试可视化数据结构httpsaddyosmanicomblogvisualize-data-structures-vscode&#34;&gt;&lt;a href=&#34;https://addyosmani.com/blog/visualize-data-structures-vscode/&#34;&gt;VSCode 如何调试可视化数据结构&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;VSCode 有一个插件，可以用可视化的方式调试代码。本文介绍这个插件的用法。&lt;/p&gt;
&lt;h3 id=&#34;cs107e-树莓派arm-和操作系统httpscjtingme20200911cs107e-review&#34;&gt;&lt;a href=&#34;https://cjting.me/2020/09/11/cs107e-review/&#34;&gt;CS107e: 树莓派，ARM 和操作系统&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;CS107e 是斯坦福大学的一门计算机课程，内容关于硬件、底层和 C 语言 。这篇文章是作者的学习感受&lt;/p&gt;
&lt;h3 id=&#34;我如何使用-netlify-的-serverless-功能httpsttntmmeblogserverless-recipes-app-faunadb-vuejs&#34;&gt;&lt;a href=&#34;https://ttntm.me/blog/serverless-recipes-app-faunadb-vuejs/&#34;&gt;我如何使用 Netlify 的 Serverless 功能&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作者介绍他如何开发一个没有后端服务器、只有前端静态网页的 Web 数据库应用。&lt;/p&gt;
&lt;h3 id=&#34;谷歌搜索的10个小技巧httpsmediumcomshalithasuranga10-hidden-features-in-google-search-83b347b48157&#34;&gt;&lt;a href=&#34;https://medium.com/@shalithasuranga/10-hidden-features-in-google-search-83b347b48157&#34;&gt;谷歌搜索的10个小技巧&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;谷歌搜索有很多小功能，比如搜索&lt;code&gt;stopwatch&lt;/code&gt;会出现一个倒计时器&lt;/p&gt;
&lt;h3 id=&#34;中国大周期httpsfinancesinacomcnchinagncj2020-09-21doc-iivhvpwy8038347shtml&#34;&gt;&lt;a href=&#34;https://finance.sina.com.cn/china/gncj/2020-09-21/doc-iivhvpwy8038347.shtml&#34;&gt;中国大周期&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;桥水基金创始人瑞·达利欧（Ray Dalio）的长文，以一个美国人的角度，谈了他对中国历史和经济政策的理解。这里是中文摘译版，也有&lt;a href=&#34;https://www.principles.com/the-changing-world-order/#chapter5&#34;&gt;英文原版&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;github-仓库的默认分支不叫master了httpswwwjiqizhixincomarticles2020-09-21-10&#34;&gt;&lt;a href=&#34;https://www.jiqizhixin.com/articles/2020-09-21-10&#34;&gt;GitHub 仓库的默认分支不叫“master”了&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;从 2020 年 10 月 1 日开始，GitHub 所有新库的默认分支都将用中性词“main”命名，取代原来的“master”。&lt;/p&gt;
&lt;h3 id=&#34;javascript-原生的日期和时间格式化httpselijahmanorcomblogformat-js-dates-and-times&#34;&gt;&lt;a href=&#34;https://elijahmanor.com/blog/format-js-dates-and-times&#34;&gt;JavaScript 原生的日期和时间格式化&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;通常使用外部库处理 JavaScript 的时间格式，但是原生的&lt;code&gt;Date.prototype.toLocale*&lt;/code&gt;方法其实也能满足需求。&lt;/p&gt;
&lt;h3 id=&#34;如何使用-canvas-模拟对象碰撞httpsjoshbradleymeobject-collisions-with-canvas&#34;&gt;&lt;a href=&#34;https://joshbradley.me/object-collisions-with-canvas/&#34;&gt;如何使用 Canvas 模拟对象碰撞&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本文从头教你在网页上，用 Canvas 做出对象不断碰撞的动画效果。&lt;/p&gt;
&lt;h3 id=&#34;instantpagehttpsinstantpage&#34;&gt;&lt;a href=&#34;https://instant.page/&#34;&gt;instant.page&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 JavaScript 库，用户鼠标悬停在某个链接上方时，就自动加载该链接，从而加快页面跳转的速度。&lt;/p&gt;
&lt;h3 id=&#34;toonifyhttpstoonifyjustinpinkneycom&#34;&gt;&lt;a href=&#34;https://toonify.justinpinkney.com/&#34;&gt;Toonify&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个在线工具，可以将真人头像变成卡通头像。&lt;/p&gt;
&lt;h3 id=&#34;advanced-rest-clienthttpsinstalladvancedrestclientcominstall&#34;&gt;&lt;a href=&#34;https://install.advancedrestclient.com/install&#34;&gt;Advanced Rest Client&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 Rest API 测试工具，基于 Electron 的跨平台桌面软件。&lt;/p&gt;
&lt;h3 id=&#34;kbhttpsgithubcomgnebbiakb&#34;&gt;&lt;a href=&#34;https://github.com/gnebbia/kb&#34;&gt;kb&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个极简的命令行笔记管理软件。&lt;/p&gt;
&lt;h3 id=&#34;kivyhttpsgithubcomkivykivy&#34;&gt;&lt;a href=&#34;https://github.com/kivy/kivy&#34;&gt;Kivy&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个 Python 的 UI 框架，可以打包成 Windows、Linux、MacOS、 Android 和 iOS 应用，特别为多点触摸设备而设计。&lt;/p&gt;
&lt;h3 id=&#34;openglcamera2httpsgithubcomgithubhaohaoopenglcamera2&#34;&gt;&lt;a href=&#34;https://github.com/githubhaohao/OpenGLCamera2&#34;&gt;OpenGLCamera2&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个安卓相机 App 的源码，使用 OpenGL ES 3.0 实现 30 种相机滤镜。&lt;/p&gt;
&lt;h3 id=&#34;twister-oshttpstwisteroscom&#34;&gt;&lt;a href=&#34;https://twisteros.com/&#34;&gt;Twister OS&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个树莓派的操作系统，可以让桌面变得像 MacOS 或 Windows。&lt;/p&gt;
&lt;h3 id=&#34;things-come-aparthttpswwwtoddmclellancomthingscomeapart&#34;&gt;&lt;a href=&#34;https://www.toddmclellan.com/thingscomeapart&#34;&gt;Things come apart&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个艺术项目，将各种东西拆开，零件放在一起，做成一张海报。&lt;/p&gt;
&lt;h3 id=&#34;一页-pythonhttpdamiantgordoncompythonmonday&#34;&gt;&lt;a href=&#34;http://damiantgordon.com/PythonMonday/&#34;&gt;一页 Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个英文的 Python 初学者教程，特点是每一讲的讲义都只有一页 A4 纸。&lt;/p&gt;
&lt;h3 id=&#34;吉布力动画图片httpwwwghiblijpinfo013344&#34;&gt;&lt;a href=&#34;http://www.ghibli.jp/info/013344/&#34;&gt;吉布力动画图片&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;吉布力工作室在官网上放出了8部影片的动画图片下载，一共400张。&lt;/p&gt;
&lt;h3 id=&#34;暴力破解密码所需的时间httpsdiggcom2020password-difficulty-hacking&#34;&gt;&lt;a href=&#34;https://digg.com/2020/password-difficulty-hacking&#34;&gt;暴力破解密码所需的时间&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;下表列出了暴力破解各种密码所需的时间。标题行的各栏依次为，纯数字密码、小写字母密码、字母密码、数字字母密码、数字字母符号密码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/fe1b9b2328339ed865d9a29ef3f2111b1ef2a847/68747470733a2f2f7777772e77616e67626173652e636f6d2f626c6f67696d672f61737365742f3230323030392f6267323032303039313332322e6a7067&#34; alt=&#34;TIME&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;第一个魔方rubiks-cubehttpswwwnytimescom20200916bookserno-rubik-rubiks-cube-inventor-cubedhtml&#34;&gt;&lt;a href=&#34;https://www.nytimes.com/2020/09/16/books/erno-rubik-rubiks-cube-inventor-cubed.html&#34;&gt;第一个魔方Rubik&amp;rsquo;s cube&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;1974年，匈牙利建筑学教授 Erno Rubik，发明了魔方，当时他30岁。&lt;/p&gt;
&lt;p&gt;下图就是他的第一个魔方，是用木头做的。为了识别，有的方块缺了一个圆圈，有的方块贴了白纸，有的方块缺了一个角……&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/cf3ef5fb79a7815d464b2b6c4bbbde82c7aae026/68747470733a2f2f7777772e77616e67626173652e636f6d2f626c6f67696d672f61737365742f3230323030392f6267323032303039313731322e6a7067&#34; alt=&#34;Rubik&amp;rsquo;s cube&#34;&gt;&lt;/p&gt;
- https://www.openheart.icu/cs/interesting/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Oracle</title>
        <link>https://www.openheart.icu/cs/oracle/</link>
        <pubDate>Tue, 21 Jul 2020 20:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/oracle/</guid>
        <description>42th openheart https://www.openheart.icu/cs/oracle/ -&lt;h1 id=&#34;common-operation&#34;&gt;Common Operation&lt;/h1&gt;
&lt;h2 id=&#34;删除操作前一定要先执行一遍查询&#34;&gt;删除操作前一定要先执行一遍查询&lt;/h2&gt;
&lt;p&gt;如题， 带的一个新员工做补丁把项目历史数据干掉了 My bad.&lt;/p&gt;
&lt;p&gt;2020-8-7&lt;/p&gt;
&lt;h1 id=&#34;optimize&#34;&gt;Optimize&lt;/h1&gt;
&lt;h2 id=&#34;索引失效&#34;&gt;索引失效&lt;/h2&gt;
&lt;p&gt;SQL在&lt;code&gt;WHERE&lt;/code&gt;条件里面使用了&lt;code&gt;IN&lt;/code&gt;导致有一个关联表的索引失效，Oracle版本为11g&lt;/p&gt;
&lt;p&gt;条件中有or，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引&lt;/p&gt;
&lt;p&gt;like查询是以%开头&lt;/p&gt;
&lt;p&gt;如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引&lt;/p&gt;
&lt;h2 id=&#34;分库-分表-分区&#34;&gt;分库 分表 分区&lt;/h2&gt;
&lt;h2 id=&#34;视图优化&#34;&gt;视图优化&lt;/h2&gt;
&lt;h3 id=&#34;基表增加索引&#34;&gt;基表增加索引&lt;/h3&gt;
&lt;p&gt;对基表中，视图查询SQL的&lt;code&gt;WHERE&lt;/code&gt;条件中用到的字段增加索引&lt;/p&gt;
&lt;h3 id=&#34;重新进行表分析&#34;&gt;重新进行表分析&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;-- 视图查询慢
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;

&lt;span style=&#34;color:#228b22&#34;&gt;-- 在当前用户下执行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;analyze table &amp;#39;&lt;/span&gt;||&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;||&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; compute statistics;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;IN&lt;/span&gt; (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;tablename&amp;#39;&lt;/span&gt;);   

&lt;span style=&#34;color:#228b22&#34;&gt;-- 得到如下语句，将这些语句整体执行一遍
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; PRODUCT_REF_LIST_NESTEDTAB compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#228b22&#34;&gt;-- ....
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;-- 查看统计信息
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;,num_rows &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分析的结果被Oracle用于基于成本的优化生成更好的查询计划。&lt;/p&gt;
&lt;p&gt;遇到当前表的查询或其他性能不好时，就可以对相应的表进行一次分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你的表经常由几千万变成几百万，又变成几千万那么需要制定分析计划定期表分析，同时可以一并分析索引，计算索引中数据的分布情况，这样CBO会选择更加准确的执行计划。&lt;/li&gt;
&lt;li&gt;如果表结构变化了也要做下，也就是经常对表做dml就需要分析，现在推荐使用dbms_stats包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;error&#34;&gt;ERROR&lt;/h1&gt;
&lt;h2 id=&#34;ora-01779-无法修改与非键值保存表对应的列&#34;&gt;ORA-01779: 无法修改与非键值保存表对应的列&lt;/h2&gt;
&lt;p&gt;这里要搞清楚三个概念：视图、联接视图、可更新的联接视图&lt;/p&gt;
&lt;h3 id=&#34;视图&#34;&gt;视图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;视图&lt;/strong&gt;可以分为视图对象和内嵌视图两种。&lt;/p&gt;
&lt;h4 id=&#34;视图对象view-object&#34;&gt;视图对象（View Object）&lt;/h4&gt;
&lt;p&gt;数据库里的&lt;strong&gt;视图对象&lt;/strong&gt;跟一张表或索引等一样，是数据库对象中的一种，它其实是将基于表中原始数据的查询给虚拟了一层之后，提供给外部查询的一种对象。
其本质是并不保存查询的实际结果，而只是将查询语句保存在数据库中，当用户查询某张视图的时候，就会找到并执行这个视图的语句。
而&lt;strong&gt;联接视图&lt;/strong&gt;其实就是在一个视图中将两个表建立关联就是了。&lt;/p&gt;
&lt;h4 id=&#34;内嵌视图inline-view&#34;&gt;内嵌视图（Inline View）&lt;/h4&gt;
&lt;p&gt;在SQL语句中，很多地方都可以写嵌套的语句，比如说，FROM后面可以套括号嵌套其他的语句，WHERE、SELECT、UPDATE、INSERT、DELETE后面都是可以写的。只是写的位置不同，执行的方式还有处理时的一些限制不同，这些SQL中嵌套的SQL被称为&lt;strong&gt;子查询（Subquery）&lt;/strong&gt; 。子查询可以分为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内嵌视图：位置位于FROM语句中，也相当于一个预处理结果集的概念&lt;/li&gt;
&lt;li&gt;标量子查询（Scalar Subquery）：只返还一个结果值的子查询。位于SELECT语句的子查询只能返还一个值，所以必然是标量子查询，WHERE语句里也会出现这样的子查询&lt;/li&gt;
&lt;li&gt;关联子查询：将查询的结果传递给子查询作为参数的使用的形式&lt;/li&gt;
&lt;li&gt;一般子查询：除了那些特殊形式的子查询以外的一般用法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;可更新联接视图updatable-join-view-&#34;&gt;可更新联接视图（Updatable Join View ）&lt;/h4&gt;
&lt;p&gt;将一个联接视图（包括视图对象和内嵌视图）放到UPADTE语句中这样的语法形式。&lt;/p&gt;
&lt;p&gt;同样的道理，如果只是用一个表来作为视图的基表，则可以对该视图直接进行&lt;code&gt;DELETE&lt;/code&gt;和&lt;code&gt;UPDATE&lt;/code&gt;，但无法直接执行&lt;code&gt;INSERT&lt;/code&gt;，因为该视图没有默认值的非空列(&lt;code&gt;brand_id&lt;/code&gt;)。该视图称为&lt;strong&gt;可更新视图&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;报错原理&#34;&gt;报错原理&lt;/h3&gt;
&lt;p&gt;Oracle的键值保存表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; *
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; DBA_UPDATABLE_COLUMNS
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;SCOTT&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;EMP_DEPT_V&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COLUMN_NAME&lt;/span&gt; | UPDATABLE | INSERTABLE | DELETABLE
SCOTT   EMP_DEPT_V     EMPNO            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     ENAME            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     SAL              &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     DEPTNO           &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     DNAME            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;视图&lt;code&gt;EMP_DEPT_V&lt;/code&gt;里的字段都无法变更。&lt;/p&gt;
&lt;p&gt;如果能保证DEPT_T表里的数据是唯一的就能够更新。也就是说在DEPT_T表上加&lt;code&gt;主键约束&lt;/code&gt;或&lt;code&gt;唯一约束&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; DEPT_T
     &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ADD&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;CONSTRAINT&lt;/span&gt; PK_DEPT_T &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;KEY&lt;/span&gt; (DEPTNO);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再看一下之前的视图：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; *
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; DBA_UPDATABLE_COLUMNS
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;SCOTT&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;EMP_DEPT_V&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COLUMN_NAME&lt;/span&gt; | UPDATABLE | INSERTABLE | DELETABLE
SCOTT   EMP_DEPT_V     EMPNO            YES         YES         YES
SCOTT   EMP_DEPT_V     ENAME            YES         YES         YES
SCOTT   EMP_DEPT_V     SAL              YES         YES         YES
SCOTT   EMP_DEPT_V     DEPTNO           YES         YES         YES
SCOTT   EMP_DEPT_V     DNAME             &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个时候就可以看到，视图中&lt;code&gt;EMP_DEPT_V&lt;/code&gt;表中原来的字段都是可以更新的了。&lt;/p&gt;
&lt;p&gt;在对联接视图进行变更的时候，必须保证修改后的值是唯一的，并且这个事实要让数据库知道，而告知数据库的方法是建立主键约束或唯一约束。&lt;/p&gt;
&lt;p&gt;并不是所有的表都可以随意建这些约束，有什么方法能够不添加约束也能变更？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加&lt;code&gt;/*+ BYPASS_UJVC */&lt;/code&gt; 提示，让ORACLE跳过检查（11g R2之后无效，不建议使用）&lt;/li&gt;
&lt;li&gt;改写&lt;code&gt;UPDATE&lt;/code&gt;语句，通过其他方式判断后处理&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;UPDATE&lt;/code&gt;改成&lt;code&gt;MERGE&lt;/code&gt;语句&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Oracle：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The concept of a &lt;strong&gt;key-preserved table&lt;/strong&gt; is fundamental to understanding the restrictions on &lt;strong&gt;modifying join views&lt;/strong&gt;. A table is key-preserved if every key of the table can also be a key of the result of the join. So, a key-preserved table has its keys preserved through a join.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;An &lt;strong&gt;updatable join view&lt;/strong&gt; (also referred to as a &lt;strong&gt;modifiable join view&lt;/strong&gt;) is a view that contains multiple tables in the top-level FROM clause of the SELECT statement, and is not restricted by the WITH READ ONLY clause.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/60a56760b19f&#34;&gt;https://www.jianshu.com/p/60a56760b19f&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.yiibai.com/oracle/oracle-updatable-view.html&#34;&gt;https://www.yiibai.com/oracle/oracle-updatable-view.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://www.openheart.icu/cs/oracle/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Speech</title>
        <link>https://www.openheart.icu/cs/speech/</link>
        <pubDate>Tue, 21 Jul 2020 19:45:28 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/speech/</guid>
        <description>42th openheart https://www.openheart.icu/cs/speech/ -&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;唯一不适应远程工作的是中层管理人员。&lt;/p&gt;
&lt;p&gt;基层员工对于在家工作感到很高兴，只要把活做好就可以了。高层管理人员只需要对销售和产量数字负责。中层管理人员的不适应在于，他们的职责是直接监控基层员工，最常用的判断方法是通过是否坐在座位上等迹象，来判断工作量和工作是否勤奋。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=23607203&#34;&gt;Hacker news 读者&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我有一种反英雄主义的精神。以前看电视时，我就对皇帝和将军不感兴趣，觉得他们已经有荣耀和风光了。&lt;/p&gt;
&lt;p&gt;我更关心皇帝和将军手下的那些小兵，有时战斗刚开始，他们就被杀死了。他们脑海里想的是什么？会有人记得他们，为他们哭泣吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 黄西自传《黄瓜的黄，西瓜的西》&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;时钟和镜子改变了人类社会。&lt;/p&gt;
&lt;p&gt;时钟创造了一种焦虑文化。&lt;/p&gt;
&lt;p&gt;镜子创造了一种自恋文化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; David Perell&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;100年前的中国，四千个人里面才有一个中学生，其他都是文盲。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 李敖&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;看到抽象的东西，应该尽量使它变得具体；看到具体的东西，应该尽量使它变得抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 李敖&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你花钱买，你就是客户，如果你免费获得，你就是产品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.wired.com/story/a-startup-is-testing-the-subscription-model-for-search-engines/&#34;&gt;《创业公司尝试搜索引擎的订阅模式》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;40年前算法很重要，大部分程序员都需要懂，因为硬件差，必须靠算法保证性能。&lt;/p&gt;
&lt;p&gt;但是今天只剩下不到1%的程序员直接跟算法打交道，其他人都使用现成的软件包，或从大公司购买算法，算法已成为一种商品，普通程序员不再需要自己生产了，也不需要有很深入的了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;http://shape-of-code.coding-guidelines.com/2020/07/05/algorithms-are-now-commodities/&#34;&gt;《算法现在是商品》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;本站100%无 JavaScript。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.swiftbysundell.com/special/javascript-free/&#34;&gt;swiftbysundell.com&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我希望 JavaScript 程序员、Java 程序员、PHP 程序员、Perl 程序员、Python 程序员、C 程序员、C ++ 程序员、以及其他重要语言的程序员，大家聚在一起开个会，一劳永逸地提出一个大家都遵守的解决方案，我们应该如何处理时间和日期。我厌倦了每个语言都有自己一套处理时间和日期的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=23781819&#34;&gt;《JavaScript 语言准备提出新的时间和日期 API》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;至少12年 Kubernetes 经验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Required Technical and Professional Expertise&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Minimum 12+ years’ experience in Kubernetes administration and management&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; IBM 招聘云工程师的&lt;a href=&#34;https://intellijobs.ai/job/IBMCloud-Native-Infrastructure-Engineer-Architect-bvJJ6yraexfWOk1nMRKP-bvJJ6yraexfWOk1nMRKP&#34;&gt;公告&lt;/a&gt;，但 Kubernetes 是2014年发布的。&lt;/p&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;一家公司获得垄断地位以后，就不需要从任何形式的产品开发获益了，只通过市场营销或金融工程就能增加利润。最终，公司就会被销售人员和财务人员控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 史蒂夫·乔布斯&lt;/p&gt;
&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;锚定偏差（anchoring bias）指的是决策时严重依赖第一个可用的信息。&lt;/p&gt;
&lt;p&gt;比如，你走进一家体育用品商店，发现的第一件商品，是一条价值500美元的运动裤。接着，你看到另一条价格为300美元的运动裤时，就会觉得它很便宜，实际上如果首先看到这条300美元的裤子，你会觉得它根本不便宜。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://models.substack.com/p/why-are-we-anchored-often&#34;&gt;《锚定偏差》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;信息成瘾指的是强迫性信息消费：明明已经看完所有内容，你仍在继续滚动浏览 Facebook；你刚刚关闭 Instagram，立即再次打开它；你每五分钟拿起手机，检查有没有新的通知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.defetter.com/&#34;&gt;《什么是信息成瘾》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;14&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;谷歌的网页排名算法 PageRank，得名于创始人拉里·佩奇（ Larry Page），实际含义是佩奇的算法（Page&amp;rsquo;s rank）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://notes.rolandcrosby.com/posts/unexpectedly-eponymous/&#34;&gt;《意想不到的来自人名的事物》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;低本底钢（Low-background steel）指的是1945年第一枚核弹爆炸之前生产的任何钢铁。此后有了核爆，大气中辐射物质增加，影响了所生产的所有钢铁。&lt;/p&gt;
&lt;p&gt;低本底钢目前用于需要最高灵敏度的放射性核检测设备中，主要来源是在第一次核爆发生前建造的船只，它们大多沉没在水底。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://en.wikipedia.org/wiki/Low-background_steel&#34;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;16&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我一直是“强观点，弱立场”（strong opinions, weakly held）。&lt;/p&gt;
&lt;p&gt;不管什么事情，我都会凭直觉得到一个结论，这就是“强观点”；只要有任何与结论相悖的信息，我就会修正自己的观点，这就是“弱立场”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://commoncog.com/blog/strong-opinions-weakly-held-is-bad/&#34;&gt;《强观点，弱立场》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;17&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;几乎所有的企业软件公司，都是销售人员多于工程人员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=23907923&#34;&gt;Hacker News 读者&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;18&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;地球与火星之间的通讯大约需要40分钟，发出一条指令，40分钟以后才能收到，这意味着火星登陆器必须高度自动化，具有自主决策的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://thediplomat.com/2020/07/why-is-china-going-to-mars/&#34;&gt;《中国为什么想去火星》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;19&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;女：你觉得怎样才是“完美的约会”（the perfect date）？&lt;/p&gt;
&lt;p&gt;男： DD/MM/YYYY，别的日期格式（date format）都容易产生误会。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://twitter.com/rafrasenberg/status/1286968074323865602&#34;&gt;推特&lt;/a&gt;。英语里面，约会和日期是同一个词&lt;code&gt;date&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;20&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;REST 和 GraphQL 的最大区别是处理缓存的方式。&lt;/p&gt;
&lt;p&gt;当你用 REST 方式构建 API 时，基本上可以自动获得 HTTP 的缓存能力。如果选择 GraphQL，你就需要自己为客户端或应用程序添加缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.stxnext.com/blog/how-to-build-a-good-api-that-wont-embarrass-you&#34;&gt;《如何构建优秀 API》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;21&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;不要轻易说出自己痛苦，能体会的人很少，看热闹的人很多。&lt;/p&gt;
&lt;p&gt;也不要轻易炫耀，会替你感到高兴的人很少，等着看你最后下场的人很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 推特用户&lt;/p&gt;
&lt;ol start=&#34;22&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;所谓完美，不是指不能再添加别的东西了，而是指没有东西可以从其中拿掉了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.brainyquote.com/quotes/antoine_de_saintexupery_103610&#34;&gt;安托万·德圣埃克絮佩里&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;23&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;公司刚成立时，需要瑞士军刀型人才。&lt;/p&gt;
&lt;p&gt;公司一旦发展壮大，需要菜刀型人才。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; David Perell&lt;/p&gt;
&lt;ol start=&#34;24&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;硬件总是变得越来越快，但软件总是变得越来越慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://en.wikipedia.org/wiki/Wirth&#39;s_law&#34;&gt;维尔斯定律&lt;/a&gt;（Wirth&amp;rsquo;s law）&lt;/p&gt;
&lt;ol start=&#34;25&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;SSD 固态硬盘变成主流，导致 Windows 10 在 HDD 机械硬盘上几乎无法使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=24015218&#34;&gt;Hacker News 读者&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;26&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Web 和浏览器已经发展到令人恐怖的技术规模。微软完全放弃了，Mozilla 在死亡线上挣扎，Safari 根本无足轻重，只剩下 Google 一个玩家。&lt;/p&gt;
&lt;p&gt;我呼吁谷歌立即无限期地中止向 Web 和浏览器添加新 API。浏览器实际上应该开始考虑缩小 API 并削减功能，更关注性能、效率、可靠性和安全性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://drewdevault.com/2020/08/13/Web-browsers-need-to-stop.html&#34;&gt;《Web 需要停下来》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;27&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;无知的一阶效应包括做出错误的决定，二阶效应包括不了解决定为何错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://unintendedconsequenc.es/tiktok-ban-openness-trap/&#34;&gt;unintended consequences&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;28&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;物理学家狄拉克（Dirac）沉默寡言，回答别人时经常只用一个单词。他顽皮的同事们引入了一种新的度量单位，测量人类的语速，就叫做Dirac，每小时只说一个词即为一个 Dirac。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://theconversation.com/the-life-changing-love-of-one-of-the-20th-centurys-greatest-physicists-51229&#34;&gt;《狄拉克的恋爱》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;29&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;制作一加仑糖浆需要50加仑的果汁，表达也是这样，你要把想法以压缩后的形式展示出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.perell.com/blog/expression-is-compression&#34;&gt;《表达就是压缩》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;30&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我们公司是一家历史悠久的 IT 公司。人力资源部门的反馈表明，我们很难挽留年轻员工，因为他们不想使用旧系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=24230266&#34;&gt;Hacker News 读者&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;31&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;架构师的工作不是做出决策，而是尽可能久地推迟决策，先在不做出重大决策的情况下构建程序，以便以后有足够信息时再做出决策。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://tomgamon.com/posts/2020-08-25-dont-marry-your-design/&#34;&gt;Bob Martin&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;32&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;公钥加密已经发明40多年了，但是我们仍然把魔术数字印在信用卡上，任何看到它们的人都可以未经授权拿走我们所有的钱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=24277899&#34;&gt;Hacker News 读者&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;33&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我加入谷歌，是因为需要更多钱；离开谷歌，是因为需要更多时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://theartofmachinery.com/2020/08/04/leaving_google.html&#34;&gt;《离开谷歌的这五年》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;34&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果微软推出容器服务，有些人是不会买的。但是，GitHub 的容器服务，他们就会买。我认为，这就是微软收购 GitHub 的部分原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://news.ycombinator.com/item?id=24346163&#34;&gt;Hacker News 读者&lt;/a&gt;评论 &lt;a href=&#34;https://github.blog/2020-09-01-introducing-github-container-registry/&#34;&gt;GitHub 推出容器仓库服务&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;45&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;贫民窟里的人已经睡眠静了。对面日新里的一排临邓脱路的洋楼里，还有几家点着了红绿的电灯，在那里弹罢拉拉衣加。一声二声清脆的歌音，带着哀调，从静寂的深夜的冷空气里传到我的耳膜上来，这大约是俄国的飘泊的少女，在那里卖钱的歌唱。天上罩满了灰白的薄云，同腐烂的尸体似的沉沉的盖在那里。云层破处也能看得出一点两点星来，但星的近处，黝黝看得出来的天色，好像有无限的哀愁蕴藏着的样子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 郁达夫《春风沉醉的晚上》&lt;/p&gt;
&lt;ol start=&#34;46&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;军队为什么要实行军衔制度？这是为了部队被打散，临时拼建时，能够迅速确定指挥关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 维基百科&lt;/p&gt;
&lt;ol start=&#34;47&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我辞职不是因为收入，也不是因为人际关系，而是因为我觉得自己被困住了，没有增长的空间了。公司的业务离当前行业的技术发展越来越远，让我作为开发人员感到非常痛苦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash;&lt;a href=&#34;https://stitcher.io/blog/dont-get-stuck&#34;&gt;《不要被困住》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;48&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;让一只猴子在打字机上随机按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全部著作。这称为“无限猴子定力”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://en.wikipedia.org/wiki/Infinite_monkey_theorem&#34;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;49&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;苹果公司不允许恶棍在电影中使用 iPhone。因此，如果您正在看一部新电影并且角色拥有 iPhone，那么他们就不是坏人，这算是剧透吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://finance.yahoo.com/news/2020-02-26-rian-johnson-apple-movie-villains-use-iphones-on-came.html&#34;&gt;《苹果和流行文化》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;50&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;2005年，我的毕业论文的《参考书目》部分包含了152个 URL。为了纪念毕业十五周年，我重新检查了这些 URL，其中82个不再起作用。我因此假定，互联网链接的腐烂率是57%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash;&lt;a href=&#34;https://www.lightbluetouchpaper.org/2020/09/03/a-measurement-of-link-rot-57/&#34;&gt;《测量链接腐烂率》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;51&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;互联网软件行业的开发模式，已经从漫长的开发周期和专门的质量保证（QA）阶段，转移到了快节奏的连续集成/连续交付（CI / CD）管道，这样做极大地提高了迭代速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://engineering.linkedin.com/blog/2020/production-testing-with-dark-canaries&#34;&gt;《黑暗金丝雀模式的生产模式》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;52&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;你能在下面的一副扑克牌中，快速找到三个方块的那张牌吗？这就是用户面对大型菜单进行导航时的感受。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/74202f12ef5f086091c1ad42a3bbeb860ffc9ed9/68747470733a2f2f7777772e77616e67626173652e636f6d2f626c6f67696d672f61737365742f3230323030392f6267323032303039313430312e6a7067&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://uxmovement.com/navigation/solving-the-megaton-problem-with-mega-menus/&#34;&gt;《大菜单导航的解决方案》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;53&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;三年前，我们搬到伦敦教书，一直租房住，现在可以买房了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://www.imperial.ac.uk/news/203853/imperial-mathematician-scoops-3m-breakthrough-prize/&#34;&gt;英国马丁·海尔教授&lt;/a&gt;（Martin Hairer）的获奖感言。他获得了今年的数学突破奖，奖金为300万美元，这是目前奖金最高的科学奖项。&lt;/p&gt;
&lt;ol start=&#34;54&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;It is not dead,it is indeed done.(它还没有死，但确实已经写完了)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://momentjs.com/docs/#/-project-status/&#34;&gt;Moment.js&lt;/a&gt; 宣布停止开发，进入维护状态。&lt;/p&gt;
&lt;ol start=&#34;55&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;技术的快速进步，尽管带来了不可预测的后果，但是它让人类站到了更高的地方。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash;&lt;a href=&#34;https://hawaiigentech.com/post/commentary/frogs-wont-let-themselves-be-cooked/&#34;&gt;《时代变化中的技术隐喻》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;56&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;你会在20个方向上走一步，还是在一个方向上走20步？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; 匿名&lt;/p&gt;
&lt;ol start=&#34;57&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;GPT-3 模型就像一个聪明的学生，他没有读完书，试图胡说八道，将一些众所周知的事实、一些真相、一些直率的谎言，编织在一种流畅的叙述中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://syncedreview.com/2020/09%E4%BC%8A%E4%B8%87%E5%B8%95/09/new-multitask-benchmark-suggests-even-the-best-language-models-dont-have-a-clue-what-theyre-doing/&#34;&gt;一个教授&lt;/a&gt;评论 GPT-3 模型可以自动生成人类可读的文本&lt;/p&gt;
&lt;ol start=&#34;58&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;网站需要3种技术，但是由于用到各种工具和框架，最终使我接触了约20种不同的技术，有时还不得不研究第 n 级依赖项的源代码。&lt;/p&gt;
&lt;p&gt;这就是我不喜欢现代 Web 开发的地方，你想使用三个工具，但是必须知道如何使用二十个工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash; &lt;a href=&#34;https://css-tricks.com/weaved-webs/&#34;&gt;《编织在一起的 Web》&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;59&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Conway&amp;rsquo;s law&lt;/strong&gt;：设计系统的架构受制于产生这些设计的组织的沟通结构。&amp;ndash;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E6%96%87%C2%B7%E5%BA%B7%E5%A8%81&#34;&gt;马尔文·康威&lt;/a&gt;1967&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization&amp;rsquo;s communication structure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;ndash;  Melvin E. Conway&lt;/p&gt;
- https://www.openheart.icu/cs/speech/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>剑指 Offer 46. 把数字翻译成字符串</title>
        <link>https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/</link>
        <pubDate>Tue, 21 Jul 2020 19:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/</guid>
        <description>42th openheart https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/ -&lt;h1 id=&#34;把数字翻译成字符串httpsleetcode-cncomproblemsba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/&#34;&gt;把数字翻译成字符串&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是&lt;code&gt;bccfi&lt;/code&gt;, &lt;code&gt;bwfi&lt;/code&gt;, &lt;code&gt;bczi&lt;/code&gt;, &lt;code&gt;mcfi&lt;/code&gt;和&lt;code&gt;mzi&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0 &amp;lt;= num &amp;lt; 2&lt;!-- raw HTML omitted --&gt;31&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;动态规划&#34;&gt;动态规划&lt;/h2&gt;
&lt;p&gt;拿示例看&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先考虑每个数字单独翻译的情况，即翻译&lt;code&gt;[1,2,2,4,8]&lt;/code&gt;，结果为&lt;code&gt;bccfi&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以将数字拼接为两位的情况，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[12,2,4,8]&lt;/code&gt; &lt;code&gt;mcfi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[12,24,8]&lt;/code&gt; &lt;code&gt;mzi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[12,2,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,22,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,22,4,8]&lt;/code&gt; &lt;code&gt;bwfi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,2,24,8]&lt;/code&gt; &lt;code&gt;bczi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1,2,2,48]&lt;/code&gt; 48&amp;gt;25&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;归纳规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以单独作为一位来翻译&lt;/li&gt;
&lt;li&gt;如果第 &lt;code&gt;i−1&lt;/code&gt; 位和第 &lt;code&gt;i&lt;/code&gt; 位组成的数字在 10 到 25 之间，可以把这两位连起来翻译&lt;/li&gt;
&lt;/ul&gt;
- https://www.openheart.icu/arithmetic/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-lcof/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>DNS</title>
        <link>https://www.openheart.icu/cs/dns/</link>
        <pubDate>Sun, 19 Jul 2020 12:50:56 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/dns/</guid>
        <description>42th openheart https://www.openheart.icu/cs/dns/ -&lt;h2 id=&#34;dnspod-dns&#34;&gt;DNSPod DNS+&lt;/h2&gt;
&lt;p&gt;​            首选：119.29.29.29&lt;/p&gt;
&lt;p&gt;​            备选：182.254.116.116&lt;/p&gt;
&lt;h3 id=&#34;114dns&#34;&gt;114DNS&lt;/h3&gt;
&lt;p&gt;​            首选：114.114.114.114&lt;/p&gt;
&lt;p&gt;​            备选：114.114.114.115&lt;/p&gt;
&lt;h3 id=&#34;阿里-alidns&#34;&gt;阿里 AliDNS&lt;/h3&gt;
&lt;p&gt;​            首选：223.5.5.5&lt;/p&gt;
&lt;p&gt;​            备选：223.6.6.6&lt;/p&gt;
&lt;h3 id=&#34;dns派&#34;&gt;DNS派&lt;/h3&gt;
&lt;p&gt;​            首选（电信/移动/铁通）：101.226.4.6&lt;/p&gt;
&lt;p&gt;​            备选（电信/移动/铁通）：218.30.118.6&lt;/p&gt;
&lt;p&gt;​            首选（联通）：123.125.81.6&lt;/p&gt;
&lt;p&gt;​            备选（联通）：140.207.198.6&lt;/p&gt;
&lt;h3 id=&#34;百度-baidudns&#34;&gt;百度 BaiduDNS&lt;/h3&gt;
&lt;p&gt;​            首选：180.76.76.76&lt;/p&gt;
&lt;h3 id=&#34;cnnic-sdns&#34;&gt;CNNIC SDNS&lt;/h3&gt;
&lt;p&gt;​            首选：1.2.4.8&lt;/p&gt;
&lt;p&gt;​            备选：202.98.0.68&lt;/p&gt;
&lt;h3 id=&#34;opendns&#34;&gt;OpenDNS&lt;/h3&gt;
&lt;p&gt;​            208.67.222.222&lt;/p&gt;
&lt;p&gt;​            208.67.220.220&lt;/p&gt;
&lt;p&gt;​            208.67.222.220&lt;/p&gt;
&lt;p&gt;​            208.67.220.222&lt;/p&gt;
&lt;h3 id=&#34;family-shield-servers&#34;&gt;Family Shield Servers&lt;/h3&gt;
&lt;p&gt;可以阻挡成人网站和含有恶意网站&lt;/p&gt;
&lt;p&gt;​            208.67.222.123&lt;/p&gt;
&lt;p&gt;​            208.67.220.123&lt;/p&gt;
&lt;h3 id=&#34;ipv6地址实验&#34;&gt;IPv6地址(实验)&lt;/h3&gt;
&lt;p&gt;​            2620:0:ccc::2&lt;/p&gt;
&lt;p&gt;​            2620:0:ccd::2&lt;/p&gt;
- https://www.openheart.icu/cs/dns/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title> 当面调试</title>
        <link>https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/</link>
        <pubDate>Sat, 18 Jul 2020 10:28:50 +0000</pubDate>
        
        <guid>https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/</guid>
        <description>42th openheart https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/ -&lt;p&gt;当我在被面试的时候我再想些什么？&lt;/p&gt;
- https://www.openheart.icu/boom/%E5%BD%93%E9%9D%A2%E8%B0%83%E8%AF%95/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>.NET INTERVIEW</title>
        <link>https://www.openheart.icu/cs/dot-net-interview/</link>
        <pubDate>Fri, 17 Jul 2020 23:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/dot-net-interview/</guid>
        <description>42th openheart https://www.openheart.icu/cs/dot-net-interview/ -&lt;h1 id=&#34;net-interview&#34;&gt;.NET INTERVIEW&lt;/h1&gt;
&lt;h2 id=&#34;from-jeffrey-zhaos-blog&#34;&gt;from Jeffrey Zhao&amp;rsquo;s blog&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.zhaojie.me/2011/03/my-interview-questions-for-dotnet-programmers.html&#34;&gt;我在面试.NET/C#程序员时会提出的问题&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;什么是net什么是cli什么是clril是什么jit是什么它是如何工作的gc是什么简述一下gc的工作方式&#34;&gt;什么是.NET？什么是CLI？什么是CLR？IL是什么？JIT是什么，它是如何工作的？GC是什么，简述一下GC的工作方式？&lt;/h3&gt;
&lt;h4 id=&#34;什么是net&#34;&gt;什么是.net&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;.NET是个平台，你就把它看成C#&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一个.NET应用是一个运行于.NET Framework之上的应用程序。（更精确的说，一个.NET应用是一个使用.NET Framework类库来编写，并运行于公共语言运行时 Common Language Runtime之上的应用程序。）如果一个应用程序跟.NET Framework无关，它就不能叫做.NET程序。比如，仅仅使用了XML并不就是.NET应用，仅仅使用SOAP SDK调用一个Web Service也不是.NET应用&lt;/p&gt;
&lt;p&gt;开发平台（Dot Net Framework）：包含通用语言运行时（CLR）和Dot Net框架类库（FCL）两个部分。他们提供了一致的编程模型，简化的编程方式，可靠的版本机制（用全局程序集缓存GAC来避免DLL Hell），轻便的部署管理（程序集自带的元数据可以避免ini文件和注册表） ，广泛的平台支持（只要这台机器兼容标准下的CLR和FCL就可以部署，当然运行的时候IL会变成本机代码），无缝的语言集成，自动化的内存管理（垃圾收集），类型安全（CLR会阻止利用缓冲区溢出错误进行的攻击），CLR支持跨语言调试，统一的错误报告，全新的安全策略（CAS），兼容以往的COM组件&lt;/p&gt;
&lt;h4 id=&#34;什么是clr&#34;&gt;什么是CLR&lt;/h4&gt;
&lt;p&gt;CLR(公用语言运行时)和Java虚拟机一样也是一个&lt;strong&gt;运行时环境&lt;/strong&gt;，它负责资源管理（内存分配和垃圾收集），并保证应用和底层操作系统之间必要的分离。.NET Framework 提供了一个称为公共语言运行时的运行时环境**（Commen Language Runtime）**，它运行代码并提供使开发过程更轻松的服务。公共语言运行时的功能通过编译器和工具公开，你可以编写利用此托管执行环境的代码。 使用基于公共语言运行时的语言编译器开发的代码称为托管代码；托管代码具有许多优点，例如：跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。&lt;/p&gt;
&lt;h4 id=&#34;什么是cli&#34;&gt;什么是CLI&lt;/h4&gt;
&lt;p&gt;通用语言基础结构（Common Language Infrastructure，CLI）是CLR的一个子集，也就是.NET中最终对编译成MSIL代码的应用程序的运行环境进行管理的那一部分。在 CLR结构图中CLI位于下半部分，主要包括类加载器(Class Loader)、实时编译器(IL To Native Compilers)和一个运行时环境的垃圾收集器(Garbage Collector)。CLI是.Net和CLR的灵魂，CLI为IL代码提供运行的环境，你可以将使用任何语言编写的代码通过其特定的编译器转换为 MSIL代码之后运行其上，甚至还可以自己写MSIL代码在CLI上面运行。&lt;/p&gt;
&lt;h4 id=&#34;什么是il&#34;&gt;什么是IL&lt;/h4&gt;
&lt;p&gt;IL是微软.NET平台上衍生出来的一门中间语言，.NET平台上的各种高级语言（如C#，VB，F#）的编译器会将各自的文字表述方式转化为 IL。各种不同的文字形式最终被统一到了IL的表述方式，其中包含了.NET平台上的各种元素，如“范型”，“类”、、“接口”、“模块”、“属性”等 等。值得注意的是，各种高级语言本身可能根本没有这些“概念”在里头，如IronScheme是一个在.NET平台上的Scheme语言实现，其中根本没有前面提到的这些IL——亦或说是.NET平台上的名词。IL本身并不知道自己是由哪种高级语言转化而来的，哪种语言中有哪些特性，IL也根本不会关心。&lt;/p&gt;
&lt;h4 id=&#34;什么是jit&#34;&gt;什么是JIT&lt;/h4&gt;
&lt;p&gt;JIT（Just In Time, JIT）是.Net边运行边编译的一种机制。&lt;/p&gt;
&lt;p&gt;开发人员需要通过IL与CLR进行交流，虽然IL本身支持一些面向对象的概念，但是对于开发人员来讲还是过于复杂低效，于是C#应运而生，程序员只需编写C#代码，csc编译器会将其翻译成IL；虽然CLR理解IL，但是CPU只认识二进制指令，所以CLR需要JIT的帮助，将IL翻译成CPU指令. JIT按需工作，当一个.NET方法即将被执行时，JIT会介入，把该方法（IL指令）编译成CPU指令，并保存以供重用。&lt;/p&gt;
&lt;h4 id=&#34;什么是gc以及它的工作方式&#34;&gt;什么是GC，以及它的工作方式&lt;/h4&gt;
&lt;p&gt;GC:.NET Framework 的垃圾回收器管理应用程序的内存分配和释放&lt;/p&gt;
&lt;h5 id=&#34;分配内存&#34;&gt;分配内存&lt;/h5&gt;
&lt;p&gt;初始化新进程时，运行时会为进程保留一个连续的地址空间区域。 这个保留的地址空间被称为托管堆。 托管堆维护着一个指针，用它指向将在堆中分配的下一个对象的地址。 最初，该指针设置为指向托管堆的基址。 托管堆上包含了所有&lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/common-type-system&#34;&gt;引用类型&lt;/a&gt;。 应用程序创建第一个引用类型时，将为托管堆的基址中的类型分配内存。 应用程序创建下一个对象时，垃圾回收器在紧接第一个对象后面的地址空间内为它分配内存。 只要地址空间可用，垃圾回收器就会继续以这种方式为新对象分配空间。&lt;/p&gt;
&lt;p&gt;从托管堆中分配内存要比非托管内存分配速度快。 由于运行时通过为指针添加值来为对象分配内存，所以这几乎和从堆栈中分配内存一样快。 另外，由于连续分配的新对象在托管堆中是连续存储，所以应用程序可以快速访问这些对象。&lt;/p&gt;
&lt;h5 id=&#34;释放内存&#34;&gt;释放内存&lt;/h5&gt;
&lt;p&gt;垃圾回收器的优化引擎根据所执行的分配决定执行回收的最佳时间。 垃圾回收器在执行回收时，会释放应用程序不再使用的对象的内存。 它通过检查应用程序的根来确定不再使用的对象。 每个应用程序都有一组根。 每个根或者引用托管堆中的对象，或者设置为空。 应用程序的根包含线程堆栈上的静态字段、局部变量和参数以及 CPU 寄存器。 垃圾回收器可以访问由&lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process&#34;&gt;实时 (JIT) 编译器&lt;/a&gt;和运行时维护的活动根的列表。 垃圾回收器对照此列表检查应用程序的根，并在此过程中创建一个图表，在其中包含所有可从这些根中访问的对象。&lt;/p&gt;
&lt;p&gt;不在该图表中的对象将无法从应用程序的根中访问。 垃圾回收器会考虑无法访问的对象垃圾，并释放为它们分配的内存。 在回收中，垃圾回收器检查托管堆，查找无法访问对象所占据的地址空间块。 发现无法访问的对象时，它就使用内存复制功能来压缩内存中可以访问的对象，释放分配给不可访问对象的地址空间块。 在压缩了可访问对象的内存后，垃圾回收器就会做出必要的指针更正，以便应用程序的根指向新地址中的对象。 它还将托管堆指针定位至最后一个可访问对象之后。 请注意，只有在回收发现大量的无法访问的对象时，才会压缩内存。 如果托管堆中的所有对象均未被回收，则不需要压缩内存。&lt;/p&gt;
&lt;p&gt;为了改进性能，运行时为单独堆中的大型对象分配内存。 垃圾回收器会自动释放大型对象的内存。 但是，为了避免移动内存中的大型对象，不会压缩此内存。&lt;/p&gt;
&lt;h5 id=&#34;级别和性能&#34;&gt;级别和性能&lt;/h5&gt;
&lt;p&gt;为优化垃圾回收器的性能，将托管堆分为三代：第 0 代、第 1 代和第 2 代。运行时的垃圾回收算法基于以下几个普遍原理，这些垃圾回收方案的原理已在计算机软件业通过实验得到了证实。 首先，压缩托管堆的一部分内存要比压缩整个托管堆速度快。 其次，较新的对象生存期较短，而较旧的对象生存期则较长。 最后，较新的对象趋向于相互关联，并且大致同时由应用程序访问。&lt;/p&gt;
&lt;p&gt;运行时的垃圾回收器将新对象存储在第 0 级中。 在应用程序生存期的早期创建的对象如果未被回收，则被升级并存储在第 1 级和第 2 级中。因为压缩托管堆的一部分要比压缩整个托管堆速度快，所以此方案允许垃圾回收器在每次执行回收时释放特定级别的内存，而不是整个托管堆的内存。&lt;/p&gt;
&lt;p&gt;实际上，垃圾回收器在第 0 级托管堆已满时执行回收。 如果应用程序在第 0 级托管堆已满时尝试新建对象，垃圾回收器将会发现第 0 级托管堆中没有可分配给该对象的剩余地址空间。 垃圾回收器执行回收，尝试为对象释放第 0 级托管堆中的地址空间。 垃圾回收器从检查第 0 级托管堆中的对象（而不是托管堆中的所有对象）开始执行回收。 这是最有效的途径，因为新对象的生存期往往较短，并且期望在执行回收时，应用程序不再使用第 0 级托管堆中的许多对象。 另外，单独回收第 0 级托管堆通常可以回收足够的内存，这样，应用程序便可以继续创建新对象。&lt;/p&gt;
&lt;p&gt;垃圾回收器执行第 0 级托管堆的回收后，会压缩可访问对象的内存，如本主题前面的&lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/standard/automatic-memory-management#cpconautomaticmemorymanagementreleasingmemoryanchor1&#34;&gt;释放内存&lt;/a&gt;中所述。 然后，垃圾回收器升级这些对象，并考虑第 1 级托管堆的这一部分。 因为未被回收的对象往往具有较长的生存期，所以将它们升级至更高的级别很有意义。 因此，垃圾回收器在每次执行第 0 级托管堆的回收时，不必重新检查第 1 级和第 2 级托管堆中的对象。&lt;/p&gt;
&lt;p&gt;在执行第 0 级托管堆的首次回收并把可访问的对象升级至第 1 级托管堆后，垃圾回收器将考虑第 0 级托管堆的其余部分。 它将继续为第 0 级托管堆中的新对象分配内存，直至第 0 级托管堆已满并需执行另一回收为止。 这时，垃圾回收器的优化引擎会决定是否需要检查较旧的级别中的对象。 例如，如果第 0 级托管堆的回收没有回收足够的内存，不能使应用程序成功完成创建新对象的尝试，垃圾回收器就会先执行第 1 级托管堆的回收，然后再执行第 2 级托管堆的回收。 如果这样仍不能回收足够的内存，垃圾回收器将执行第 2、1 和 0 级托管堆的回收。 每次回收后，垃圾回收器都会压缩第 0 级托管堆中的可访问对象并将它们升级至第 1 级托管堆。 第 1 级托管堆中未被回收的对象将会升级至第 2 级托管堆。 由于垃圾回收器只支持三个级别，因此第 2 级托管堆中未被回收的对象会继续保留在第 2 级托管堆中，直到在将来的回收中确定它们为无法访问为止。&lt;/p&gt;
&lt;p&gt;托管代码就是执行过程交由运行时管理的代码。 在这种情况下，相关的运行时称为公共语言运行时 (CLR)，不管使用的是哪种实现（Mono、.NET Framework 或.NET Core）。 CLR 负责提取托管代码、将其编译成机器代码，然后执行它。 除此之外，运行时还提供多个重要服务，例如自动内存管理、安全边界、类型安全，等等。&lt;/p&gt;
&lt;p&gt;托管的执行过程包括以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择编译器。若要获取公共语言运行时提供的好处，必须使用一个或多个面向运行时的语言编译器。&lt;/li&gt;
&lt;li&gt;将代码编译为 MSIL。编译将你的源代码转换为 Microsoft 中间语言 (MSIL) 并生成必需的元数据。&lt;/li&gt;
&lt;li&gt;将 MSIL 编译为本机代码。在执行时，实时 (JIT) 编译器将 MSIL 转换为本机代码。 在此编译期间，代码必须通过检查 MSIL 和元数据的验证过程以查明是否可以将代码确定为类型安全。&lt;/li&gt;
&lt;li&gt;运行代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公共语言运行时提供启用要发生的执行的基础结构以及执行期间可使用的服务。&lt;/p&gt;
&lt;h3 id=&#34;类class和结构struct的区别是什么它们对性能有影响吗net-bcl里有哪些是类结构为什么它们不是结构类在自定义类型时您如何选择是类还是结构&#34;&gt;类（class）和结构（struct）的区别是什么？它们对性能有影响吗？.NET BCL里有哪些是类（结构），为什么它们不是结构（类）？在自定义类型时，您如何选择是类还是结构？&lt;/h3&gt;
&lt;h4 id=&#34;什么是class和struct&#34;&gt;什么是class和struct&lt;/h4&gt;
&lt;p&gt;class 和struct 最本质的区别: class 是引用类型，它在堆中分配空间，栈中保存的只是引用；而struct 是值类型，它在栈中分配空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是class?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;class（类）是面向对象编程的基本概念，是一种自定义数据结构类型，通常包含字段、属性、方法、构造函数、索引器、操作符等。在.NET中，所有的类都最终继承自 System.Object 类，因此是一种引用类型，也就是说，new 一个类的实例时，在栈（stack）上存放该实例在托管堆（Managed Heap）中的地址，而实例的值保存在托管堆（Managed Heap）中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;托管堆&lt;/strong&gt;（&lt;strong&gt;Managed Heap&lt;/strong&gt;） ：&lt;strong&gt;托管堆&lt;/strong&gt;分配在被操作系统保留的一段内存区域中，这段内存区域是由 CLR 来管理的，这段内存称之为&lt;strong&gt;托管堆&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是struct?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;struct（结构）是一种值类型，用于将一组相关的变量组织为一个单一的变量实体 。所有的结构直接派生自 System.ValueType，间接派生自System.Object，但&lt;strong&gt;结构是隐式密封&lt;/strong&gt;的，不能作为基类再派生出其他的结构，也不能从类派生，但可以从接口派生。struct 实例在创建时分配在线程的栈（stack）上，它本身存储了值。所以在使用 struct 时，我们可以将其当作 int、char 这样的基本类型对待。&lt;/p&gt;
&lt;h4 id=&#34;使用区别&#34;&gt;使用区别&lt;/h4&gt;
&lt;p&gt;class是引用类型，struct是值类型；既然 class 是引用类型，class 可以设为 null；但是我们不能将 struct 设为 null，因为它是值类型。&lt;/p&gt;
&lt;p&gt;当你实例化一个 class，它将创建在&lt;strong&gt;堆&lt;/strong&gt;上。
而你实例化一个 struct，它将创建在&lt;strong&gt;栈&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;你使用的是一个对 class 实例的引用。
而你使用的不是对一个 struct 的引用（而是直接使用它们）。&lt;/p&gt;
&lt;p&gt;当我们将 class 作为参数传给一个方法，
我们传递的是一个引用。struct 传递的是值而非引用。&lt;/p&gt;
&lt;p&gt;class 可以定义析构器，但是 struct 不可以。&lt;/p&gt;
&lt;p&gt;class可以有显示的无参构造器，但是 struct不可以。&lt;/p&gt;
&lt;p&gt;class 的构造器不需要初始化全部字段。
struct 的构造器必须初始化所有字段。&lt;/p&gt;
&lt;p&gt;struct 在声明时不能对实例字段进行赋值。&lt;/p&gt;
&lt;p&gt;class使用前必须new关键字实例化(静态类除外)，struct不需要。&lt;/p&gt;
&lt;p&gt;class 支持继承和多态，struct 不支持。注意：但是 struct 可以和类一样实现接口。&lt;/p&gt;
&lt;p&gt;既然 struct 不支持继承，其成员不能以 protected 或 protected internal 修饰。&lt;/p&gt;
&lt;p&gt;class 比较适合大的和复杂的数据。
struct 适用于作为经常使用的一些数据组合成的新类型。&lt;/p&gt;
&lt;p&gt;struct 类型总是隐式密封的，因此在定义结构时不能使用 sealed 和 abstract 关键字。&lt;/p&gt;
&lt;p&gt;struct的函数成员不能声明为 abstract 和 virtual，但是可以使用 override 关键字，用以覆写它的基类 System.ValueType 中的方法。&lt;/p&gt;
&lt;h4 id=&#34;适用场合&#34;&gt;适用场合&lt;/h4&gt;
&lt;p&gt;struct 有性能优势，class 有面向对象的扩展优势.&lt;/p&gt;
&lt;p&gt;由于结构是值类型，并且直接存储数据，因此在一个对象的主要成员为数据且数据量不大的情况下，使用结构会带来更好的性能.&lt;/p&gt;
&lt;p&gt;将一个结构变量赋值给另一个结构变量，就是把数据从一个结构复制到另一个结构。而类则不同，在类的变量之间，复制的是引用，而不是类数据.&lt;/p&gt;
&lt;p&gt;当把一个结构类型的变量赋值给另一个结构时，对性能的影响取决于结构的大小，当数据比较大的时候，这种数据复制机制会带来较大的开销.&lt;/p&gt;
&lt;p&gt;对于点、矩形和颜色这样的轻量对象，假如要声明一个含有许多个颜色对象的数组，则 CLR 需要为每个对象分配内存，在此情况下，使用结构的成本较低.&lt;/p&gt;
&lt;p&gt;当堆栈的空间很有限，且有大量的逻辑对象时，创建类要比创建结构好一些.&lt;/p&gt;
&lt;p&gt;在表现抽象和多级别的对象层次时，类是最好的选择，因为结构不支持继承.&lt;/p&gt;
&lt;p&gt;用于底层数据存储的类型设计为 struct 类型，将用于定义应用程序行为的类型设计为 class。如果对类型将来的应用情况不能确定，应该使用 class.&lt;/p&gt;
&lt;h3 id=&#34;泛型的作用是什么它有什么优势它对性能有影响吗它在执行时的行为是什么net-bcl中有哪些泛型类型举例说明平时编程中您定义的泛型类型&#34;&gt;泛型的作用是什么？它有什么优势？它对性能有影响吗？它在执行时的行为是什么？.NET BCL中有哪些泛型类型？举例说明平时编程中您定义的泛型类型。&lt;/h3&gt;
&lt;h4 id=&#34;泛型的作用&#34;&gt;泛型的作用&lt;/h4&gt;
&lt;p&gt;泛型的作用在于“算法的重用”。&lt;/p&gt;
&lt;p&gt;比如，原来的ArrayList只能接受Object，现在通过List可以接受任何类型，也就是说ArrayList的方法都被各个类型重用了。但是Dot Net的泛型有个比较制肘地方，就是你很难对数值类型（值类型）进行算法抽象，因为这牵涉到运算符重载的问题，同时Dot Net的泛型的类型参数也不能约束成一个基元值类型，如int、double、float。&lt;/p&gt;
&lt;h4 id=&#34;泛型的优势&#34;&gt;泛型的优势&lt;/h4&gt;
&lt;p&gt;1.源代码保护。&lt;/p&gt;
&lt;p&gt;如果你知道C++模板对泛型的实现机制，就会知道C++在编译的时候根据对泛型的调用，自动“内联”了一个实现，这样泛型的内容就暴露了，尔DotNet的实现方式就不同了，泛型类和方法会被编译成IL，在执行的时候由JIT负责将IL变化为指定类型参数的本地代码，从而保护了源代码。&lt;/p&gt;
&lt;p&gt;2.类型安全。&lt;/p&gt;
&lt;p&gt;这点是最显而易见的，抛弃了使用ArrayList时各种丑陋的强制类型转换&lt;/p&gt;
&lt;p&gt;3.更清晰地代码。&lt;/p&gt;
&lt;p&gt;因为没有了强制类型转换，所以代码自然显得更清晰，但是使用泛型时候带来的&amp;lt;&amp;gt;有时候确实也会让人搞糊涂，幸好泛型方法可以用类型推断或者using语句来进一步简化写法。&lt;/p&gt;
&lt;p&gt;4.更好的性能。&lt;/p&gt;
&lt;p&gt;因为值类型可以避免装箱和拆箱所带来的损耗（垃圾回收的次数也会减少）。这点正是泛型神奇的地方，开发历史上抽象能力的上升往往意味着性能的下降，但是泛型却不是！泛型抽象了算法，但是C++和DotNet对泛型的实现能够让性能无损，并且更快。Java的擦除法泛型就没有这种性能上的好处。&lt;/p&gt;
&lt;h4 id=&#34;对性能的影响&#34;&gt;对性能的影响&lt;/h4&gt;
&lt;p&gt;对性能有积极的影响，因为值类型可以避免装箱和拆箱所带来的负面影响，避免了垃圾回收，使得性能显著提高。但是对引用类型这种影响就不明显了。但是需要注意的是首次为一个特定数据类型调用方法时，CLR都会为这个方法生成本地代码。这会增大应用程序的工作集大小，从而影响性能。&lt;/p&gt;
&lt;h4 id=&#34;泛型在执行时的行为是什么&#34;&gt;泛型在执行时的行为是什么&lt;/h4&gt;
&lt;p&gt;使用泛型类型参数的一个方法在进行JIT编译时，CLR获取IL，用指定的类型实参进行替换，然后创建本地代码。需要特别注意的是引用类型是共享代码的，而对值类型就会为每一种生成独立的一份类型代码。但是需要指出的是引用类型的这种代码共享并不会造成封闭类型只执行一次构造函数（包括静态构造函数）。&lt;/p&gt;
&lt;h4 id=&#34;net-bcl中有哪些泛型类型&#34;&gt;.NET BCL中有哪些泛型类型&lt;/h4&gt;
&lt;p&gt;List、Dictionary、Queue、Stack、SortedList和SortedDictionary、LinkedList等等。&lt;/p&gt;
&lt;h3 id=&#34;异常的作用是什么net-bcl中有哪些常见的异常在代码中您是如何捕获处理异常的在catch-ex中throw和throw-ex有什么区别您会如何设计异常的结构什么情况下您会抛出异常&#34;&gt;异常的作用是什么？.NET BCL中有哪些常见的异常？在代码中您是如何捕获/处理异常的？在“catch (ex)”中，“throw”和“throw ex”有什么区别？您会如何设计异常的结构，什么情况下您会抛出异常？&lt;/h3&gt;
&lt;h4 id=&#34;异常的作用是什么&#34;&gt;异常的作用是什么&lt;/h4&gt;
&lt;p&gt;异常用于处理系统级或者应用程序级的错误状态。异常处理是一种结构化的处理过程，个人认为他最大的优点就在于将“成功场景”剥离出来，使得代码更加清晰自然。但是异常处理相对于返回错误码有一个缺点，那就是他会失去发生异常的位置。不过异常本身提供了很多帮助调试问题的工具，一般都带有栈跟踪，这样位置的问题就得到一定程度的解决。还有就是IF和异常之间的选择，我记得以前有人讨论过在各种分支下是使用异常来处理各种“失败场景”的分支还是使用IF或者SWITCH来处理呢？这其实是一个假问题，因为异常和错误是有概念上的不同的，这里的错误是指有违“主成功场景”的“异常场景”，尔异常是指当程序不能完成其名字所表示功能时的错误。&lt;/p&gt;
&lt;h4 id=&#34;net-bcl中有哪些常见的异常&#34;&gt;.NET BCL中有哪些常见的异常&lt;/h4&gt;
&lt;p&gt;随便说几个，最著名的恐怕就是那句像绕口令一样的“&lt;strong&gt;未将对象引用设置到对象实例&lt;/strong&gt;”了，还有那些基本一出现整个应用程序就被判死刑的“&lt;strong&gt;堆栈溢出&lt;/strong&gt;”、“&lt;strong&gt;内存无法分配&lt;/strong&gt;”异常了&lt;/p&gt;
&lt;h4 id=&#34;在代码中您是如何捕获处理异常的&#34;&gt;在代码中您是如何捕获/处理异常的&lt;/h4&gt;
&lt;p&gt;的最多的CATCH就是抓住数据的异常，然后回滚数据库来事务处理。这是一个典型的场景，因为你明确并且能够很好的恢复状态&lt;/p&gt;
&lt;h4 id=&#34;在catch-ex中throw和throw-ex有什么区别&#34;&gt;在“catch (ex)”中，“throw”和“throw ex”有什么区别&lt;/h4&gt;
&lt;p&gt;throw 重新抛出异常但是不破坏异常发生的调用栈尔“throw ex”会重置调用栈这样捕获异常的人会以为代码出错在这里。&lt;/p&gt;
&lt;p&gt;直接使用throw ex会导致吃掉原始异常点，重置堆栈中的异常起始点&lt;/p&gt;
&lt;p&gt;推荐使用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt;{}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;catch&lt;/span&gt; (Exception ex)
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;经过进一步包装的异常&amp;#34;&lt;/span&gt;, ex);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;listt和t的区别是什么平时你如何进行选择dictionarytkey-tvalue是做什么的net-bcl中还有哪些常用的容器它们分别是如何实现的哪种数据结构分别是适用于哪些场景&#34;&gt;List&lt;!-- raw HTML omitted --&gt;和T[]的区别是什么，平时你如何进行选择？Dictionary&amp;lt;TKey, TValue&amp;gt;是做什么的？.NET BCL中还有哪些常用的容器？它们分别是如何实现的（哪种数据结构）？分别是适用于哪些场景？&lt;/h3&gt;
&lt;p&gt;List&lt;!-- raw HTML omitted --&gt;长度不固定，动态变化，支持方法较多；T[]固定大小的泛型数组。&lt;/p&gt;
&lt;p&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;是泛型字典，提供一对一的关系；&lt;/p&gt;
&lt;p&gt;.Net BCL中常用的集合有Stack&lt;!-- raw HTML omitted --&gt;、Queue&lt;!-- raw HTML omitted --&gt;、LinkedList&lt;!-- raw HTML omitted --&gt;，对应的数据结构是栈、队列和链表。&lt;/p&gt;
&lt;h3 id=&#34;抽象类和接口有什么区别使用时有什么需要注意的吗如何选择是定义一个完全抽象的抽象类还是接口什么是接口的显式实现为什么说它很重要&#34;&gt;抽象类和接口有什么区别？使用时有什么需要注意的吗？如何选择是定义一个“完全抽象”的抽象类，还是接口？什么是接口的“显式实现”？为什么说它很重要？&lt;/h3&gt;
&lt;p&gt;抽象类不能实例化。
抽象类的用途是提供多个派生类可共享基类的公共定义。
抽象类也可以定义抽象方法。
抽象方法没有实现，所以方法定义后面是分号，而不是常规的方法块。
抽象类的派生类必须实现所有抽象方法。
抽象类只能单继承&lt;/p&gt;
&lt;p&gt;接口类似于抽象基类：实现接口的任何非抽象类型都必须实现接口的所有成员。
不能直接实例化接口。
接口可以包含事件、索引器、方法和属性。
接口不包含方法的实现。
类和结构可继承多个接口。
接口自身可从多个接口继承。&lt;/p&gt;
&lt;p&gt;相同点：都不能被实例化，都可以通过继承实现其抽象方法；&lt;/p&gt;
&lt;p&gt;不同点：接口支持多继承，抽象类不能；接口只能定义行为，抽象类既可以定义行为，还能提供实现；接口只包含方法、属性、索引器和事件的签名，不能包括自定义字段和实现方法，抽象类可以包含自定义字段和实现方法。&lt;/p&gt;
&lt;h4 id=&#34;显式地实现接口成员&#34;&gt;显式地实现接口成员&lt;/h4&gt;
&lt;p&gt;即创建一个仅通过该接口调用并且特定于该接口的类成员&lt;/p&gt;
&lt;p&gt;类成员 IControl.Paint 只能通过 IControl 接口使用， ISurface.Paint 只能通过 ISurface 使用。
两个方法实现都是分离的，都不可以直接在类中使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; IControl
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Paint();
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; ISurface
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Paint();
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;SampleClass&lt;/span&gt; : IControl, ISurface
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Paint()
    {
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;SampleClass obj = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; SampleClass();
&lt;span style=&#34;color:#228b22&#34;&gt;//obj.Paint(); // Compiler error.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
IControl c = (IControl)obj;
c.Paint(); &lt;span style=&#34;color:#228b22&#34;&gt;// Calls IControl.Paint on SampleClass.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
ISurface s = (ISurface)obj;
s.Paint(); &lt;span style=&#34;color:#228b22&#34;&gt;// Calls ISurface.Paint on SampleClass.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显式实现还用于解决两个接口分别声明具有相同名称的不同成员（如属性和方法）的情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; ILeft
{
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; P { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;;}
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; IRight
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; P();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了同时实现两个接口，类必须对属性 P 和/或方法 P 使用显式实现以避免编译器错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Middle&lt;/span&gt; : ILeft, IRight
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; P() { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ILeft.P { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt; { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; } }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;抽象类和接口的使用&#34;&gt;抽象类和接口的使用&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单的方法来控制组件版本；&lt;/li&gt;
&lt;li&gt;如果创建的功能将在大范围的全异对象间使用，则使用接口。如果要设计小而简练的功能块，则使用接口；&lt;/li&gt;
&lt;li&gt;如果要设计大的功能单元，则使用抽象类。如果要在组件的所有实现间提供通用的已实现功能，则使用抽象类；&lt;/li&gt;
&lt;li&gt;抽象类主要用于关系密切的对象；而接口适合为不相关的类提供通用功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;字符串是引用类型类型还是结构类型它和普通的引用类型相比有什么特别的地方吗使用字符串时有什么需要注意的地方为什么说stringbuilder比较高效在连接多个字符串时它无论何时都比直接相加更高效吗&#34;&gt;字符串是引用类型类型还是结构类型？它和普通的引用类型相比有什么特别的地方吗？使用字符串时有什么需要注意的地方？为什么说StringBuilder比较高效？在连接多个字符串时，它无论何时都比直接相加更高效吗？&lt;/h3&gt;
&lt;p&gt;MSDN 中明确指出 String 是引用类型而不是值类型，但 String 表面上用起来却像是值类型&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//值类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; a = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; b = a;
a = &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;;
Console.WriteLine(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;a is {0},b is {1}&amp;#34;&lt;/span&gt;, a, b);
 
&lt;span style=&#34;color:#228b22&#34;&gt;//引用类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; str1 = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;ab&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; str2 = str1;
str1 = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;;
Console.WriteLine(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;str1 is {0},str2 is {1}&amp;#34;&lt;/span&gt;, str1, str2);
Console.Read();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;//结果：
a is 2,b is 1
str1 is abc,str2 is ab
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原因：string对象是不可变的，包括长度和其中任何字符都是不可以改变的。&lt;/p&gt;
&lt;h4 id=&#34;string的不变性&#34;&gt;String的不变性&lt;/h4&gt;
&lt;p&gt;string 对象称为不可变的（只读），即字符串恒定性(Immutability)，字符串一经创建，就不可改变。有的时候看来似乎修改了，实际是string经过了特殊处理，每次改变值时都会建立一个新的string对象，变量会指向这个新的对象，而原来的还是指向原来的对象，所以不会改变。这也是string效率低下的原因。如果经常改变string的值则应该使用StringBuilder而不使用string。&lt;/p&gt;
&lt;h4 id=&#34;stringstringbuilder&#34;&gt;String、StringBuilder&lt;/h4&gt;
&lt;p&gt;当大量使用string进行拼接的时候，直接使用string+会影响效率，使用StringBuilder更为合适；&lt;/p&gt;
&lt;p&gt;在连接多个字符串时，StringBuilder并不总是比String高效，对于简单的字符串连接操作，在性能上StringBuilder不一定总是优于String，因为StringBuilder对象的创建代价比较大，在字符串连接目标较少的情况下，过度滥用StringBuilder会导致性能的浪费而非节约。只有大量的或者无法预知次数的字符串操作，才考虑以StringBuilder实现。&lt;/p&gt;
&lt;h3 id=&#34;如何高效地进行数组复制二维数组和数组的数组有什么区别在使用双重循环遍历一个二维数组时如何选择内外层的遍历顺序&#34;&gt;如何高效地进行数组复制？“二维数组”和“数组的数组”有什么区别？在使用双重循环遍历一个二维数组时，如何选择内外层的遍历顺序？&lt;/h3&gt;
&lt;h3 id=&#34;什么是元编程net有哪些元编程的手段和场景什么是反射能否举一些反射的常用场景有人说反射性能较差您怎么看待这个问题有什么办法可以提高反射的性能吗&#34;&gt;什么是元编程，.NET有哪些元编程的手段和场景？什么是反射？能否举一些反射的常用场景？有人说反射性能较差，您怎么看待这个问题？有什么办法可以提高反射的性能吗？&lt;/h3&gt;
&lt;h3 id=&#34;委托是什么匿名方法是什么在c-30中lambda表达式是什么扩展方法是什么linq是什么您觉得c-30中还有哪些重要的特性它们带来了什么优势bcl中哪些类库和这些特性有关您平时最常用哪些&#34;&gt;委托是什么？匿名方法是什么？在C# 3.0中，Lambda表达式是什么？扩展方法是什么？LINQ是什么？您觉得C# 3.0中还有哪些重要的特性，它们带来了什么优势？BCL中哪些类库和这些特性有关？您平时最常用哪些？&lt;/h3&gt;
&lt;h4 id=&#34;委托是什么&#34;&gt;委托是什么&lt;/h4&gt;
&lt;p&gt;MSND:委托是一种引用方法的类型，太抽象了这定义，看不懂&lt;/p&gt;
&lt;p&gt;我的理解是：委托就是对于一组方法的抽象，代表一组方法的共同特征。&lt;/p&gt;
&lt;h4 id=&#34;匿名方法是什么&#34;&gt;匿名方法是什么&lt;/h4&gt;
&lt;p&gt;匿名方法是指将一段代码块作为委托参数传递给另外一个方法中。&lt;/p&gt;
&lt;p&gt;匿名方法能访问方法中的变量和类中的成员。&lt;/p&gt;
&lt;p&gt;使用匿名方法，则不必创建当独的方法，因此减少了实例化委托所需的编码开销。&lt;/p&gt;
&lt;h4 id=&#34;lamdba表达式是什么&#34;&gt;lamdba表达式是什么&lt;/h4&gt;
&lt;p&gt;“Lambda 表达式”是一个匿名函数，它可以包含表达式和语句，并且可用于创建委托或表达式树类型。&lt;/p&gt;
&lt;h4 id=&#34;扩展方法是什么&#34;&gt;扩展方法是什么&lt;/h4&gt;
&lt;p&gt;扩展方法是使我们能在现有类型的基础上添加新方法，而无需创建派生类、重新编译或以其他方式修改原始类型。&lt;/p&gt;
&lt;h4 id=&#34;linq是什么&#34;&gt;LINQ是什么&lt;/h4&gt;
&lt;p&gt;语言级集成查询（Language INtegrated Query），是一组用于c#和Visual Basic语言的扩展。它允许编写C#或者Visual Basic代码以查询数据库相同的方式操作内存数据。&lt;/p&gt;
&lt;h3 id=&#34;工作之外您看哪些技术相关的书网站社区项目等等您还接触哪些net以外的技术能和net或net中有针对性的部分做个对比吗&#34;&gt;工作之外您看哪些技术相关的书、网站、社区、项目等等？您还接触哪些.NET以外的技术，能和.NET或.NET中有针对性的部分做个对比吗？&lt;/h3&gt;
&lt;p&gt;多了去了&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;面试题&#34;&gt;面试题&lt;/h2&gt;
&lt;h3 id=&#34;服务器&#34;&gt;服务器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Kestrel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kestrel 是 ASP.NET Core 项目模板指定的默认 Web 服务器。&lt;/p&gt;
&lt;p&gt;以下部署方案中的 ASP.NET Core 支持 &lt;a href=&#34;https://httpwg.org/specs/rfc7540.html&#34;&gt;HTTP/2&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kestrel
&lt;ul&gt;
&lt;li&gt;操作系统
&lt;ul&gt;
&lt;li&gt;Windows Server 2016/Windows 10 或更高版本†&lt;/li&gt;
&lt;li&gt;具有 OpenSSL 1.0.2 或更高版本的 Linux（例如，Ubuntu 16.04 或更高版本）&lt;/li&gt;
&lt;li&gt;macOS 的未来版本将支持 HTTP/2。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目标框架：.NET Core 2.2 或更高版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTTP.sys
&lt;ul&gt;
&lt;li&gt;Windows Server 2016/Windows 10 或更高版本&lt;/li&gt;
&lt;li&gt;目标框架：不适用于 HTTP.sys 部署。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IIS（进程内）
&lt;ul&gt;
&lt;li&gt;Windows Server 2016/Windows 10 或更高版本；IIS 10 或更高版本&lt;/li&gt;
&lt;li&gt;目标框架：.NET Core 2.2 或更高版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IIS（进程外）
&lt;ul&gt;
&lt;li&gt;Windows Server 2016/Windows 10 或更高版本；IIS 10 或更高版本&lt;/li&gt;
&lt;li&gt;面向公众的边缘服务器连接使用 HTTP/2，但与 Kestrel 的反向代理连接使用 HTTP/1.1。&lt;/li&gt;
&lt;li&gt;目标框架：不适用于 IIS 进程外部署。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Apache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apache对每个请求都会创建一个进程&lt;/strong&gt;, 因此请求越多，进程创建的也越多，&lt;strong&gt;那么整体网站的性能也就越低&lt;/strong&gt;。这是因为每个进程都会占用一定的资源，当进程越来越多的时候，对于整个服务器的性能消耗都是一个很大的影响。当从外部境内的请求持续增长的时候，Apache服务器就会变得越来越慢，处理的越来越吃力了。因为处理的变慢了，就会导致有更多的请求积压下来，从而导致性能进一步降低。这就形成了&lt;strong&gt;恶性的循环&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nginx是用另外一种方式来处理请求的。当请求处理达到一个峰值的时候，会要求这些请求等待，当&lt;strong&gt;有空间的时候再放进来&lt;/strong&gt;。这就是&lt;strong&gt;基于事件为导向的处理方式&lt;/strong&gt;。因为事件消耗的资源，要比进程消耗的资源小的多的多，所以nginx，在同等性能的条件下能够处理4倍于Apache服务器的请求。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;集合类型和泛型&#34;&gt;集合类型和泛型&lt;/h3&gt;
&lt;h4 id=&#34;数组array&#34;&gt;数组(Array)&lt;/h4&gt;
&lt;p&gt;数组具有以下的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数组属于线性结构，在内存中是连续存放的。&lt;/li&gt;
&lt;li&gt;数组的元素类型必须相同。&lt;/li&gt;
&lt;li&gt;数组可以直接通过下标访问。&lt;/li&gt;
&lt;li&gt;数组的查找速度非常快，新增和删除速度慢。&lt;/li&gt;
&lt;li&gt;数组在初始化时要指定数组长度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;动态数组arraylist&#34;&gt;动态数组(ArrayList)&lt;/h4&gt;
&lt;p&gt;动态数组具有以下的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ArrayList的底层其实就是一个数组。&lt;/li&gt;
&lt;li&gt;ArrayList在声明时不必指定长度，会根据存储的数据动态的增加或减少长度。&lt;/li&gt;
&lt;li&gt;ArrayList会把所有的元素都当做Object处理，因此可以存储不同数据类型的元素。&lt;/li&gt;
&lt;li&gt;插入和删除一个元素时，会移动它之后所有元素的位置，效率低，频繁进行插入或者删除元素推荐使用LinkedList。&lt;/li&gt;
&lt;li&gt;ArrayList是非类型安全的，在插入和删除元素时会进行拆箱和装箱问题，影响性能，效率低。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;泛型list&#34;&gt;泛型List&lt;/h4&gt;
&lt;p&gt;泛型List具有以下的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;List是ArrayList的泛型类。&lt;/li&gt;
&lt;li&gt;泛型List需要在声明时指定具体的类型。&lt;/li&gt;
&lt;li&gt;泛型List没有装箱和拆箱操作，因此List比ArrayList效率高而且类型安全。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;双向链表linkedlist&#34;&gt;双向链表（LinkedList）&lt;/h4&gt;
&lt;p&gt;双向链表具有如下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;链表的节点在内存中的空间是不连续的，每块空间称作一个节点，每个节点都存有一个前驱和后置指针，分别指向前一个节点和后一个节点，因此向链表中添加和删除元素的效果高，只需要更改相应节点的指针指向即可。&lt;/li&gt;
&lt;li&gt;链表的查找效率低。查找元素时不能通过下标进行访问，只能从头开始通过地址按顺序查找。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;堆栈stack&#34;&gt;堆栈（Stack）&lt;/h4&gt;
&lt;p&gt;堆栈具有如下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;堆栈是先进后出的原则，最先插入的元素最后被访问，最后插入的元素最先被访问。&lt;/li&gt;
&lt;li&gt;Push入栈，Pop出栈并返回栈顶元素，Peek只返回栈顶元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;queue队列&#34;&gt;Queue（队列）&lt;/h4&gt;
&lt;p&gt;队列具有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;队列是先进先出的原则，最先进入的元素最先被访问，最后进入的元素最后被访问。&lt;/li&gt;
&lt;li&gt;Enqueue入队列，Dequeue出队列并返回列首元素，Peek只返回列首元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;字典dictionary&#34;&gt;字典（Dictionary）&lt;/h4&gt;
&lt;p&gt;字典具有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建字典时需要指定key和value的数据类型。&lt;/li&gt;
&lt;li&gt;字典中的key值是唯一的，value的值可以不唯一。&lt;/li&gt;
&lt;li&gt;可以通过key快速查找对应的value，速度快，但是消耗内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在字典中,数组entries用来存储数据,buckets作为桥梁,每次通过hash function获取了key的哈希值后,对这个哈希值进行取余,即&lt;code&gt;hashResult%bucketsLength=bucketIndex&lt;/code&gt;,余数作为buckets的index,而buckets的value就是这个key对应的entry所在entries中的索引,所以最终我们就可以通过这个索引在entries中拿到我们想要的数据,整个过程不需要对所有数据进行遍历,的时间复杂度为1.&lt;/p&gt;
&lt;h4 id=&#34;几种常见数据结构的使用情景&#34;&gt;几种常见数据结构的使用情景&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据结构&lt;/th&gt;
&lt;th&gt;使用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Array&lt;/td&gt;
&lt;td&gt;需要处理的元素数量确定并且需要使用下标进行访问时可以考虑，不过建议使用List&lt;!-- raw HTML omitted --&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ArrayList&lt;/td&gt;
&lt;td&gt;不推荐使用，建议使用泛型List&lt;!-- raw HTML omitted --&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;List&lt;!-- raw HTML omitted --&gt;&lt;/td&gt;
&lt;td&gt;需要处理的元素数量不确定时，通常建议使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LinkedList&lt;!-- raw HTML omitted --&gt;&lt;/td&gt;
&lt;td&gt;链表适合元素数量不固定，而且需要经常增减节点的情况，链表增减元素效率高。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Queue&lt;!-- raw HTML omitted --&gt;&lt;/td&gt;
&lt;td&gt;队列适合于先进先出的情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Stack&lt;!-- raw HTML omitted --&gt;&lt;/td&gt;
&lt;td&gt;堆栈适合于先进后出的情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dictionary&amp;lt;K,T&amp;gt;&lt;/td&gt;
&lt;td&gt;字典适合于需要键值对操作的情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;许多泛型集合类型均为非泛型类型的直接模拟。 &lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2?view=dotnet-plat-ext-3.1&#34;&gt;Dictionary&lt;/a&gt; 是 &lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.hashtable?view=dotnet-plat-ext-3.1&#34;&gt;Hashtable&lt;/a&gt; 的泛型版本；它使用枚举的泛型结构 &lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.keyvaluepair-2?view=dotnet-plat-ext-3.1&#34;&gt;KeyValuePair&lt;/a&gt;而不是 &lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.dictionaryentry?view=dotnet-plat-ext-3.1&#34;&gt;DictionaryEntry&lt;/a&gt;。 &lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1?view=dotnet-plat-ext-3.1&#34;&gt;List&lt;/a&gt; 是 &lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.arraylist?view=dotnet-plat-ext-3.1&#34;&gt;ArrayList&lt;/a&gt; 的泛型版本。 存在响应非泛型版本的泛型 &lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.queue-1?view=dotnet-plat-ext-3.1&#34;&gt;Queue&lt;/a&gt; 和 &lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.stack-1?view=dotnet-plat-ext-3.1&#34;&gt;Stack&lt;/a&gt; 类。 存在 &lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.sortedlist-2?view=dotnet-plat-ext-3.1&#34;&gt;SortedList&lt;/a&gt; 的泛型和非泛型版本。 这两个版本均为字典和列表的混合。&lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.sorteddictionary-2?view=dotnet-plat-ext-3.1&#34;&gt;SortedDictionary&lt;/a&gt; 泛型类是一个纯字典，并且没有任何非泛型对应项。 &lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.linkedlist-1?view=dotnet-plat-ext-3.1&#34;&gt;LinkedList&lt;/a&gt;泛型类是真正的链接列表，不包含任何非泛型。&lt;/p&gt;
&lt;h4 id=&#34;线程安全&#34;&gt;线程安全&lt;/h4&gt;
&lt;p&gt;ConcurrentDictionary是&lt;code&gt;System.Collections.Concurrent&lt;/code&gt;中&lt;strong&gt;线程安全&lt;/strong&gt;的字典类&lt;/p&gt;
&lt;h4 id=&#34;和equals方法的区别&#34;&gt;==和equals方法的区别&lt;/h4&gt;
&lt;p&gt;首先的区别是，equals 是方法，而 == 是操作符；&lt;/p&gt;
&lt;p&gt;对于基本类型的变量来说（如 short、 int、 long、 float、 double），只能使用 == ，因为这些基本类型的变量没有 equals 方法。对于基本类型变量的比较，使用 == 比较， &lt;code&gt;一般比较的是它们的值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于引用类型的变量来说（例如 String 类）才有 equals 方法，因为 String 继承了 Object 类， equals 是 Object 类的通用方法。对于该类型对象的比较，默认情况下，也就是没有复写 Object 类的 equals 方法，使用 == 和 equals 比较是一样效果的，都是比较的是它们在内存中的存放地址。但是对于某些类来说，为了满足自身业务需求，可能存在 equals 方法被复写的情况，这时使用 equals 方法比较需要看具体的情况，例如 String 类，使用 equals 方法会比较它们的值；&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;聚集索引与非聚集索引&#34;&gt;聚集索引与非聚集索引&lt;/h3&gt;
&lt;p&gt;MSDN介绍索引创建有如下Typical Implementations：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在创建 PRIMARY KEY 约束时，如果不存在该表的聚集索引且未指定唯一非聚集索引，则将自动对一列或多列创建唯一聚集索引。 主键列不允许空值。&lt;/p&gt;
&lt;p&gt;在创建 UNIQUE 约束时，默认情况下将创建唯一非聚集索引，以便强制 UNIQUE 约束。 如果不存在该表的聚集索引，则可以指定唯一聚集索引。&lt;/p&gt;
&lt;p&gt;将索引创建为约束的一部分后，会自动将索引命名为与约束名称相同的名称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PRIMARY KEY and UNIQUE constraints会自动创建索引。登录时，用户名必然是unique的，所以使用用户名查询进行SQL优化时无需再考虑创建索引。&lt;/p&gt;
&lt;h4 id=&#34;聚集索引&#34;&gt;聚集索引&lt;/h4&gt;
&lt;p&gt;MSDN上讲到 &lt;em&gt;A heap is a table without a clustered index&lt;/em&gt; (没有聚集索引的表叫做堆)。B+树是应数据库所需而出现的一种B树的变形树，存储在堆中的数据是无序的（&lt;em&gt;Data is stored in the heap without specifying an order&lt;/em&gt;），那怎么让数据按照B+树的结构存储并以方便查找呢？bingo, it&amp;rsquo;s clustered index.&lt;/p&gt;
&lt;p&gt;在primary key或者unique constraints加上聚集索引后，数据以B+树结构排序，以方便数据库进行查找（B+树的所在章并非树而是查找）。数据库数据存储结构（B+树）如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.openheart.icu/image/B+Tree-20200916191519.png&#34; alt=&#34;B+Tree&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用B+树进行查找在提高关系数据库查找效率的同时，如果频繁的对数据进行增删改树的结构必然会被破坏，数据库将重新梳理索引重建树，聚集索引会给查询以外的操作带来的byproduct，影响增删改的效率。&lt;/p&gt;
&lt;h4 id=&#34;非聚集索引&#34;&gt;非聚集索引&lt;/h4&gt;
&lt;p&gt;非聚集索引与聚集索引类似，只不过是针对unique contraints字段创建的。可以给表中多个字段都加上非聚集索引，数据库就会有多个独立的树结构，每个索引互相之间不存在关联。&lt;/p&gt;
&lt;p&gt;每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。&lt;/p&gt;
&lt;h4 id=&#34;引申&#34;&gt;引申&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;非聚集索引和聚集索引的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过聚集索引可以一次查到需要查找的数据（聚集索引的叶子节点直接指向数据）， 而通过非聚集索引第一次只能查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据（非聚簇索引的叶节点仍然是索引节点，然后由该索引结点指向对应的数据块）。&lt;/p&gt;
&lt;p&gt;聚集索引一张表只能有一个，而非聚集索引一张表可以有多个。&lt;/p&gt;
&lt;p&gt;一般来说聚簇索引 B 树的叶子节点存储的数据，非聚簇索引叶子节点存储指针，所以非聚簇索引要多一次I/O操作才能读取到数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B+ Tree索引和Hash索引区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哈希索引适合等值查询，但是不无法进行范围查询哈希索引没办法利用索引完成排序，哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用聚集索引或者非聚集索引&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;动作描述&lt;/th&gt;
&lt;th&gt;使用聚集索引&lt;/th&gt;
&lt;th&gt;使用非聚集索引&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;列经常被分组排序&lt;/td&gt;
&lt;td&gt;应&lt;/td&gt;
&lt;td&gt;应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;返回某范围内的数据&lt;/td&gt;
&lt;td&gt;应&lt;/td&gt;
&lt;td&gt;不应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;一个或极少不同值&lt;/td&gt;
&lt;td&gt;不应&lt;/td&gt;
&lt;td&gt;不应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;小数目的不同值&lt;/td&gt;
&lt;td&gt;应&lt;/td&gt;
&lt;td&gt;不应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;大数目的不同值&lt;/td&gt;
&lt;td&gt;不应&lt;/td&gt;
&lt;td&gt;应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;频繁更新的列&lt;/td&gt;
&lt;td&gt;不应&lt;/td&gt;
&lt;td&gt;应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;外键列&lt;/td&gt;
&lt;td&gt;应&lt;/td&gt;
&lt;td&gt;应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键列&lt;/td&gt;
&lt;td&gt;应&lt;/td&gt;
&lt;td&gt;应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;频繁修改索引列&lt;/td&gt;
&lt;td&gt;不应&lt;/td&gt;
&lt;td&gt;应&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;复合索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过包含非键列，可以创建覆盖更多查询的非聚集索引。 这是因为非键列具有下列优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们可以是不允许作为索引键列的数据类型。&lt;/li&gt;
&lt;li&gt;在计算索引键列数或索引键大小时， 数据库引擎不考虑它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在where条件中字段用索引，如果用多字段就用复合索引。当查询中的所有列都作为键列或非键列包含在索引中时，带有包含性非键列的索引可以显著提高查询性能。 这样可以实现性能提升，因为查询优化器可以在索引中找到所有列值；不访问表或聚集索引数据，从而减少磁盘 I/O 操作。&lt;/p&gt;
&lt;p&gt;当索引包含查询引用的所有列时，它通常称为“覆盖查询”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;explain，使用执行计划去分析是否走索引，没有索引创建索引，有的话判断索引为什么失效？&lt;/p&gt;
&lt;p&gt;索引什么时候会失效？最左匹配原则、or条件两边有一边没有使用索引、条件字段函数操作、字段类型隐式转换、like以%开头、表中数据较少导致全表比索引快，这些条件都会导致索引失效。&lt;/p&gt;
&lt;p&gt;最左匹配原则：以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&amp;gt;、&amp;lt;、between、like)就会停止匹配&lt;/p&gt;
&lt;p&gt;sqlserver创建分区表的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建文件组&lt;/li&gt;
&lt;li&gt;创建数据文件&lt;/li&gt;
&lt;li&gt;创建分区函数&lt;/li&gt;
&lt;li&gt;创建分区方案&lt;/li&gt;
&lt;li&gt;创建分区表&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;sqlserver中varcharmaxtextxml的区别&#34;&gt;sqlserver中varchar(max)/text/xml的区别&lt;/h3&gt;
&lt;p&gt;varchar(max)=text&lt;/p&gt;
&lt;p&gt;nvarchar(max)=ntext&lt;/p&gt;
&lt;p&gt;varbinary(max)=image&lt;/p&gt;
&lt;p&gt;有了大值数据类型之后，在对大值数据操作的时候要比以前灵活的多了。比如：之前text是不能用‘like’ ‘=’&lt;/p&gt;
&lt;p&gt;如果能保证XML格式的字段永远只存储XMl，而应当用xml数据类型存储XML，XML能的保证格式，并且可能要使用服务器端验证并查询XML。&lt;/p&gt;
&lt;p&gt;char是定长的，会自动空格补足&lt;/p&gt;
&lt;p&gt;varchar(n)&lt;/p&gt;
&lt;p&gt;长度为 n 个字节的可变长度且非 Unicode 的字符数据。n 必须是一个介于 1 和 8,000 之间的数值。存储大小为输入数据的字节的实际长度，而不是 n 个字节。&lt;/p&gt;
&lt;p&gt;nvarchar(n)&lt;/p&gt;
&lt;p&gt;包含 n 个字符的可变长度 Unicode 字符数据。n 的值必须介于 1 与 4,000 之间。字节的存储大小是所输入字符个数的两倍。&lt;/p&gt;
&lt;p&gt;两字段分别有字段值：我和coffee&lt;/p&gt;
&lt;p&gt;那么varchar字段占2×2+6=10个字节的存储空间，而nvarchar字段占8×2=16个字节的存储空间。&lt;/p&gt;
&lt;p&gt;如字段值只是英文可选择varchar，而字段值存在较多的双字节（中文、韩文等）字符时用nvarchar&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;sql-join&#34;&gt;SQL JOIN&lt;/h3&gt;
&lt;p&gt;内连接：（只有2张表匹配的行才能显示）&lt;/p&gt;
&lt;p&gt;左连接：（左边的表不加限制）&lt;/p&gt;
&lt;p&gt;右连接：（右边的表不加限制）&lt;/p&gt;
&lt;p&gt;全外连接：(左右2张表都不加限制）&lt;/p&gt;
&lt;p&gt;UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型 UNION 只选取记录，而UNION ALL会列出所有记录&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;deletetruncate&#34;&gt;delete/truncate&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;delete可以删除表中的一条或多条数据，也可以删除全部数据；而truncate只能将表中的全部数据删除。&lt;/li&gt;
&lt;li&gt;delete删除表数据后，标识字段不能复用。也就是说如果你把id=10（假如id是标识字段）的那行数据删除了，你也不可能再插入一条数据让id=10.&lt;/li&gt;
&lt;li&gt;truncate删除表数据后，标识重新恢复初始状态。默认为初始值为1，也就是说，truncate之后，再插入一条数据，id=1.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;时间复杂度&#34;&gt;时间复杂度&lt;/h3&gt;
&lt;h4 id=&#34;c-中列表字典集合操作的时间复杂度&#34;&gt;C# 中列表、字典、集合操作的时间复杂度&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;List&lt;/strong&gt;列表是顺序线性表，Add操作是O(1)或O(N)，因为List是动态扩容的，在未扩容之前，其Add操作是O(1)，而在扩容的时候，Add操作是O(N)的。其Contains方法，是按照线性检索的，其复杂度是O(n)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SortedList&lt;/strong&gt;列表是有序线性表，Add操作是O(n)，其Contains方法是通过二分查找检索元素的，因此复杂度是O(log n)，其Containskey方法也是通过二分查找检索元素，复杂度也是O(log n)，ContainsValue方法是使用线性查找元素，复杂度是O(n)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashSet&lt;/strong&gt;集合类是包含不重复项的无序hash表(非线性)，它本身是一个一维数组，但是二维链表结构(扩展：一维数组的大小总是2的N次方)。Add操作是O(1)或是O(N)的，原因同List集合类。Contains方法是O(1)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SortedSet&lt;/strong&gt;集合类是基于红黑树实现的，其Add方法是O(lg n)，Contains方法也是O(lg n)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dictionary&lt;/strong&gt;字典类是hash表，Add操作是O(1)或是O(N)的，原理同上。其Containskey方法是O(1)，原因是通过hash来查找元素而不是遍历元素。ContainsValue方法的时间复杂度是O(N)，原因是内部通过遍历key来查找value，而不是通过hash来查找。Item[Key]属性根据key来检索value，其时间复杂度也是O(1)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SortedDictionary&lt;/strong&gt;字典类是基于平衡二叉树实现的，其Add方法是O(lg n),ContainsKey方法也是O(lg n)，而ContainsValue方法则是O(n)。&lt;/p&gt;
&lt;h4 id=&#34;常见算法时间复杂度&#34;&gt;常见算法时间复杂度&lt;/h4&gt;
&lt;p&gt;以下表格统整了一些常用的时间复杂度类。表中，poly(&lt;em&gt;x&lt;/em&gt;) = $x^{O(1)}$，也就是 &lt;em&gt;x&lt;/em&gt; 的多项式。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%B1%BB&#34;&gt;复杂度类&lt;/a&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;运行时间（{\displaystyle T(n)}&lt;img src=&#34;https://wikimedia.org/api/rest_v1/media/math/render/svg/0be5a46684e1279c27414b285fa995f30407d002&#34; alt=&#34;T(n)&#34;&gt;）&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;运行时间举例&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;算法举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%95%B8%E6%99%82%E9%96%93&#34;&gt;常数时间&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(1)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;判断一个二进制数的奇偶&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;反&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B0&#34;&gt;阿克曼&lt;/a&gt;时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(\alpha(n))$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86&#34;&gt;并查集&lt;/a&gt;的单个操作的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%91%8A%E6%97%B6%E9%97%B4&#34;&gt;平摊时间&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%B0%8D%E6%95%B8&#34;&gt;迭代对数&lt;/a&gt;时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(\log^*n)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98&#34;&gt;分布式圆环着色问题&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;对数对数时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(\log \log n)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有界&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97&#34;&gt;优先队列&lt;/a&gt;的单个操作[&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6#cite_note-1&#34;&gt;1]&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;对数时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/DLOGTIME&#34;&gt;DLOGTIME&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(\log n)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$\log n$，$\log n^{2}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2&#34;&gt;二分搜索&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B9%82%E5%AF%B9%E6%95%B0&#34;&gt;幂对数&lt;/a&gt;时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$(\log n)^{O(1)}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$(\log n)^{2}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;（小于1次）幂时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(n^{c})$，其中$ 0&amp;lt;c&amp;lt;1$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$n^{\frac {1}{2}}$，$n^{\frac {2}{3}}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/K-d%E6%A0%91&#34;&gt;K-d树&lt;/a&gt;的搜索操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E6%99%82%E9%96%93&#34;&gt;线性时间&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(n)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$n$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84&#34;&gt;数组&lt;/a&gt;的搜索&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;线性迭代对数时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(n\log ^{*}n)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%E8%90%8A%E5%A7%86%E5%BE%B7%C2%B7%E8%B3%BD%E5%BE%B7%E7%88%BE&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;莱姆德·赛德尔&lt;/a&gt;的&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%E4%B8%89%E8%A7%92%E5%88%86%E5%89%B2%E5%A4%9A%E8%BE%B9%E5%BD%A2&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;三角分割多边形&lt;/a&gt;算法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;线性对数时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(n\log n)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$n\log n$，$\log n!$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;最快的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F&#34;&gt;比较排序&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;二次时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(n^{2})$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$ n^{2}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F&#34;&gt;冒泡排序&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&#34;&gt;插入排序&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;三次时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(n^{3})$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$n^{3}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95&#34;&gt;矩阵乘法&lt;/a&gt;的基本实现，计算&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%E9%83%A8%E5%88%86%E7%9B%B8%E5%85%B3%E6%80%A7&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;部分相关性&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;多项式时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=P_(%E5%A4%8D%E6%9D%82%E6%80%A7)&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;P&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$2^{O(\log n)}=n^{O(1)}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$n$，$n\log n$，$n^{10}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92&#34;&gt;线性规划&lt;/a&gt;中的&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%E5%8D%A1%E9%A6%AC%E5%8D%A1%E6%BC%94%E7%AE%97%E6%B3%95&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;卡马卡算法&lt;/a&gt;，&lt;a href=&#34;https://zh.wikipedia.org/wiki/AKS%E8%B3%AA%E6%95%B8%E6%B8%AC%E8%A9%A6&#34;&gt;AKS质数测试&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;准多项式时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;QP&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$2^{(\log n)O(1)}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;关于&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E5%9B%BE&#34;&gt;有向&lt;/a&gt;&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91%E9%97%AE%E9%A2%98&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;斯坦纳树问题&lt;/a&gt;最著名的{\displaystyle O(\log ^{2}n)}&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95&#34;&gt;近似算法&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;次指数时间（第一定义）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=SUBEXP&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;SUBEXP&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(2^{n^{\epsilon }})$，对任意的$ε &amp;gt; 0$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(2^{(\log n)^{\log \log n}}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;假设复杂性理论推测，&lt;a href=&#34;https://zh.wikipedia.org/wiki/BPP_(%E8%A4%87%E9%9B%9C%E5%BA%A6)&#34;&gt;BPP&lt;/a&gt; 包含在 SUBEXP 中。[&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6#cite_note-bpp-2&#34;&gt;2]&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;次指数时间（第二定义）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$2O(n)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$2^{n^{1/3}}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用于&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3&#34;&gt;整数分解&lt;/a&gt;与&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%E5%9C%96%E5%BD%A2%E5%90%8C%E6%A7%8B%E5%95%8F%E9%A1%8C&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;图形同构问题&lt;/a&gt;的著名算法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B8%E6%99%82%E9%96%93&#34;&gt;指数时间&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=E_(complexity)&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;E&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$2O(n)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$1.1^n, 10^n$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;使用&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&#34;&gt;动态规划&lt;/a&gt;解决&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98&#34;&gt;旅行推销员问题&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;阶乘时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$O(n!)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;em&gt;n&lt;/em&gt;!&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;通过&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2&#34;&gt;暴力搜索&lt;/a&gt;解决旅行推销员问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B8%E6%99%82%E9%96%93&#34;&gt;指数时间&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/EXPTIME&#34;&gt;EXPTIME&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$2poly(n)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$2^n, 2^{n^{2}}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;双重指数时间&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/2-EXPTIME&#34;&gt;2-EXPTIME&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$22poly(n)$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$2^{2^n}$&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;在&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%E9%A0%90%E8%86%A8%E8%84%B9%E7%AE%97%E8%A1%93&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;预膨胀算术&lt;/a&gt;中决定一个给定描述的真实性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;字符串操作&#34;&gt;字符串操作&lt;/h3&gt;
&lt;h4 id=&#34;拼接字符串&#34;&gt;拼接字符串&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&amp;lsquo;&amp;lsquo;+&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步先在内存中分配空间，存储变量的对象。“+=”时，又会重新创建一个对象来存储新的字符串，把创建的字符串指向这个新的地址。&lt;/p&gt;
&lt;p&gt;只有简单拼接无伤大雅，如果有时候需要循环拼接时，就会不断创建新的对象，很浪费性能和内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String.Format()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以看到是先创建一个StringBuilder类型的变量，长度为第一个参数的长度+参数长度的8倍。.Net自动分配一个比较大的容量来存储&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StringBuilder.Append&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;StringBuilder 是预先创建一个比较大的内存，以后每次操作时判断容量上限是否不够用，如果不够用就自动把容量扩大一倍，修改的还是第一次创建的对象的值。&lt;/p&gt;
&lt;p&gt;如果是简单的拼写时，可以用 &amp;ldquo;+=&amp;rdquo;, string.format，循环内拼写很长的字符串时，就需要用到StringBuilder来节省性能和内存了。&lt;/p&gt;
&lt;h4 id=&#34;stringbuilder&#34;&gt;StringBuilder&lt;/h4&gt;
&lt;p&gt;String 对象是不可改变的。每次使用 System.String 类中的方法之一时，都要在内存中创建一个新的字符串对象，这就需要为该新对象分配新的空间。在需要对字符串执行重复修改的情况下，与创建新的 String 对象相关的系统开销可能会非常昂贵。如果要修改字符串而不创建新的对象，则可以使用 System.Text.StringBuilder 类。例如，当在一个循环中将许多字符串连接在一起时，使用 StringBuilder 类可以提升性能。&lt;/p&gt;
&lt;p&gt;通过用一个重载的构造函数方法初始化变量，可以创建 StringBuilder 类的新实例，正如以下示例中所阐释的那样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;StringBuilder  MyStringBuilder = new StringBuilder(&amp;quot;Hello   World!&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;设置容量和长度&#34;&gt;设置容量和长度&lt;/h5&gt;
&lt;p&gt;虽然 StringBuilder 对象是动态对象，允许扩充它所封装的字符串中字符的数量，但是您可以为它可容纳的最大字符数指定一个值。此值称为该对象的容量，不应将它与当前 StringBuilder 对象容纳的字符串长度混淆在一起。例如，可以创建 StringBuilder 类的带有字符串“Hello”（长度为5）的一个新实例，同时可以指定该对象的最大容量为25。当修改 StringBuilder 时，在达到容量之前，它不会为其自己重新分配空间。当达到容量时，将自动分配新的空间且容量翻倍。可以使用重载的构造函数之一来指定 StringBuilder 类的容量。以下代码示例指定可以将 MyStringBuilder 对象扩充到最大 25 个空白。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;StringBuilder MyStringBuilder = new StringBuilder(&amp;quot;Hello   World!&amp;quot;,   25); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外，可以使用读/写 Capacity 属性来设置对象的最大长度。以下代码示例使用 Capacity 属性来定义对象的最大长度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; MyStringBuilder.Capacity = 25;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;EnsureCapacity 方法可用来检查当前 StringBuilder 的容量。如果容量大于传递的值，则不进行任何更改；但是，如果容量小于传递的值，则会更改当前的容量以使其与传递的值匹配。&lt;/p&gt;
&lt;p&gt;也可以查看或设置 Length 属性。如果将 Length 属性设置为大于 Capacity 属性的值，则自动将 Capacity 属性更改为与 Length 属性相同的值。如果将 Length 属性设置为小于当前 StringBuilder 对象内的字符串长度的值，则会缩短该字符串。&lt;/p&gt;
&lt;p&gt;无参的构造方法默认父类AbstractStringBuilder的构造方法，并默认容量为16。&lt;/p&gt;
&lt;p&gt;有参的构造方法初始化容量为参数字符串的长度+16。&lt;/p&gt;
&lt;h5 id=&#34;扩容&#34;&gt;扩容&lt;/h5&gt;
&lt;p&gt;StringBuilder.Length属性指示对象当前包含的字符数 StringBuilder 。 如果向对象添加字符 StringBuilder ，则其长度将增加，直到它等于属性的大小 StringBuilder.Capacity ，该大小定义对象可以包含的字符数。 如果添加的字符数导致对象的长度 StringBuilder 超过其当前容量，则分配新内存，属性的值 Capacity 翻倍，新字符将添加到 StringBuilder 对象中，并 Length 调整其属性。 对象的额外内存 StringBuilder 会动态分配，直到达到属性定义的值 StringBuilder.MaxCapacity 。 达到最大容量时，不能为该对象分配更多的内存 StringBuilder ，尝试添加字符或将其扩展到超出其最大容量后，会引发 ArgumentOutOfRangeException 或 OutOfMemoryException 例外。&lt;/p&gt;
&lt;p&gt;使用append()方法在字符串后面追加东西的时候，如果长度超过了该字符串存储空间大小了就需要进行扩容：构建新的存储空间更大的字符串，将久的复制过去；&lt;/p&gt;
&lt;p&gt;再进行字符串append添加的时候，会先计算添加后字符串大小，先检查是否需要扩容。需要扩容就尝试将新容量扩为大小变成2倍，容量如果还不够，直接扩充到需要的容量大小。&lt;/p&gt;
&lt;p&gt;发生扩容时就可能非常浪费内存，所以在创建时要考虑好字符串的长度，避免扩容的发生。&lt;/p&gt;
&lt;h5 id=&#34;修改-stringbuilder-字符串&#34;&gt;修改 StringBuilder 字符串&lt;/h5&gt;
&lt;p&gt;下表列出了可以用来修改 StringBuilder 的内容的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;StringBuilder.Append   将信息追加到当前   StringBuilder   的结尾。 将根据需要自动分配空间    
StringBuilder.AppendFormat   用带格式文本替换字符串中传递的格式说明符。     
StringBuilder.Insert   将字符串或对象插入到当前   StringBuilder   对象的指定索引处。     
StringBuilder.Remove   从当前   StringBuilder   对象中移除指定数量的字符。     
StringBuilder.Replace   替换指定索引处的指定字符。     
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;析构函数&#34;&gt;析构函数&lt;/h3&gt;
&lt;h4 id=&#34;using-的本质&#34;&gt;using 的本质&lt;/h4&gt;
&lt;p&gt;using 语句可确保调用 Dispose 或 DisposeAsync，即使 using 块中发生异常也是如此。 通过将对象放入 try 块中，然后调用 finally 块中的 Dispose（或 DisposeAsync），可以实现相同的结果；实际上，这就是编译器转换 using 语句的方式。&lt;/p&gt;
&lt;h4 id=&#34;析构函数finalizers-dispose-和-idisposable区别&#34;&gt;析构函数Finalizers Dispose 和 IDisposable区别&lt;/h4&gt;
&lt;p&gt;析构函数(destructor，Finalizers)与构造函数相反，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统自动执行析构函数。 析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，delete会自动调用析构函数后释放内存）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法在结构中定义终结器。 它们仅用于类。&lt;/li&gt;
&lt;li&gt;一个类只能有一个终结器。&lt;/li&gt;
&lt;li&gt;不能继承或重载终结器。&lt;/li&gt;
&lt;li&gt;不能手动调用终结器。 可以自动调用它们。&lt;/li&gt;
&lt;li&gt;终结器不使用修饰符或参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finalize方法（C#中是析构函数，以下称析构函数）是用于释放非托管资源的，而托管资源会由GC自动回收。所以，我们也可以这样来区分 托管和非托管资源。所有会由GC自动回收的资源，就是托管的资源，而不能由GC自动回收的资源，就是非托管资源。在我们的类中直接使用非托管资源的情况很 少，所以基本上不用我们写析构函数。&lt;/p&gt;
&lt;p&gt;大部分的非托管资源会给系统带来很多负面影响，例如数据库连接不被释放就可能导致连接池中的可用数据库连接用尽。文件不关闭会导致其它进程无法读写这个文件等等。&lt;/p&gt;
&lt;p&gt;实现模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于大多数的非托管资源都要求可以手动释放，所以，我们应该专门为释放非托管资源公开一个方法。实现IDispose接口的Dispose方法是最好的模型，因为C#支持using语句块，可以在离开语句块时自动调用Dispose方法。&lt;/li&gt;
&lt;li&gt;虽然可以手动释放非托管资源，我们仍然要在析构函数中释放非托管资源，这样才是安全的应用程序。否则如果因为程序员的疏忽忘记了手动释放非托管资源，那么就会带来灾难性的后果。所以说在析构函数中释放非托管资源，是一种补救的措施，至少对于大多数类来说是如此。&lt;/li&gt;
&lt;li&gt;由于析构函数的调用将导致GC对对象回收的效率降低，所以如果已经完成了析构函数该干的事情（例如释放非托管资源），就应当使用SuppressFinalize方法告诉GC不需要再执行某个对象的析构函数。&lt;/li&gt;
&lt;li&gt;析构函数中只能释放非托管资源而不能对任何托管的对象/资源进行操作。因为你无法预测析构函数的运行时机，所以，当析构函数被执行的时候，也许你进行操作的托管资源已经被释放了。这样将导致严重的后果。&lt;/li&gt;
&lt;li&gt;（这是一个规则）如果一个类拥有一个实现了IDispose接口类型的成员，并创建（注意是创建，而不是接收，必须是由类自己创建）它的实例对象，则这个类也应该实现IDispose接口，并在Dispose方法中调用所有实现了IDispose接口的成员的Dispose方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.NET 垃圾回收器不会分配或释放非托管内存，实现 Dispose 方法主要用于释放非托管资源（Dispose释放托管和非托管资源）。 处理 IDisposable 实现的实例成员时，通常会级联 Dispose 调用。 实现 Dispose 有其他原因，例如，为了释放已分配的内存、删除已添加到集合中的项，或发出释放已获取的锁的信号。&lt;/p&gt;
&lt;p&gt;IDisposable接口提供了一种机制，允许类的用户控制释放资源的时间，但需要确保执行Dispose()&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;reflection&#34;&gt;Reflection&lt;/h3&gt;
&lt;h4 id=&#34;用处与优缺点&#34;&gt;用处与优缺点&lt;/h4&gt;
&lt;p&gt;反射在以下情况下很有用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要访问程序元数据中的特性时。&lt;/li&gt;
&lt;li&gt;检查和实例化程序集中的类型。&lt;/li&gt;
&lt;li&gt;在运行时构建新类型。 使用 System.Reflection.Emit 中的类。&lt;/li&gt;
&lt;li&gt;执行后期绑定，访问在运行时创建的类型上的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;反射提高了程序的灵活性和扩展性。&lt;/li&gt;
&lt;li&gt;降低耦合性，提高自适应能力。&lt;/li&gt;
&lt;li&gt;它允许程序创建和控制任何类的对象，无需提前硬编码目标类。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。&lt;/li&gt;
&lt;li&gt;使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;如何优化&#34;&gt;如何优化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;利用反射读取attribute的时候可以使用静态变量对读取内容进行缓存，减少反射使用次数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;项目更新方式&#34;&gt;项目更新方式&lt;/h3&gt;
&lt;h4 id=&#34;蓝绿部署&#34;&gt;蓝绿部署&lt;/h4&gt;
&lt;p&gt;蓝绿部署涉及两个生产环境：蓝色环境指代正在使用的生产环境。绿色环境则将发布一个新版本。&lt;/p&gt;
&lt;p&gt;以下是蓝绿部署的一些优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可在绿色环境下进行测试，而不会中断蓝色环境。&lt;/li&gt;
&lt;li&gt;切换到绿色环境不需要停机，只需要重定向用户流量。&lt;/li&gt;
&lt;li&gt;问题发生时，可很方便地从绿色环境回滚到蓝色环境，只要将流量重定向回蓝色环境即可，而无需重新构建。&lt;/li&gt;
&lt;li&gt;需要变更时，利用不可变基础设施原则初始化新的实例，避免实例配置产生不一致性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;滚动发布&#34;&gt;滚动发布&lt;/h4&gt;
&lt;p&gt;滚动发布能够解决掉蓝绿部署时对硬件要求增倍的问题。&lt;/p&gt;
&lt;p&gt;先将几台机器从集群中隔离，将流量打到其它机器上。然后升级隔离的机器，进行发布和验证，验证通过后将流量接回。然后循环这个过程，直到集群中所有机器都升级完毕&lt;/p&gt;
&lt;h4 id=&#34;灰度发布金丝雀发布&#34;&gt;灰度发布（金丝雀发布）&lt;/h4&gt;
&lt;p&gt;在灰度发布开始后，先启动一个新版本应用，但是并不直接将流量切过来，而是测试人员对新版本进行线上测试，启动的这个新版本应用，就是我们的金丝雀。如果没有问题，那么可以将少量的用户流量导入到新版本上，然后再对新版本做运行状态观察，收集各种运行时数据，如果此时对新旧版本做各种数据对比，就是所谓的A/B测试。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;多线程异步并发的区别&#34;&gt;多线程/异步/并发的区别&lt;/h3&gt;
&lt;h4 id=&#34;多线程&#34;&gt;多线程&lt;/h4&gt;
&lt;p&gt;多线程是对cpu剩余劳动力的压榨，是一种技术，强调的是并发（想想web server 需要处理大量并发请求的场景）。多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。&lt;/p&gt;
&lt;h4 id=&#34;异步&#34;&gt;异步&lt;/h4&gt;
&lt;p&gt;异步强调的是非阻塞，是一种编程模式（pattern），主要解决了UI响应被阻塞的问题，可借助线程技术或者硬件本身的计算能力解决。&lt;/p&gt;
&lt;p&gt;异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。&lt;/p&gt;
&lt;p&gt;异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。&lt;/p&gt;
&lt;p&gt;异步和同步的区别， 在io等待的时候，同步不会切走，浪费了时间。&lt;/p&gt;
&lt;p&gt;多线程的好处，比较容易的实现了异步切换的思想， 因为异步的程序很难写的。多线程本身程还是以同步完成，但是应该说比效率是比不上异步的。 而且多线很容易写， 相对效率也高。&lt;/p&gt;
&lt;h5 id=&#34;异步原理&#34;&gt;异步原理&lt;/h5&gt;
&lt;p&gt;await修饰的方法返回的是一个Task，而这个Task其实就是一个异步句柄，注册一个回调方法在异步操作完成后继续&lt;/p&gt;
&lt;p&gt;限制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序的Main方法不能转变成异步函数&lt;/li&gt;
&lt;li&gt;构造函数、属性、事件不能转变成异步函数&lt;/li&gt;
&lt;li&gt;不能在catch、finally、unsafe块中使用await操作符&lt;/li&gt;
&lt;li&gt;不能在支持线程锁中使用await操作符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linq中，只能在from子句的第一个集合表达式或join子句的集合表达式中使用await操作符。&lt;/p&gt;
&lt;h4 id=&#34;并发&#34;&gt;并发&lt;/h4&gt;
&lt;p&gt;并行虽然同样也是对cpu剩余劳动力的压榨，且基于多线程技术，但它强调的是高效完成计算任务，而不是并发数量。&lt;/p&gt;
&lt;p&gt;在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互斥&lt;/strong&gt;：进程间相互排斥的使用临界资源的现象，就叫互斥。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。&lt;/p&gt;
&lt;p&gt;其中并发又有伪并发和真并发，伪并发是指单核处理器的并发，真并发是指多核处理器的并发。&lt;/p&gt;
&lt;p&gt;在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事件之间不一定要同一时刻发生。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;sessioncookieapplicationcache&#34;&gt;Session/Cookie/Application/Cache&lt;/h3&gt;
&lt;h4 id=&#34;session&#34;&gt;Session&lt;/h4&gt;
&lt;p&gt;session值是保存在服务器内存上,那么,可以肯定,大量的使用session将导致服务器负担加重. 而viewstate由于只是将数据存入到页面隐藏控件里,不再占用服务器资源,因此, 我们可以将一些需要服务器&amp;quot;记住&amp;quot;的变量和对象保存到viewstate里面. 而sesson则只应该应用在需要跨页面且与每个访问用户相关的变量和对象存储上.&lt;/p&gt;
&lt;p&gt;session在默认情况下20分钟就过期,而viewstate则永远不会过期.&lt;/p&gt;
&lt;p&gt;但viewstate并不是能存储所有的.net类型数据,它仅仅支持String、Integer、Boolean、Array、ArrayList、Hashtable 以及自定义的一些类型。&lt;/p&gt;
&lt;h5 id=&#34;session是如何实现区分用户&#34;&gt;session是如何实现区分用户&lt;/h5&gt;
&lt;p&gt;在服务器端有一个session池，用来存储每个用户提交session中的数据，Session对于每一个客户端（或者说浏览器实例）是“人手一份”，用户首次与Web服务器建立连接的时候，服务器会给用户分发一个SessionID作为标识。SessionID是一个由24个字符组成的随机字符串。用户每次提交页面，浏览器都会把这个SessionID包含在HTTP头中提交给Web服务器，这样Web服务器就能区分当前请求页面的是哪一个客户端,而这个SessionID是一cookie的方式保存的在客户端的内存中的，如果想要得到Session池中的数据，服务器就会根据客户端提交的唯一SessionID标识给出相应的数据返回。&lt;/p&gt;
&lt;p&gt;如果说&lt;strong&gt;Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;生命周期&#34;&gt;生命周期&lt;/h5&gt;
&lt;p&gt;Session保存在服务器端。&lt;strong&gt;为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Session在用户第一次访问服务器的时候自动创建&lt;/strong&gt;。需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session&lt;/strong&gt;。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。&lt;/p&gt;
&lt;h4 id=&#34;cookies&#34;&gt;Cookies&lt;/h4&gt;
&lt;p&gt;HTTP协议下的一种方式,通过该方式,服务器或脚本能够在客户机上维护状态信息；&lt;/p&gt;
&lt;p&gt;就是在客户端保存客户端单独使用的数据的一种方式；&lt;/p&gt;
&lt;p&gt;String格式存放。&lt;/p&gt;
&lt;h4 id=&#34;application全局对象&#34;&gt;Application（全局对象）&lt;/h4&gt;
&lt;p&gt;Application对象生存期和Web应用程序生存期一样长，生存期从Web应用程序网页被访问开始，HttpApplication类对象Application被自动创建，直到没有一个网页被访问时结束，Application对象被自动撤销。因此Application对象中的变量也有相同生存期，并且变量可以被Web应用程序中的所有网页访问。因此，可以在Application对象中建立一些全局的公用变量，由于存储在Application对象中的数值可以被应用程序的所有网页读取，所以Application对象的属性也适合在应用程序的网页之间传递信息。Application对象主要有以下用途：&lt;/p&gt;
&lt;p&gt;​        ● 存储记录在线人数或访问网站总人数的变量。&lt;/p&gt;
&lt;p&gt;​        ● 存储网站共用最新消息，供所有网页更新。&lt;/p&gt;
&lt;p&gt;​        ● 记录网站中个网页同一条广告被点击的次数或时间。&lt;/p&gt;
&lt;p&gt;​        ● 存储供所有网页使用的数据库数据。&lt;/p&gt;
&lt;p&gt;​        ● 不同用之间通讯，例如多用户聊天室，多用户游戏等&lt;/p&gt;
&lt;h4 id=&#34;cache&#34;&gt;Cache&lt;/h4&gt;
&lt;p&gt;​    吃Server記憶體。&lt;/p&gt;
&lt;p&gt;​    可設定時間、hit rate或先進先出來當作條件。&lt;/p&gt;
&lt;p&gt;​    通常應用在靜態網頁快取。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;mvc原理&#34;&gt;MVC原理&lt;/h3&gt;
&lt;p&gt;request-》Controller-》提取数据并完成数据处理工作-》将数据或处理结果呈现给用户-》response&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Convention over Configuration&lt;/strong&gt; (&lt;!-- raw HTML omitted --&gt;约定优先于配置&lt;!-- raw HTML omitted --&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制器的名字以Controller结束，但在URL中不需要写出&amp;quot;Controller&amp;rdquo;&lt;/li&gt;
&lt;li&gt;所有的Controller默认情况下放到名为&amp;quot;Controllers&amp;quot;的文件夹中。&lt;/li&gt;
&lt;li&gt;所有视图放到名为&amp;quot;Views&amp;quot;的文件夹中。每个Controller对应一个与其同名的视图文件夹。&lt;/li&gt;
&lt;li&gt;每个视图文件与对应的Controller中的Action方法同名。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;net-core&#34;&gt;.net core&lt;/h4&gt;
&lt;p&gt;​    1. ASP.NET Core 在运行时首先加载 Program 类下面的 Main 方法，在 Main 方法中指定托管服务器，并调用 Startup 类中的 Configure 和 ConfigureServices 方法等完成初始化；&lt;/p&gt;
&lt;p&gt;​    2.在 ASP.NET Core 中 HTTP 请求是以中间件管道的形式进行处理，每个中间件都可以在 HTTP 请求开始和结束对它进行处理；&lt;/p&gt;
&lt;p&gt;​    3.ASP.NET Core 可以构建跨平台应用，服务运行在 Http.Sys（仅适用于Windows平台）和 Kestrel 上，不需要用IIS进行托管，所以相比传统 ASP.NET 来说性能更高效也更加灵活。&lt;/p&gt;
&lt;h4 id=&#34;net-mvc&#34;&gt;.net mvc&lt;/h4&gt;
&lt;p&gt;​    请求被UrlRoutingModule部件拦截&lt;/p&gt;
&lt;p&gt;​    封装请求上下文HttpContext，成为HttpContextWrapper对象。&lt;/p&gt;
&lt;p&gt;​    根据当前的HttpContext，从Routes集合中得到与当前请求URL相符合的RouteData对象。&lt;/p&gt;
&lt;p&gt;​    将RouteData与HttpContext请求封装成一个RequestContext对象。&lt;/p&gt;
&lt;p&gt;​    根据RequestContext对象，从RouteData的RouteHandler中获取IHttpHandler（MVC里面会有一个IHttpHandler的实现类MvcHandler）。&lt;/p&gt;
&lt;p&gt;​    执行IHttpHandler（MvcHandler），然后就是通过反射激活具体的controller，执行具体的action。&lt;/p&gt;
&lt;p&gt;​    整个过程有两个核心的组件：UrlRoutingModule和MvcHandler，上文提到的各个过程都和两个组件有紧密的联系。而这两个组件分别继承至IHttpModule和IHttpHandler接口，这两个接口在管道事件里面这两个接口扮演着重要角色。&lt;/p&gt;
&lt;p&gt;​        1.UrlRoutingModule的作用可以理解为通过一系列的与路由相关的组件去解析当前请求的Controller与Action名称，其实简单点理解，比如我们请求http://localhost:8080/Home/Index这个url的时候，UrlRoutingModule拦截到这个请求，然后通过一系列的方式得到这里的“Home”和“Index”，这样理解有没有简单一点呢。&lt;/p&gt;
&lt;p&gt;​        2.MvcHandler的作用就更加直接，上述通过拦截组件得到了请求的Controller和Action的名称，MvcHandler组件将当前请求的Controller名称反射得到对应的控制器对象，然后执行对应的Action方法。比如还是上述http://localhost:8080/Home/Index这个请求，通过字符串“Home”反射成为Home这个类型的控制器对象，然后调用这个对象的Index()方法。&lt;/p&gt;
&lt;p&gt;​    综上，联合这两个组件来理解，UrlRoutingMudule组件的主要作用是解析当前的Controller与Action名称，MvcHandler的作用是将得到的Controller名称激活，得到具体的Controller对象，然后执行对应的Action方法。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;js闭包httpsdevelopermozillaorgzh-cndocswebjavascriptclosures&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&#34;&gt;JS闭包&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个函数和对其周围状态（&lt;strong&gt;lexical environment，词法环境&lt;/strong&gt;）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是&lt;strong&gt;闭包&lt;/strong&gt;（&lt;strong&gt;closure&lt;/strong&gt;）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。&lt;/p&gt;
&lt;p&gt;闭包是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。&lt;/p&gt;
&lt;p&gt;闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。&lt;/p&gt;
&lt;p&gt;因此，通常你使用只有一个方法的对象的地方，都可以使用闭包。&lt;/p&gt;
&lt;p&gt;在 Web 中，你想要这样做的情况特别常见。大部分我们所写的 JavaScript 代码都是基于事件的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常作为回调：为响应事件而执行的函数。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;css盒子模型&#34;&gt;CSS盒子模型&lt;/h3&gt;
&lt;p&gt;所有HTML元素可以看作盒子，在CSS中，&amp;ldquo;box model&amp;quot;这一术语是用来设计和布局时使用。CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Margin(外边距)&lt;/strong&gt; - 清除边框外的区域，外边距是透明的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Border(边框)&lt;/strong&gt; - 围绕在内边距和内容外的边框。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Padding(内边距)&lt;/strong&gt; - 清除内容周围的区域，内边距是透明的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Content(内容)&lt;/strong&gt; - 盒子的内容，显示文本和图像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;浏览器的兼容性问题&#34;&gt;浏览器的兼容性问题&lt;/h4&gt;
&lt;p&gt;一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。&lt;/p&gt;
&lt;p&gt;虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。&lt;/p&gt;
&lt;p&gt;IE8 及更早IE版本不支持设置填充的宽度和边框的宽度属性。&lt;/p&gt;
&lt;p&gt;解决IE8及更早版本不兼容问题可以在HTML页面声明 &lt;!-- raw HTML omitted --&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model&#34;&gt;MDN&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;性能监控&#34;&gt;性能监控&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;这个问题遇到过好几次，但之前的工作里面确实没用过性能监控 2020-10-27 18:24:23&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;OneAPM 通过自动探知 Web 端用户、关键应用、数据库请求、外部调用等各层级应用组件，绘制全局拓扑，直观展示组件性能及相互调用时间，其中包括网络耗时。可以实时了解哪些环节成为了系统的性能瓶颈，做出有针对性的优化&lt;/p&gt;
&lt;p&gt;百度应用性能监测中心(&lt;a href=&#34;http://developer.baidu.com/apm/&#34;&gt;http://developer.baidu.com/apm/&lt;/a&gt;)&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;实现用户验证区分角色根据不同的角色访问不同的页面&#34;&gt;实现用户验证/区分角色/根据不同的角色访问不同的页面&lt;/h3&gt;
&lt;p&gt;传统的aspx 在pageload方法中判断session&lt;/p&gt;
&lt;p&gt;MVC razor 直接重写IViewLocationExpander 分权限去不同路径寻找对应views / 如果是前台后台中台 直接使用区域路由 两套多套各自实现各自逻辑&lt;/p&gt;
&lt;p&gt;前后端分离 第一次请求api返回权限，前端控制能否显示，后端控制能否访问 axios ajax&lt;/p&gt;
&lt;p&gt;页面拦截 控制直接浏览器输入访问非本权限页面&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;documentready和onload&#34;&gt;document.ready和onload&lt;/h3&gt;
&lt;p&gt;JavaScript文档加载完成事件&lt;/p&gt;
&lt;p&gt;页面加载完成有两种事件：&lt;/p&gt;
&lt;p&gt;一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）；&lt;/p&gt;
&lt;p&gt;二是onload，指示页面包含图片等文件在内的所有元素都加载完成。&lt;/p&gt;
&lt;p&gt;Dom Ready是在dom加载完成后就可以直接对dom进行操作，比如一张图片只要&lt;!-- raw HTML omitted --&gt;标签完成，不用等这个图片加载完成，就可以设置图片的宽高的属性或样式等；&lt;/p&gt;
&lt;p&gt;Dom Load是在整个document文档（包括了加载图片等其他信息）加载完成后就可以直接对dom进行操作，比如一张图片要等这个图标加载完成之后才能设置图片的宽高的属性或样式等；&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;设计模式&#34;&gt;设计模式&lt;/h3&gt;
&lt;h4 id=&#34;简单工厂工厂方法抽象工厂的区别&#34;&gt;简单工厂/工厂方法/抽象工厂的区别&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;简单工厂&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;描述了一个类， 它拥有一个包含大量条件语句的构建方法， 可根据方法的参数来选择对何种产品进行初始化并将其返回。&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;人们通常会将简单工厂与普通的工厂或其它创建型设计模式混淆。 在绝大多数情况下， 简单工厂是引入工厂方法或抽象工厂模式时的一个中间步骤。&lt;/p&gt;
&lt;p&gt;简单工厂通常没有子类。 但当从一个简单工厂中抽取出子类后， 它看上去就会更像经典的工厂方法模式了。顺便提一句， 如果你将一个简单工厂声明为 abstract类型， 它并不会神奇地变成抽象工厂模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工厂方法&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;如果在基类及其扩展的子类中都有一个构建方法的话， 那它可能就是工厂方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象工厂&lt;/strong&gt;  &lt;!-- raw HTML omitted --&gt;是一种创建型设计模式， 它能创建一系列相关或相互依赖的对象， 而无需指定其具体类。&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;什么是 “系列对象”？ 例如有这样一组的对象：  运输工具+ 引擎+ 控制器 。 它可能会有几个变体：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;汽车+ 内燃机+ 方向盘&lt;/li&gt;
&lt;li&gt;飞机+ 喷气式发动机+ 操纵杆&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你的程序中并不涉及产品系列的话， 那就不需要抽象工厂。再次重申， 许多人分不清抽象工厂模式和声明为 abstract 的简单工厂。 不要犯这个错误！&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;排序&#34;&gt;排序&lt;/h3&gt;
&lt;p&gt;每一次排序之后都能确定至少一个元素位置的排序方法包括：&lt;/p&gt;
&lt;p&gt;1.选择排序：每次将最大的数放到最后。所以最大的数排一次序后位置就确定了。&lt;/p&gt;
&lt;p&gt;2.冒泡排序：同选择排序。每一次排序最大的值位置确定。&lt;/p&gt;
&lt;p&gt;3.快排：每一次排序pivot的位置确定。&lt;/p&gt;
&lt;p&gt;4.堆排序：每一次排序时，都是将堆顶的元素和最后一个节点互换，然后调整堆，再将堆大小减1。所以每一次排序堆顶元素确定。&lt;/p&gt;
&lt;p&gt;不能至少确定一个元素的位置的方法包括：&lt;/p&gt;
&lt;p&gt;1.插入排序：不到最后一步求的都是相对位置。&lt;/p&gt;
&lt;p&gt;2.shell排序：对简单插入排序的改进。不到最后一步，是无法确定每个元素位置的。&lt;/p&gt;
&lt;p&gt;3.归并排序：局部有序，并不能确定任一元素在全局的位置。&lt;/p&gt;
&lt;p&gt;4.基数排序，计数排序：利用桶排序的思路，不是基于比较的排序，也无法在一次排序中确定某个元素的位置。因为每一次排序都是整体处理。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;webservicewcfwebapi&#34;&gt;WebService/WCF/WebAPI&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Web Service&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    它是基于SOAP协议的，数据格式是XML&lt;/p&gt;
&lt;p&gt;​    只支持HTTP协议&lt;/p&gt;
&lt;p&gt;​    它不是开源的，但可以被任意一个了解XML的人使用&lt;/p&gt;
&lt;p&gt;​    它只能部署在IIS上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WCF&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    这个也是基于SOAP的，数据格式是XML&lt;/p&gt;
&lt;p&gt;​    这个是Web Service（ASMX）的进化版，可以支持各种各样的协议，像TCP，HTTP，HTTPS，Named Pipes, MSMQ.&lt;/p&gt;
&lt;p&gt;​    WCF的主要问题是，它配置起来特别的繁琐&lt;/p&gt;
&lt;p&gt;​    它不是开源的，但可以被任意一个了解XML的人使用&lt;/p&gt;
&lt;p&gt;​    它可以部署应用程序中或者IIS上或者Windows服务中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WCF Rest&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    想使用WCF Rest service，你必须在WCF中使用webHttpBindings&lt;/p&gt;
&lt;p&gt;​    它分别用[WebGet]和[WebInvoke]属性，实现了HTTP的GET和POST动词&lt;/p&gt;
&lt;p&gt;​    要想使用其他的HTTP动词，你需要在IIS中做一些配置，使.svc文件可以接受这些动词的请求&lt;/p&gt;
&lt;p&gt;​    使用WebGet通过参数传输数据，也需要配置。而且必须指定UriTemplate&lt;/p&gt;
&lt;p&gt;​    它支持XML、JSON以及ATOM这些数据格式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Web API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    这是一个简单的构建HTTP服务的新框架&lt;/p&gt;
&lt;p&gt;​    在.net平台上Web API 是一个开源的、理想的、构建REST-ful 服务的技术&lt;/p&gt;
&lt;p&gt;​    不像WCF REST Service.它可以使用HTTP的全部特点（比如URIs、request/response头，缓存，版本控制，多种内容格式）&lt;/p&gt;
&lt;p&gt;​    它也支持MVC的特征，像路由、控制器、action、filter、模型绑定、控制反转（IOC）或依赖注入（DI），单元测试。这些可以使程序更简单、更健壮&lt;/p&gt;
&lt;p&gt;​    它可以部署在应用程序和IIS上&lt;/p&gt;
&lt;p&gt;​    这是一个轻量级的框架，并且对限制带宽的设备，比如智能手机等支持的很好&lt;/p&gt;
&lt;p&gt;​    Response可以被Web API的MediaTypeFormatter转换成Json、XML 或者任何你想转换的格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WCF和WEB API我该选择哪个？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你想创建一个支持消息、消息队列、双工通信的服务时，你应该选择WCF&lt;/li&gt;
&lt;li&gt;当你想创建一个服务，可以用更快速的传输通道时，像TCP、Named Pipes或者甚至是UDP（在WCF4.5中）,在其他传输通道不可用的时候也可以支持HTTP。&lt;/li&gt;
&lt;li&gt;当你想创建一个基于HTTP的面向资源的服务并且可以使用HTTP的全部特征时（比如URIs、request/response头，缓存，版本控制，多种内容格式），你应该选择Web API&lt;/li&gt;
&lt;li&gt;当你想让你的服务用于浏览器、手机、iPhone和平板电脑时，你应该选择Web API&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;ajax-httprequest过程&#34;&gt;AJAX HttpRequest过程&lt;/h3&gt;
&lt;p&gt;创建XMLHttpRequest&lt;/p&gt;
&lt;p&gt;连接服务器&lt;/p&gt;
&lt;p&gt;发送请求&lt;/p&gt;
&lt;p&gt;服务器做出响应&lt;/p&gt;
&lt;p&gt;接收响应数据&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;容灾&#34;&gt;容灾&lt;/h3&gt;
&lt;p&gt;软件复制：应用高可用、应用负载均衡、应用配置文件同步、VMware HA&lt;/p&gt;
&lt;p&gt;数据库复制：Oracle DG、MySQL 主从、MSSQL 镜像、日志同步；&lt;/p&gt;
&lt;p&gt;存储复制：EMC Vplex 、IBM SVC、NetAPP MetroCluster。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;aspnet页面生命周期&#34;&gt;ASP.Net页面生命周期&lt;/h3&gt;
&lt;p&gt;每个页面的生命周期为用户的每一次访问，也就是说每一次客户端与服务器之间的一个往返过程.全局变量的生命周期在此之间.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Page_Init();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Load ViewState and Postback data;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Page_Load();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Handle control events;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Page_PreRender();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Page_Render();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Unload event;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dispose method called;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;sql防注入&#34;&gt;SQL防注入&lt;/h3&gt;
&lt;p&gt;使用orm框架/预编译(参数化查询)&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;缓存和db之间怎么保证数据一致性&#34;&gt;缓存和DB之间怎么保证数据一致性&lt;/h3&gt;
&lt;p&gt;缓存预留模式&lt;/p&gt;
&lt;p&gt;​    读操作：先读缓存，缓存没有的话读DB，然后取出数据放入缓存，最后响应数据&lt;/p&gt;
&lt;p&gt;​    写操作：先更新DB，再删除缓存&lt;/p&gt;
&lt;p&gt;为什么是删除而不是更新呢？&lt;/p&gt;
&lt;p&gt;​    原因很简单，复杂场景下缓存不单单是DB中直接取出来的值，此外更新缓存的代价是很高的，频繁更新的缓存到底会不会被频繁访问到？可能更新到缓存里面的数据都是冷数据，频繁失效，所以一般用到再去加载缓存，lazy加载的思想&lt;/p&gt;
&lt;p&gt;先更新DB，再删除缓存的问题，如果更新DB成功，删除缓存失败会导致数据不一致&lt;/p&gt;
&lt;p&gt;​    所以一般是先删除缓存，再更新DB&lt;/p&gt;
&lt;p&gt;还是有问题，A先删除了缓存，但还没更新DB，这时B过来请求数据，发现缓存没有，去请求DB拿到旧数据，然后再写到缓存，等A更新完了DB之后就会出现缓存和DB数据不一致的情况了&lt;/p&gt;
&lt;p&gt;​    更新数据时，根据数据的唯一标识路由到队列中，读取数据时，如果发现数据不再缓存中，那么把读取数据+更新缓存的操作，根据唯一标识路由之后，也发送到相应队列中。一个队列对应一个工作线程，线程串行拿到队列里的操作一一执行&lt;/p&gt;
&lt;p&gt;带来的新问题：&lt;/p&gt;
&lt;p&gt;​    可能数据更新频繁，导致队列中积压了大量的更新操作，读请求长时间阻塞，所以要压测&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;关键字&#34;&gt;关键字&lt;/h3&gt;
&lt;h4 id=&#34;constreadonly&#34;&gt;const/readonly&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/readonly&#34;&gt;readonly&lt;/a&gt; 关键字与 &lt;code&gt;const&lt;/code&gt; 关键字不同。 &lt;code&gt;const&lt;/code&gt; 字段只能在该字段的声明中初始化。 字段可以在声明或构造函数中初始化。 因此，根据所使用的构造函数，&lt;code&gt;readonly&lt;/code&gt; 字段可能具有不同的值。 另外，虽然 &lt;code&gt;const&lt;/code&gt; 字段是编译时常量，但 &lt;code&gt;readonly&lt;/code&gt; 字段可用于运行时常量。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;访问修饰符&#34;&gt;访问修饰符&lt;/h3&gt;
&lt;p&gt;public：同一程序集中的任何其他代码或引用该程序集的其他程序集都可以访问该类型或成员。
private：只有同一 class 或 struct 中的代码可以访问该类型或成员。
protected：只有同一 class 或者从该 class 派生的 class 中的代码可以访问该类型或成员。
internal：同一程序集中的任何代码都可以访问该类型或成员，但其他程序集中的代码不可以。
protected internal：该类型或成员可由对其进行声明的程序集或另一程序集中的派生 class 中的任何代码访问。
private protected：只有在其声明程序集内，通过相同 class 中的代码或派生自该 class 的类型，才能访问类型或成员。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;浏览器输入网址enter之后发生了什么&#34;&gt;浏览器输入网址，Enter之后发生了什么？&lt;/h3&gt;
&lt;p&gt;输入网址后DNS(域名解析协议)将网址转换成对应的IP，然后网络在路由表中查找最适合一条路由连接到对应的服务器ip，也就是刚刚转换的ip。此时，传输层tcp经过三次握手后简历连接，服务器收到http请求(get/post)等后，进行相应的处理并把结果数据返回到浏览器上，此时输入网址后对应的信息就会显示出来。&lt;/p&gt;
- https://www.openheart.icu/cs/dot-net-interview/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>About</title>
        <link>https://www.openheart.icu/about/</link>
        <pubDate>Fri, 17 Jul 2020 22:57:45 +0800</pubDate>
        
        <guid>https://www.openheart.icu/about/</guid>
        <description>42th openheart https://www.openheart.icu/about/ -&lt;h2 id=&#34;关于我&#34;&gt;关于我&lt;/h2&gt;
&lt;p&gt;I am Kris Nie.&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&#34;https://github.com/Hyominn&#34;&gt;@Hyominn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Ins: &lt;a href=&#34;https://www.instagram.com/krisnie42/&#34;&gt;@krisnie42&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Twitter: &lt;a href=&#34;https://twitter.com/hehe54213&#34;&gt;@hehe54213&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;关于本站&lt;/h2&gt;
&lt;p&gt;This is my Hugo blog :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;42th openheart.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用来记录我的第42次不开心&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── Gossip			#谨言慎行
├── ComputerScience		#计算机科学
├── Arithmetic			#算法
├── About			#关于
├── Category			#归类
└── Tags			#标签
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;Thanks for theme makers:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Hugo Theme &lt;a href=&#34;https://github.com/amazingrise/hugo-theme-diary&#34;&gt;Diary&lt;/a&gt; by &lt;a href=&#34;https://amazingrise.net/&#34;&gt;Rise&lt;/a&gt; Ported from &lt;a href=&#34;https://mak1t0.cc/&#34;&gt;Makito&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;https://github.com/SumiMakito/hexo-theme-journal/&#34;&gt;Journal.&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
- https://www.openheart.icu/about/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>206. Reverse Linked List</title>
        <link>https://www.openheart.icu/arithmetic/206.-reverse-linked-list/</link>
        <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/arithmetic/206.-reverse-linked-list/</guid>
        <description>42th openheart https://www.openheart.icu/arithmetic/206.-reverse-linked-list/ -&lt;h1 id=&#34;reverse-a-singly-linked-listhttpsleetcode-cncomproblemsreverse-linked-list&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/reverse-linked-list&#34;&gt;Reverse a singly linked list.&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Follow up:&lt;/p&gt;
&lt;p&gt;A linked list can be reversed either iteratively or recursively. Could you implement both?&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;迭代&#34;&gt;迭代&lt;/h2&gt;
&lt;p&gt;将&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转化为&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NULL&amp;lt;-1&amp;lt;-2&amp;lt;-3&amp;lt;-4&amp;lt;-5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用一个prev节点存储上一个节点（初始为NULL），将当前curr节点的next指向prev节点，prev节点存储curr节点，curr存储curr的原next节点，完成一次迭代。最后返回prev（最后的curr是原ListNode的NULL）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * Definition for singly-linked list.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * public class ListNode {
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *     int val;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *     ListNode next;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *     ListNode(int x) { val = x; }
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * }
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; ListNode &lt;span style=&#34;color:#008b45&#34;&gt;reverseList&lt;/span&gt;(ListNode head) {
    ListNode prev = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
    ListNode curr = head;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (curr != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
        ListNode nextTemp = curr.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt;;
        curr.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; = prev;
        prev = curr;
        curr = nextTemp;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; prev;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;时间复杂度分析&#34;&gt;时间复杂度分析&lt;/h3&gt;
&lt;p&gt;时间复杂度：&lt;em&gt;O&lt;/em&gt;(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：&lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
&lt;h2 id=&#34;递归&#34;&gt;递归&lt;/h2&gt;
&lt;p&gt;将
$$
n_1→&amp;hellip;→n_{k−1}→n_k→n_{k+1}→&amp;hellip;→n_m→∅
$$
转化为
$$
n_1→&amp;hellip;→n_{k−1}→n_k→n_{k+1}←&amp;hellip;←n_m
$$
先转化原链表最后一个节点，然后依次转化直到n&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; ListNode &lt;span style=&#34;color:#008b45&#34;&gt;reverseList&lt;/span&gt;(ListNode head) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (head == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt; || head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; head;
    ListNode p = reverseList(head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt;);
    head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; = head;
    head.&lt;span style=&#34;color:#658b00&#34;&gt;next&lt;/span&gt; = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; p;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;时间复杂度分析-1&#34;&gt;时间复杂度分析&lt;/h3&gt;
&lt;p&gt;时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。&lt;/p&gt;
&lt;p&gt;空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。&lt;/p&gt;
- https://www.openheart.icu/arithmetic/206.-reverse-linked-list/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Computer network</title>
        <link>https://www.openheart.icu/cs/computer-network/</link>
        <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/computer-network/</guid>
        <description>42th openheart https://www.openheart.icu/cs/computer-network/ -&lt;h1 id=&#34;网络的七层架构&#34;&gt;网络的七层架构&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;物理层&lt;/li&gt;
&lt;li&gt;数据链路层&lt;/li&gt;
&lt;li&gt;网络层&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;会话层&lt;/li&gt;
&lt;li&gt;表示层&lt;/li&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;tcpip-原理&#34;&gt;TCP/IP 原理&lt;/h2&gt;
&lt;h2 id=&#34;tcp-三次握手四次挥手&#34;&gt;TCP 三次握手/四次挥手&lt;/h2&gt;
&lt;h3 id=&#34;三次握手&#34;&gt;三次握手&lt;/h3&gt;
&lt;p&gt;TCP 在传输之前会进行三次沟通，一般称为“三次握手”。&lt;/p&gt;
&lt;h3 id=&#34;四次挥手&#34;&gt;四次挥手&lt;/h3&gt;
&lt;p&gt;TCP在传输完数据断开的时候要进行四次沟通，一般称为“四次挥手”。&lt;/p&gt;
- https://www.openheart.icu/cs/computer-network/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
  </channel>
</rss> 