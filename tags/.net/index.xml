<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>.NET on 42th openheart</title>
    <link>https://www.openheart.icu/tags/.net/</link>
    <description>Recent content in .NET on 42th openheart</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>ALL RIGHTS RESERVED KRIS NIE</copyright>
    <lastBuildDate>Sat, 25 Jul 2020 00:14:11 +0000</lastBuildDate>
    
	<atom:link href="https://www.openheart.icu/tags/.net/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C# in Depth</title>
      <link>https://www.openheart.icu/cs/csharp-in-depth/</link>
      <pubDate>Sat, 25 Jul 2020 00:14:11 +0000</pubDate>
      
      <guid>https://www.openheart.icu/cs/csharp-in-depth/</guid>
      <description>本文为「C# in Depth」(4th edition)学习记录。
Implementing the Singleton Pattern in C# 在C＃中实现单例模式。该模式是非常常见的设计模式之一，某个对象全局只需要一个实例时，就可以使用单例模式。它的优点也显而易见：
 它能够避免对象重复创建，节约空间并提升效率 避免由于操作不同实例导致的逻辑错误  以下是原文作者Jon Skeet 对C#单例模式的介绍。
Introduction 单例模式是软件工程中最著名的模式之一。本质上，单例是仅允许创建其自身的单个实例的类，并且通常提供对该实例的简单访问。最常见的是，单例在创建实例时不允许指定任何参数，否则对实例的第二次请求但参数不同可能会出现问题！ （如果应该为具有相同参数的所有请求访问相同的实例，则使用工厂模式更为合适。）本文仅涉及不需要参数的情况。通常，单例的要求是它们是懒惰地创建的，即：直到首次需要实例时才创建实例。
在C＃中有多种不同的方式来实现单例模式。我将在这里以从简到难顺序（in reverse order of elegance）介绍它们，从最常见的线程安全性开始，逐步发展为完全延迟加载，线程安全，简单且高性能的版本。
所有这些实现都有四个共同的特征，但是：
 单个构造函数，私有且无参数。这样可以防止其他类实例化它（这将违反模式）。请注意，它还防止了子类化（subclassing）如果一个单例可以被子类化一次，则可以被子类化两次，并且如果每个子类都可以创建一个实例，则将违反（violated）该模式。如果您需要基本类型的单个实例，则可以使用工厂模式，但是直到运行时才知道确切的类型。 该类是密封的。严格来说，由于上述几点，这是不必要的，但可以帮助JIT进行更多优化。 一个静态变量，其中包含对创建的单个实例的引用（如果有）。 公共静态方法是获取对创建的单个实例的引用，并在必要时创建一个实例。  请注意，所有这些实现还使用公共静态属性Instance作为访问实例的方式。在所有情况下，都可以轻松地将属性转换为方法，而不会影响线程安全性或性能。
First version - not thread-safe // Bad code! Do not use! public sealed class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton Instance { get { if (instance == null) { instance = new Singleton(); } return instance; } } } 如前所述，以上内容不是线程安全的。</description>
    </item>
    
    <item>
      <title>.NET INTERVIEW</title>
      <link>https://www.openheart.icu/cs/dot-net-interview-questions/</link>
      <pubDate>Fri, 17 Jul 2020 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/cs/dot-net-interview-questions/</guid>
      <description>.NET INTERVIEW from Jeffrey Zhao&amp;rsquo;s blog 我在面试.NET/C#程序员时会提出的问题
 什么是.NET？什么是CLI？什么是CLR？IL是什么？JIT是什么，它是如何工作的？GC是什么，简述一下GC的工作方式？ 什么是.net .NET是个平台，你就把它看成C#
一个.NET应用是一个运行于.NET Framework之上的应用程序。（更精确的说，一个.NET应用是一个使用.NET Framework类库来编写，并运行于公共语言运行时 Common Language Runtime之上的应用程序。）如果一个应用程序跟.NET Framework无关，它就不能叫做.NET程序。比如，仅仅使用了XML并不就是.NET应用，仅仅使用SOAP SDK调用一个Web Service也不是.NET应用
开发平台（Dot Net Framework）：包含通用语言运行时（CLR）和Dot Net框架类库（FCL）两个部分。他们提供了一致的编程模型，简化的编程方式，可靠的版本机制（用全局程序集缓存GAC来避免DLL Hell），轻便的部署管理（程序集自带的元数据可以避免ini文件和注册表） ，广泛的平台支持（只要这台机器兼容标准下的CLR和FCL就可以部署，当然运行的时候IL会变成本机代码），无缝的语言集成，自动化的内存管理（垃圾收集），类型安全（CLR会阻止利用缓冲区溢出错误进行的攻击），CLR支持跨语言调试，统一的错误报告，全新的安全策略（CAS），兼容以往的COM组件
什么是CLR CLR(公用语言运行时)和Java虚拟机一样也是一个运行时环境，它负责资源管理（内存分配和垃圾收集），并保证应用和底层操作系统之间必要的分离。.NET提供了一个运行时环境，叫做公用语言运行时（Commen Language Runtime），是一种多语言执行环境，支持众多的数据类型和语言特性。他管理着代码的执行，并使开发过程变得更加简单。这是一种可操控的执行环境，其功能通过编译器与其他工具共同展现。
什么是CLI 通用语言基础结构（Common Language Infrastructure，CLI）是CLR的一个子集，也就是.NET中最终对编译成MSIL代码的应用程序的运行环境进行管理的那一部分。在 CLR结构图中CLI位于下半部分，主要包括类加载器(Class Loader)、实时编译器(IL To Native Compilers)和一个运行时环境的垃圾收集器(Garbage Collector)。CLI是.Net和CLR的灵魂，CLI为IL代码提供运行的环境，你可以将使用任何语言编写的代码通过其特定的编译器转换为 MSIL代码之后运行其上，甚至还可以自己写MSIL代码在CLI上面运行。
什么是IL IL是微软.NET平台上衍生出来的一门中间语言，.NET平台上的各种高级语言（如C#，VB，F#）的编译器会将各自的文字表述方式转化为 IL。各种不同的文字形式最终被统一到了IL的表述方式，其中包含了.NET平台上的各种元素，如“范型”，“类”、、“接口”、“模块”、“属性”等 等。值得注意的是，各种高级语言本身可能根本没有这些“概念”在里头，如IronScheme是一个在.NET平台上的Scheme语言实现，其中根本没有前面提到的这些IL——亦或说是.NET平台上的名词。IL本身并不知道自己是由哪种高级语言转化而来的，哪种语言中有哪些特性，IL也根本不会关心。
什么是JIT JIT（Just In Time, JIT）是.Net边运行边编译的一种机制。
开发人员需要通过IL与CLR进行交流, 虽然IL本身支持一些面向对象的概念, 但是对于开发人员来讲还是过于复杂低效, 于是C#应运而生, 程序员只需编写C#代码, csc编译器会将其翻译成IL;虽然CLR理解IL, 但是CPU只认识二进制指令, 所以CLR需要JIT的帮助, 将IL翻译成CPU指令. JIT按需工作, 当一个.NET方法即将被执行时, JIT会介入, 把该方法(IL指令) 编译成CPU指令, 并保存以供重用。
什么是GC，以及它的工作方式 GC:.NET Framework 的垃圾回收器管理应用程序的内存分配和释放
工作方式：每次您使用 new 运算符创建对象时，运行库都从托管堆为该对象分配内存。只要托管堆中有地址空间可用，运行库就会继续为新对象分配空间。但是，内存不是无限大的。最终，垃 圾回收器必须执行回收以释放一些内存。垃圾回收器优化引擎根据正在进行的分配情况确定执行回收的最佳时间。当垃圾回收器执行回收时，它检查托管堆中不再被 应用程序使用的对象并执行必要的操作来回收它们占用的内存。</description>
    </item>
    
  </channel>
</rss>